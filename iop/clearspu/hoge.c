/* This file was generated by the Hex-Rays decompiler.
	 Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

	 Detected compiler: GNU C++
*/

#include "defz.h"

// rspu2drv/rsd_com.o

static int ret = 0;
static int gMultiVoiceNum = 0;
#ifndef LIB_OSD_100
static volatile int g_AutoDmaIntrCount = 0;
static int g_AutoDmaInProcessing = 0;
#endif

// libspu2/spu.o

vu16 *_spu_RXX = (vu16 *)0xBF900000;
u32 _spu_tsa[2] = {0u, 0u};
u32 _spu_transMode = 0u;
u32 _spu_inTransfer = 1u;
SpuTransferCallbackProc _spu_transferCallback = NULL;
SpuTransferCallbackProc _spu_AutoDMACallback = NULL;
SpuIRQCallbackProc _spu_IRQCallback = NULL;
static int g_DmaCoreIndex = 0;
static int _spu_dma_mode = 0;
static int _spu_transfer_startaddr = 0;
static int _spu_transfer_time = 0;

// libspu2/s_ini.o

u32 _spu_keystat[2] = {0u, 0u};
u32 _spu_trans_mode = SPU_TRANSFER_BY_DMA;
u32 _spu_rev_flag = 0u;
u32 _spu_rev_reserve_wa = 0u;
u32 _spu_rev_offsetaddr = 0u;
SpuReverbAttr _spu_rev_attr = {0u, 0, {0, 0}, 0, 0};
u32 _spu_RQvoice = 0u;
u32 _spu_RQmask = 0u;
s16 _spu_voice_centerNote[2][24] = {
	{
		0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000,
		0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000,
	},
	{
		0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000,
		0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000,
	}};
u32 _spu_env = 0u;
u32 _spu_isCalled = 0u;
SpuIRQCallbackProc _spu_irq_callback = NULL;

// libspu2/s_i.o

int _spu_eea[4] = {15, 15, 0, 0};

// libspu2/s_m.o

int _spu_AllocBlockNum = 0;
int _spu_AllocLastNum = 0;
libspu2_malloc_t *_spu_memList = NULL;

// libspu2/zerobuf.o

u32 _spu_zerobuf[256] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

// libspu2/s_n2p.o

static s16 _spu_NTable[12] = {
	0x8000,
	0x879c,
	0x8fac,
	0x9837,
	0xa145,
	0xaadc,
	0xb504,
	0xbfc8,
	0xcb2f,
	0xd744,
	0xe411,
	0xf1a1,
};
static s16 _spu_FTable[128] = {
	0x8000, 0x800e, 0x801d, 0x802c, 0x803b, 0x804a, 0x8058, 0x8067, 0x8076, 0x8085, 0x8094, 0x80a3, 0x80b1,
	0x80c0, 0x80cf, 0x80de, 0x80ed, 0x80fc, 0x810b, 0x811a, 0x8129, 0x8138, 0x8146, 0x8155, 0x8164, 0x8173,
	0x8182, 0x8191, 0x81a0, 0x81af, 0x81be, 0x81cd, 0x81dc, 0x81eb, 0x81fa, 0x8209, 0x8218, 0x8227, 0x8236,
	0x8245, 0x8254, 0x8263, 0x8272, 0x8282, 0x8291, 0x82a0, 0x82af, 0x82be, 0x82cd, 0x82dc, 0x82eb, 0x82fa,
	0x830a, 0x8319, 0x8328, 0x8337, 0x8346, 0x8355, 0x8364, 0x8374, 0x8383, 0x8392, 0x83a1, 0x83b0, 0x83c0,
	0x83cf, 0x83de, 0x83ed, 0x83fd, 0x840c, 0x841b, 0x842a, 0x843a, 0x8449, 0x8458, 0x8468, 0x8477, 0x8486,
	0x8495, 0x84a5, 0x84b4, 0x84c3, 0x84d3, 0x84e2, 0x84f1, 0x8501, 0x8510, 0x8520, 0x852f, 0x853e, 0x854e,
	0x855d, 0x856d, 0x857c, 0x858b, 0x859b, 0x85aa, 0x85ba, 0x85c9, 0x85d9, 0x85e8, 0x85f8, 0x8607, 0x8617,
	0x8626, 0x8636, 0x8645, 0x8655, 0x8664, 0x8674, 0x8683, 0x8693, 0x86a2, 0x86b2, 0x86c1, 0x86d1, 0x86e0,
	0x86f0, 0x8700, 0x870f, 0x871f, 0x872e, 0x873e, 0x874e, 0x875d, 0x876d, 0x877d, 0x878c,
};

// libspu2/st.o

static unsigned int _st_core = 0u;
static int _spu_st_stat_int = 0;
static int _spu_st_start_voice_bit = 0;
static int _spu_st_start_tmp_voice_bit = 0;
static int _spu_st_start_add_voice_bit = 0;
static int _spu_st_start_prepare_voice_bit = 0;
static int _spu_st_start_prepare_tmp_voice_bit = 0;
static int _spu_st_start_prepared_voice_bit = 0;
static int _spu_st_stop_voice_bit = 0;
static int _spu_st_stop_saved_voice_bit = 0;
static int _spu_st_tmp_voice_bit = 0;

// libspu2/s_rmp1.o

s32 _spu_rev_workareasize[12] = {
	0x2,
	0x4d8,
	0x3e8,
	0x908,
	0xdfc,
	0x15bc,
	0x1ed8,
	0x3008,
	0x3008,
	0x780,
	0x0,
	0x0,
};

// libspu2/s_rmp2.o

libspu2_reverb_param_entry_t _spu_rev_param[10] = {
	{
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	},
	{
		0x0,   0x7d,  0x5b,  0x6d80, 0x54b8, 0xbed0, 0x0,   0x0,   0xba80, 0x5800, 0x5300,
		0x4d6, 0x333, 0x3f0, 0x227,  0x374,  0x1ef,  0x336, 0x1b7, 0x335,  0x1b6,  0x334,
		0x1b5, 0x334, 0x1b5, 0x334,  0x1b5,  0x1b4,  0x136, 0xb8,  0x5c,   0x8000, 0x8000,
	},
	{
		0x0,   0x33,  0x25,  0x70f0, 0x4fa8, 0xbce0, 0x4410, 0xc0f0, 0x9c00, 0x5280, 0x4ec0,
		0x3e4, 0x31b, 0x3a4, 0x2af,  0x372,  0x266,  0x31c,  0x25d,  0x25c,  0x18e,  0x22f,
		0x135, 0x1d2, 0xb7,  0x18f,  0xb5,   0xb4,   0x80,   0x4c,   0x26,   0x8000, 0x8000,
	},
	{
		0x0,   0xb1,  0x7f,  0x70f0, 0x4fa8, 0xbce0, 0x4510, 0xbef0, 0xb4c0, 0x5280, 0x4ec0,
		0x904, 0x76b, 0x824, 0x65f,  0x7a2,  0x616,  0x76c,  0x5ed,  0x5ec,  0x42e,  0x50f,
		0x305, 0x462, 0x2b7, 0x42f,  0x265,  0x264,  0x1b2,  0x100,  0x80,   0x8000, 0x8000,
	},
	{
		0x0,   0xe3,  0xa9,  0x6f60, 0x4fa8, 0xbce0, 0x4510, 0xbef0, 0xa680, 0x5680, 0x52c0,
		0xdfb, 0xb58, 0xd09, 0xa3c,  0xbd9,  0x973,  0xb59,  0x8da,  0x8d9,  0x5e9,  0x7ec,
		0x4b0, 0x6ef, 0x3d2, 0x5ea,  0x31d,  0x31c,  0x238,  0x154,  0xaa,   0x8000, 0x8000,
	},
	{
		0x0,    0x1a5,  0x139,  0x6000, 0x5000, 0x4c00, 0xb800, 0xbc00, 0xc000, 0x6000, 0x5c00,
		0x15ba, 0x11bb, 0x14c2, 0x10bd, 0x11bc, 0xdc1,  0x11c0, 0xdc3,  0xdc0,  0x9c1,  0xbc4,
		0x7c1,  0xa00,  0x6cd,  0x9c2,  0x5c1,  0x5c0,  0x41a,  0x274,  0x13a,  0x8000, 0x8000,
	},
	{
		0x0,    0x33d,  0x231,  0x7e00, 0x5000, 0xb400, 0xb000, 0x4c00, 0xb000, 0x6000, 0x5400,
		0x1ed6, 0x1a31, 0x1d14, 0x183b, 0x1bc2, 0x16b2, 0x1a32, 0x15ef, 0x15ee, 0x1055, 0x1334,
		0xf2d,  0x11f6, 0xc5d,  0x1056, 0xae1,  0xae0,  0x7a2,  0x464,  0x232,  0x8000, 0x8000,
	},
	{
		0x0,    0x3,    0x3,    0x7fff, 0x7fff, 0x0,    0x0,    0x0, 0x8100, 0x0,    0x0,
		0x1ffd, 0xffd,  0x1009, 0x9,    0x0,    0x0,    0x1009, 0x9, 0x1fff, 0x1fff, 0x1ffe,
		0x1ffe, 0x1ffe, 0x1ffe, 0x1ffe, 0x1ffe, 0x1008, 0x1004, 0x8, 0x4,    0x8000, 0x8000,
	},
	{
		0x0,    0x3,    0x3,    0x7fff, 0x7fff, 0x0,    0x0,    0x0, 0x0,    0x0,    0x0,
		0x1ffd, 0xffd,  0x1009, 0x9,    0x0,    0x0,    0x1009, 0x9, 0x1fff, 0x1fff, 0x1ffe,
		0x1ffe, 0x1ffe, 0x1ffe, 0x1ffe, 0x1ffe, 0x1008, 0x1004, 0x8, 0x4,    0x8000, 0x8000,
	},
	{
		0x0,   0x17,  0x13,  0x70f0, 0x4fa8, 0xbce0, 0x4510, 0xbef0, 0x8500, 0x5f80, 0x54c0,
		0x371, 0x2af, 0x2e5, 0x1df,  0x2b0,  0x1d7,  0x358,  0x26a,  0x1d6,  0x11e,  0x12d,
		0xb1,  0x11f, 0x59,  0x1a0,  0xe3,   0x58,   0x40,   0x28,   0x14,   0x8000, 0x8000,
	}};

// libsnd2/ssinit.o

unsigned int _snd_vmask = 0u;
static s16 volume_dat_2[16] = {16383, 16383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

// libsnd2/ssinit_c.o

s16 gPitchCorrect = 0;

// libsnd2/ssstart.o

libsnd2_seq_tick_env_t _snd_seq_tick_env = {60, 1, &SsSeqCalledTbyT, NULL, 0u, 0u, 127u, 0u};
int _snd_seq_interval = 1;

// libsnd2/dmyprint.o

static int is_first_dmy_SsNoteOn = 0;
static int is_first_dmy_SsSetProgramChange = 0;
static int is_first_dmy_SsGetMetaEvent = 0;
static int is_first_dmy_SsSetPitchBend = 0;
static int is_first_dmy_SsSetControlChange = 0;
static int is_first_dmy_SsContBankChange = 0;
static int is_first_dmy_SsContDataEntry = 0;
static int is_first_dmy_SsContMainVol = 0;
static int is_first_dmy_SsContPanpot = 0;
static int is_first_dmy_SsContExpression = 0;
static int is_first_dmy_SsContDamper = 0;
static int is_first_dmy_SsContExternal = 0;
static int is_first_dmy_SsContNrpn1 = 0;
static int is_first_dmy_SsContNrpn2 = 0;
static int is_first_dmy_SsContRpn1 = 0;
static int is_first_dmy_SsContRpn2 = 0;
static int is_first_dmy_SsContResetAll = 0;
static int is_first_dmy_SsSetNrpnVabAttr0 = 0;
static int is_first_dmy_SsSetNrpnVabAttr1 = 0;
static int is_first_dmy_SsSetNrpnVabAttr2 = 0;
static int is_first_dmy_SsSetNrpnVabAttr3 = 0;
static int is_first_dmy_SsSetNrpnVabAttr4 = 0;
static int is_first_dmy_SsSetNrpnVabAttr5 = 0;
static int is_first_dmy_SsSetNrpnVabAttr6 = 0;
static int is_first_dmy_SsSetNrpnVabAttr7 = 0;
static int is_first_dmy_SsSetNrpnVabAttr8 = 0;
static int is_first_dmy_SsSetNrpnVabAttr9 = 0;
static int is_first_dmy_SsSetNrpnVabAttr10 = 0;
static int is_first_dmy_SsSetNrpnVabAttr11 = 0;
static int is_first_dmy_SsSetNrpnVabAttr12 = 0;
static int is_first_dmy_SsSetNrpnVabAttr13 = 0;
static int is_first_dmy_SsSetNrpnVabAttr14 = 0;
static int is_first_dmy_SsSetNrpnVabAttr15 = 0;
static int is_first_dmy_SsSetNrpnVabAttr16 = 0;
static int is_first_dmy_SsSetNrpnVabAttr17 = 0;
static int is_first_dmy_SsSetNrpnVabAttr18 = 0;
static int is_first_dmy_SsSetNrpnVabAttr19 = 0;

// libsnd2/vm/vm_n2p.o

static u16 _svm_ntable[12] = {
	0x8000,
	0x879c,
	0x8fac,
	0x9837,
	0xa145,
	0xaadc,
	0xb504,
	0xbfc8,
	0xcb2f,
	0xd744,
	0xe411,
	0xf1a1,
};
static u16 _svm_ftable[128] = {
	0x8000, 0x800e, 0x801d, 0x802c, 0x803b, 0x804a, 0x8058, 0x8067, 0x8076, 0x8085, 0x8094, 0x80a3, 0x80b1,
	0x80c0, 0x80cf, 0x80de, 0x80ed, 0x80fc, 0x810b, 0x811a, 0x8129, 0x8138, 0x8146, 0x8155, 0x8164, 0x8173,
	0x8182, 0x8191, 0x81a0, 0x81af, 0x81be, 0x81cd, 0x81dc, 0x81eb, 0x81fa, 0x8209, 0x8218, 0x8227, 0x8236,
	0x8245, 0x8254, 0x8263, 0x8272, 0x8282, 0x8291, 0x82a0, 0x82af, 0x82be, 0x82cd, 0x82dc, 0x82eb, 0x82fa,
	0x830a, 0x8319, 0x8328, 0x8337, 0x8346, 0x8355, 0x8364, 0x8374, 0x8383, 0x8392, 0x83a1, 0x83b0, 0x83c0,
	0x83cf, 0x83de, 0x83ed, 0x83fd, 0x840c, 0x841b, 0x842a, 0x843a, 0x8449, 0x8458, 0x8468, 0x8477, 0x8486,
	0x8495, 0x84a5, 0x84b4, 0x84c3, 0x84d3, 0x84e2, 0x84f1, 0x8501, 0x8510, 0x8520, 0x852f, 0x853e, 0x854e,
	0x855d, 0x856d, 0x857c, 0x858b, 0x859b, 0x85aa, 0x85ba, 0x85c9, 0x85d9, 0x85e8, 0x85f8, 0x8607, 0x8617,
	0x8626, 0x8636, 0x8645, 0x8655, 0x8664, 0x8674, 0x8683, 0x8693, 0x86a2, 0x86b2, 0x86c1, 0x86d1, 0x86e0,
	0x86f0, 0x8700, 0x870f, 0x871f, 0x872e, 0x873e, 0x874e, 0x875d, 0x876d, 0x877d, 0x878c,
};

// libsnd2/vm/vs_vtbp.o

static s16 vabid_old_2 = -1;

// rspu2drv/rsd_cb.o

static SpuEECBData eeCBData;

// libspu2/spu.o

static int gMode;
static int gWhichBuff;
static u8 *gHostAddr;
static int gBufferSize48;

// libspu2/st.o

static SpuStEnv _spu_st_Info;
static u32 _spu_st_buf_sizeSBhalf;
static int _spu_st_save_final_block[98];
static int _spu_st_start_prepare_voice_current;
static SpuTransferCallbackProc _spu_st_cb_transfer_saved;
static SpuStCallbackProc _spu_st_cb_prepare_finished;
static int _spu_st_start_prepare_lock;
static int _spu_st_bufferP;
static int _spu_st_start_voice_smallest;
static int _spu_st_stop_voice_smallest;
static SpuIRQCallbackProc _spu_st_cb_IRQ_saved;
static SpuStCallbackProc _spu_st_cb_stream_finished;
static unsigned int _spu_st_addrIRQ;
static int _spu_st_start_tmp_voice_current;
static int _spu_st_start_add_lock;
static SpuStCallbackProc _spu_st_cb_transfer_finished;
static int _spu_st_start_prepare_voice_smallest;

// libspu2/spu.o

u16 _spu_RQ[16];

// libspu2/s_i.o

int _spu_core;

// libspu2/s_ini.o

u16 gDMADeliverEvent;

// libsnd2/ssinit.o

libsnd2_sequence_marker_t _SsMarkCallback[32];
int VBLANK_MINUS;
unsigned int _snd_openflag;
int _snd_ev_flag;
_SsFCALL SsFCALL;
libsnd2_sequence_struct_t *_ss_score[32];
s16 _snd_seq_s_max;
s16 _snd_seq_t_max;

// libsnd2/vm/vm_g.o

s16 _svm_stereo_mono;
int _svm_vab_not_send_size;
SpuReverbAttr _svm_rattr;
char _svm_vab_used[16];
char _SsVmMaxVoice;
s16 _svm_vab_count;
s16 kMaxPrograms;
libsnd2_svm_t _svm_cur;
s16 _svm_damper;
u8 _svm_auto_kof_mode;
VabHdr *_svm_vab_vh[16];
ProgAtr *_svm_vab_pg[16];
VagAtr *_svm_vab_tn[16];
int _svm_vab_start[16];
int _svm_vab_total[16];
VabHdr *_svm_vh;
ProgAtr *_svm_pg;
VagAtr *_svm_tn;

// libsnd2/vm/vm_f.o

u16 _svm_okon1;
int _svm_envx_ptr;
unsigned int _svm_envx_hist[16];
libsnd2_spu_voice_t _svm_voice[24];
u16 _svm_okof1;
u16 _svm_okof2;
u16 _svm_okon2;
libsnd2_auto_vol_pan_callback _autovol;
libsnd2_auto_vol_pan_callback _autopan;
char _svm_sreg_dirty[24];
libsnd2_reg_buffer_struct_t _svm_sreg_buf[24];
libsnd2_reg_buffer_struct_2_t _svm_sreg_buf2[24];
u16 _svm_orev2;
u16 _svm_orev1;
u16 _svm_onos2;
u16 _svm_onos1;

// libsnd2/vm/vm_init.o

static libspu2_malloc_t _ss_spu_vm_rec[32];

// libsnd2/vm/vs_vh.o

s16 gVabOffet[16];

// rspu2drv/rsd_com.o

SpuStEnv *gStPtr;
int gStThid;
static char seq_table[3520];  // sizeof(libsnd2_sequence_struct_t) * 20
static SpuVoiceAttr s_attr;
static SpuCommonAttr c_attr;
static char spu_malloc_rec[1032];  // sizeof(libspu2_malloc_t) * 129
static SpuReverbAttr r_attr;
static int gRpcArg[384];
static char status[24];
SpuStEnv gStBuff;

// rspu2drv/rsd_cb.o

static SifRpcClientData_t cd;

// rspu2drv/rsd_main.o

int _start(int ac, char **av)
{
	const int *BootMode;
	iop_thread_t param;
	int th;

	(void)ac;
	(void)av;
	FlushDcache();
	BootMode = QueryBootMode(3);
	if ( BootMode && (BootMode[1] & 2) != 0 )
		return MODULE_NO_RESIDENT_END;
	CpuEnableIntr();
	param.attr = TH_C;
	param.thread = create_th;
	param.priority = 32;
#ifdef LIB_OSD_100
	param.stacksize = 512;
#else
	param.stacksize = 1024;
#endif
	param.option = 0;
	th = CreateThread(&param);
	if ( th <= 0 )
		return MODULE_NO_RESIDENT_END;
	StartThread(th, 0);
	return MODULE_RESIDENT_END;
}

void create_th(void *userdata)
{
	iop_thread_t param;
	int th;

	(void)userdata;

	if ( !sceSifCheckInit() )
		sceSifInit();
	sceSifInitRpc(0);
	param.attr = TH_C;
	param.thread = sce_spu2_loop;
	param.priority = 34;
#ifdef LIB_OSD_100
	param.stacksize = 2048;
#else
	param.stacksize = 4096;
#endif
	param.option = 0;
	th = CreateThread(&param);
	StartThread(th, 0);
#if 0
	param.attr = TH_C;
	param.thread = sce_osd_spu2_loop;
	param.priority = 35;
#ifdef LIB_OSD_100
	param.stacksize = 4096;
#else
	param.stacksize = 0x2000;
#endif
	param.option = 0;
	gSth = CreateThread(&param);
	StartThread(gSth, 0);
#endif
	SleepThread();
}

// rspu2drv/rsd_com.o

#ifndef LIB_OSD_100
static u8 *g_AutoDmaBuf;
static int g_AutoDmaBufSize;
#endif

#ifndef LIB_OSD_100
static void AutoDmaStatusCB(void)
{
	if ( g_AutoDmaIntrCount < 4 && g_AutoDmaIntrCount >= 0 )
		g_AutoDmaIntrCount += 1;
}

#ifdef LIB_OSD_110
static void AutoDmaClearBuffer(void)
{
	SpuSetTransferStartAddr(0x4800u);
	SpuWrite0(0x800u);
	SpuIsTransferCompleted(1);
}
#endif
#endif

void sce_spu2_loop(void *userdata)
{
	SifRpcDataQueue_t qd;
	SifRpcServerData_t sd;

	(void)userdata;

	CpuEnableIntr();
	EnableIntr(IOP_IRQ_DMA_SPU);
	EnableIntr(IOP_IRQ_DMA_SPU2);
	EnableIntr(IOP_IRQ_SPU);
	sceSifSetRpcQueue(&qd, GetThreadId());
	sceSifRegisterRpc(&sd, sce_SPU_DEV, (SifRpcFunc_t)spuFunc, gRpcArg, 0, 0, &qd);
	sceSifRpcLoop(&qd);
}

int AutoDmaWaitForCompletion(unsigned int played_size, int start_wait_count)
{
	for ( ; start_wait_count <= 949999; start_wait_count += 1 )
	{
		unsigned int v3;
		unsigned int v4;

		v3 = SpuAutoDMAGetStatus();
		if ( (((v3 >> 24)) & 0xFF) == 1 )
			v4 = (v3 & 0xFFFFFF) - (u32)g_AutoDmaBuf - g_AutoDmaBufSize / 2;
		else
			v4 = (v3 & 0xFFFFFF) - (u32)g_AutoDmaBuf;
		if ( v4 >= played_size )
			break;
		__asm__ __volatile__("" : "+g"(start_wait_count) : :);
	}
	return start_wait_count;
}

void *spuFunc(unsigned int command, void *data, int size)
{
	(void)size;

	switch ( command )
	{
		case 0x0001:
			SpuInit();
			break;
		case 0x0002:
			ret = SpuSetCore(*((u32 *)data + 1));
			break;
		case 0x0005:
			SpuSetKey(*((u32 *)data + 1), *((u32 *)data + 2));
			break;
		case 0x0006:
			ret = SpuSetReverb(*((u32 *)data + 1));
			break;
		case 0x0007:
			ret = SpuClearReverbWorkArea(*((u32 *)data + 1));
			break;
		case 0x0008:
			SpuSetReverbEndAddr(*((u32 *)data + 1));
			break;
		case 0x000A:
			SpuSetReverbModeDepth(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x000B:
			ret = SpuSetReverbVoice(*((u32 *)data + 1), *((u32 *)data + 2));
			break;
		case 0x000C:
			ret = SpuSetIRQ(*((u32 *)data + 1));
			break;
		case 0x000D:
			ret = SpuSetIRQAddr(*((u32 *)data + 1));
			break;
		case 0x000E:
			ret = SpuSetTransferMode(*((u32 *)data + 1));
			break;
		case 0x0010:
			ret = SpuSetTransferStartAddr(*((u32 *)data + 1));
			break;
		case 0x0011:
			ret = SpuWrite(*((u8 **)data + 1), *((u32 *)data + 2));
			break;
		case 0x0012:
			ret = SpuWrite0(*((u32 *)data + 1));
			break;
		case 0x0013:
			ret = SpuIsTransferCompleted(*((u32 *)data + 1));
			break;
		case 0x0017:
			ret = SpuGetReverbEndAddr();
			break;
		case 0x0018:
			ret = SpuWritePartly(*((u8 **)data + 1), *((u32 *)data + 2));
			break;
		case 0x0019:
			SpuInitHot();
			break;
		case 0x001A:
			ret = SpuIsReverbWorkAreaReserved(*((u32 *)data + 1));
			break;
		case 0x001B:
			ret = SpuMallocWithStartAddr(*((u32 *)data + 1), *((u32 *)data + 2));
			break;
		case 0x001C:
			ret = SpuRead(*((u8 **)data + 1), *((u32 *)data + 2));
			break;
		case 0x001D:
			ret = SpuReadDecodedData(*((SpuDecodedData **)data + 1), *((u32 *)data + 2));
			break;
		case 0x001E:
			ret = SpuReserveReverbWorkArea(*((u32 *)data + 1));
			break;
		case 0x0020:
			ret = SpuSetMute(*((u32 *)data + 1));
			break;
		case 0x0021:
			ret = SpuSetNoiseClock(*((u32 *)data + 1));
			break;
		case 0x0022:
			ret = SpuSetNoiseVoice(*((u32 *)data + 1), *((u32 *)data + 2));
			break;
		case 0x0023:
			ret = SpuSetPitchLFOVoice(*((u32 *)data + 1), *((u32 *)data + 2));
			break;
		case 0x0024:
			ret = SpuStGetStatus();
			break;
		case 0x0025:
			ret = SpuStGetVoiceStatus();
			break;
		case 0x0100:
			ret = SpuInitMalloc(*((u32 *)data + 1), spu_malloc_rec);
			break;
		case 0x0101:
			ret = SpuMalloc(*((u32 *)data + 1));
			break;
		case 0x0200:
		{
			gStPtr = SpuStInit(*((u32 *)data + 1));
			ret = (int)&gStBuff;
			SpuStSetPreparationFinishedCallback(spustCB_preparation_finished);
			SpuStSetTransferFinishedCallback(spustCB_transfer_finished);
			SpuStSetStreamFinishedCallback(spustCB_stream_finished);
			break;
		}
		case 0x0201:
			ret = SpuStQuit();
			break;
		case 0x0202:
		{
			memcpy(gStPtr, &gStBuff, sizeof(SpuStEnv));
			ret = SpuStTransfer(*((u32 *)data + 1), *((u32 *)data + 2));
			break;
		}
		case 0x0203:
			ret = SpuStSetCore(*((u32 *)data + 1));
			break;
		case 0x100C:
			ret = SpuGetIRQAddr();
			break;
		case 0x1010:
			ret = SpuFlush(*((u32 *)data + 1));
			break;
		case 0x1011:
			SpuFree(*((u32 *)data + 1));
			break;
		case 0x1013:
			ret = SpuGetIRQ();
			break;
		case 0x1014:
			ret = SpuGetMute();
			break;
		case 0x1015:
			ret = SpuGetNoiseClock();
			break;
		case 0x1016:
			ret = SpuGetNoiseVoice();
			break;
		case 0x1017:
			ret = SpuGetPitchLFOVoice();
			break;
		case 0x1018:
			ret = SpuGetReverb();
			break;
		case 0x1019:
			ret = SpuGetReverbVoice();
			break;
		case 0x101A:
			ret = SpuGetTransferMode();
			break;
		case 0x101B:
			ret = SpuGetTransferStartAddr();
			break;
		case 0x101C:
			ret = SpuGetKeyStatus(*((u32 *)data + 1));
			break;
		case 0x1020:
		{
#ifdef LIB_OSD_100
			ret = SpuAutoDMAWrite(*((u8 **)data + 1), *((u32 *)data + 2), *((u32 *)data + 3));
#else
			if ( g_AutoDmaInProcessing )
			{
				ret = 0;
			}
			else
			{
				u32 *v7;
				int ii;
				int jj;
				int kk;

#ifdef LIB_OSD_110
				AutoDmaClearBuffer();
#endif
				SpuAutoDMASetCallback(AutoDmaStatusCB);
				g_AutoDmaBuf = (u8 *)*((u32 *)data + 1);
				g_AutoDmaBufSize = *((u32 *)data + 2);
				v7 = (u32 *)(g_AutoDmaBuf + 0x3000);
				memset((void *)g_AutoDmaBuf, 0, 0x3000);
				for ( ii = 0; ii < 512; ii += 128 )
				{
					for ( jj = 0; jj < 128; jj += 1 )
					{
						v7[jj] = v7[jj] / 512 * (jj + ii);
					}
					for ( kk = 0; kk < 128; kk += 1 )
					{
						v7[kk] = v7[kk] / 512 * (kk + ii);
					}
				}
				g_AutoDmaIntrCount = 10;
				ret = SpuAutoDMAWrite(*((u8 **)data + 1), *((u32 *)data + 2), *((u32 *)data + 3));
				g_AutoDmaInProcessing = 1;
			}
#endif
			break;
		}
		case 0x1021:
		{
#ifdef LIB_OSD_100
			SpuAutoDMAStop();
#else
			int n;
			u32 *v3;
			void *v4;
			int v5;
			int v11;
			int j;
			int k;
			int m;
#ifndef LIB_OSD_110
			u32 *v12;
			int v19;
			int v20;
			size_t sizea;
#endif

			if ( g_AutoDmaInProcessing )
			{
				v11 = SpuAutoDMAGetStatus();
				if ( v11 >> 24 == 1 )
					v5 = (v11 & 0xFFFFFF) - (u32)g_AutoDmaBuf - g_AutoDmaBufSize / 2;
				else
					v5 = (v11 & 0xFFFFFF) - (u32)g_AutoDmaBuf;
#ifdef LIB_OSD_110
				if ( v5 > 0xbfff )
#else
				if ( v5 >= 0x6000 )
#endif
				{
					while ( v5 <= 0xefff )
					{
						v5 = SpuAutoDMAGetStatus();
						if ( v5 >> 24 == 1 )
							v5 = (v5 & 0xFFFFFF) - (u32)g_AutoDmaBuf - g_AutoDmaBufSize / 2;
						else
							v5 = (v5 & 0xFFFFFF) - (u32)g_AutoDmaBuf;
					}
#ifndef LIB_OSD_110
					v19 = 0;
					v20 = 0x1c00;
					sizea = 0x2000;
					g_AutoDmaIntrCount = 0;
#endif
					if ( v11 >> 24 == 1 )
					{
						v3 = (u32 *)g_AutoDmaBuf;
						v4 = (void *)(g_AutoDmaBufSize / 2 + g_AutoDmaBuf);
					}
					else
					{
						v3 = (u32 *)(g_AutoDmaBufSize / 2 + g_AutoDmaBuf);
						v4 = (void *)g_AutoDmaBuf;
					}
				}
				else
				{
#ifndef LIB_OSD_110
					v19 = ((v5 + 1023) / 1024) << 10;
					v20 = 0x2000 - ((v19 + ((((v5 + 1023) / 1024) & 0x200000) != 0 ? 0x3FF : 0)) >> 10 << 7);
					sizea = 0;
					g_AutoDmaIntrCount = 0;
#endif
					if ( v11 >> 24 == 1 )
					{
						v3 = (u32 *)(g_AutoDmaBufSize / 2 + g_AutoDmaBuf);
						v4 = (void *)g_AutoDmaBuf;
					}
					else
					{
						v3 = (u32 *)g_AutoDmaBuf;
						v4 = (void *)(g_AutoDmaBufSize / 2 + g_AutoDmaBuf);
					}
				}
#ifdef LIB_OSD_110
				for ( j = 0; j < 0x2000; j += 128 )
				{
					for ( k = 0; k < 128; k += 1 )
					{
						v3[k] = v3[k] / 0x2000 * (0x2000 - j - k);
					}
					for ( m = 0; m < 128; m += 1 )
					{
						v3[m] = v3[m] / 0x2000 * (0x2000 - j - m);
					}
				}
				memset(v4, 0, g_AutoDmaBufSize / 2);
				g_AutoDmaIntrCount = 0;
				for ( n = 0; g_AutoDmaIntrCount < 2 && n <= 949999; n += 1 )
				{
					__asm__ __volatile__("" : "+g"(n) : :);
				}
#else
				v12 = &v3[v19 / 4];
				for ( j = 0; j < v20; j += 128 )
				{
					for ( k = 0; k < 128; k += 1 )
					{
						if ( !v20 )
							__builtin_trap();
						if ( v20 == -1 && *v12 == 0x80000000 )
							__builtin_trap();
						v12[k] = v12[k] / v20 * (v20 - k - j);
					}
					for ( m = 0; m < 128; m += 1 )
					{
						if ( !v20 )
							__builtin_trap();
						if ( v20 == -1 && *v12 == 0x80000000 )
							__builtin_trap();
						v12[m] = v12[m] / v20 * (v20 - m - j);
					}
				}
				if ( sizea )
					memset(v12, 0, sizea);
				if ( v5 >= 0x6000 )
				{
					n = 0;
					for ( ; g_AutoDmaIntrCount <= 0 && n <= 949999; n += 1 )
					{
						__asm__ __volatile__("" : "+g"(n) : :);
					}
					memset(v4, 0, g_AutoDmaBufSize / 2);
					for ( ; g_AutoDmaIntrCount < 2 && n <= 949999; n += 1 )
					{
						__asm__ __volatile__("" : "+g"(n) : :);
					}
				}
				else
				{
					n = AutoDmaWaitForCompletion(0xF000u, 0);
					memset(v4, 0, g_AutoDmaBufSize / 2);
					for ( ; g_AutoDmaIntrCount <= 0 && n <= 949999; n += 1 )
					{
						__asm__ __volatile__("" : "+g"(n) : :);
					}
				}
				memset(v3, 0, g_AutoDmaBufSize / 2);
				AutoDmaWaitForCompletion(0x4001 - sizea, n);
#endif
				SpuAutoDMAStop();
#ifdef LIB_OSD_110
				AutoDmaClearBuffer();
#endif
				g_AutoDmaInProcessing = 0;
			}
#endif
			break;
		}
		case 0x1022:
			ret = SpuAutoDMAGetStatus();
			break;
		case 0x1023:
			SpuSetAutoDMAAttr(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6), *((u16 *)data + 8));
			break;
		case 0x1024:
			SpuSetSerialInAttr(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x1030:
			gMultiVoiceNum = *((u32 *)data + 1);
			break;
		case 0x1031:
			SpuSetDigitalOut(*((u32 *)data + 1));
			break;
		case 0x4001:
			ret = SsBlockVoiceAllocation();
			break;
		case 0x4002:
			SsEnd();
			break;
		case 0x4003:
			SsChannelMute(*((u16 *)data + 2), *((u16 *)data + 4), *((u32 *)data + 3));
			break;
		case 0x4004:
			ret = SsGetActualProgFromProg(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x4005:
			ret = SsGetChannelMute(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x4006:
			ret = (int)SsGetCurrentPoint(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x4007:
			ret = SsGetVoiceMask();
			break;
		case 0x4008:
			SsInit();
			break;
		case 0x4009:
			ret = SsIsEos(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x400A:
			SsAllocateVoices(*((u8 *)data + 4), *((u8 *)data + 8));
			break;
		case 0x4010:
			SsPitchCorrect(*((u16 *)data + 2));
			break;
		case 0x4011:
			ret = (u16)SsPitchFromNote(*((u16 *)data + 2), *((u16 *)data + 4), *((u8 *)data + 12), *((u8 *)data + 16));
			break;
		case 0x4012:
			SsPlayBack(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6));
			break;
		case 0x4013:
			SsQueueKeyOn(*((u32 *)data + 1));
			break;
		case 0x4014:
			SsQueueReverb(*((u32 *)data + 1), *((u32 *)data + 2));
			break;
		case 0x4015:
			SsQuit();
			break;
		case 0x4017:
			SsSetTableSize(seq_table, *((u16 *)data + 4), *((u16 *)data + 6));
			break;
		case 0x4018:
			SsSetTickMode(*((u32 *)data + 1));
			break;
		case 0x4019:
			SsSepClose(*((u16 *)data + 2));
			break;
		case 0x4020:
			ret = SsSepOpen((unsigned int *)data + 1, *((u16 *)data + 4), *((u16 *)data + 6));
			break;
		case 0x4021:
			SsSepPause(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x4022:
			SsSepPlay(*((u16 *)data + 2), *((u16 *)data + 4), *((u8 *)data + 12), *((u16 *)data + 8));
			break;
		case 0x4023:
			SsSepReplay(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x4024:
			SsSepSetAccelerando(*((u16 *)data + 2), *((u16 *)data + 4), *((u32 *)data + 3), *((u32 *)data + 4));
			break;
		case 0x4025:
			SsSepSetCrescendo(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6), *((u32 *)data + 4));
			break;
		case 0x4026:
			SsSepSetDecrescendo(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6), *((u32 *)data + 4));
			break;
		case 0x4027:
			SsSepSetRitardando(*((u16 *)data + 2), *((u16 *)data + 4), *((u32 *)data + 3), *((u32 *)data + 4));
			break;
		case 0x4028:
			SsSepSetVol(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6), *((u16 *)data + 8));
			break;
		case 0x4029:
			SsSepStop(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x4030:
			SsSeqGetVol(*((u16 *)data + 2), *((u16 *)data + 4), (s16 *)data + 6, (s16 *)data + 8);
			break;
		case 0x4031:
			ret = SsSeqOpen(*((unsigned int **)data + 1), *((u16 *)data + 4));
			break;
		case 0x4032:
			SsSeqPause(*((u16 *)data + 2));
			break;
		case 0x4033:
			SsSeqPlayPtoP(
				*((u16 *)data + 2),
				*((u16 *)data + 4),
				*((u8 **)data + 3),
				*((u8 **)data + 4),
				*((u8 *)data + 20),
				*((u16 *)data + 12));
			break;
		case 0x4034:
			SsSeqReplay(*((u16 *)data + 2));
			break;
		case 0x4035:
			SsSeqSetAccelerando(*((u16 *)data + 2), *((u32 *)data + 2), *((u32 *)data + 3));
			break;
		case 0x4036:
			SsSeqSetCrescendo(*((u16 *)data + 2), *((u16 *)data + 4), *((u32 *)data + 3));
			break;
		case 0x4037:
			SsSeqSetDecrescendo(*((u16 *)data + 2), *((u16 *)data + 4), *((u32 *)data + 3));
			break;
		case 0x4038:
			SsSeqSetRitardando(*((u16 *)data + 2), *((u32 *)data + 2), *((u32 *)data + 3));
			break;
		case 0x4039:
			SsSeqSetNext(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x4040:
			SsSeqCalledTbyT();
			break;
		case 0x4041:
			SsSeqClose(*((u16 *)data + 2));
			break;
		case 0x4042:
			SsSeqPlay(*((u16 *)data + 2), *((u8 *)data + 8), *((u16 *)data + 6));
			break;
		case 0x4043:
			SsSeqSetVol(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6));
			break;
		case 0x4044:
			SsSeqSkip(*((u16 *)data + 2), *((u16 *)data + 4), *((u8 *)data + 12), *((u16 *)data + 8));
			break;
		case 0x4045:
			SsSeqStop(*((u16 *)data + 2));
			break;
		case 0x4046:
			SsSetAutoKeyOffMode(*((u16 *)data + 2));
			break;
		case 0x4047:
			SsSetCurrentPoint(*((u16 *)data + 2), *((u16 *)data + 4), *((u8 **)data + 3));
			break;
		case 0x4048:
			SsSetLoop(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6));
			break;
		case 0x4049:
			SsSetMono();
			break;
		case 0x404A:
			SsSetMVol(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x4050:
			SsSetNext(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6), *((u16 *)data + 8));
			break;
		case 0x4051:
			ret = SsSetReservedVoice(*((u8 *)data + 4));
			break;
		case 0x4052:
			SsSetStereo();
			break;
		case 0x4053:
			SsSetTempo(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6));
			break;
		case 0x4054:
			SsSetVoiceMask(*((u32 *)data + 1));
			break;
		case 0x4055:
			SsStart();
			break;
		case 0x4056:
			SsStart2();
			break;
		case 0x4057:
			ret = SsUnBlockVoiceAllocation();
			break;
		case 0x4058:
			SsUtFlush();
			break;
		case 0x4059:
			ret = SsUtGetVagAddr(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x4060:
			ret = SsUtGetVagAddrFromTone(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6));
			break;
		case 0x4061:
			ret = SsUtGetVBaddrInSB(*((u16 *)data + 2));
			break;
		case 0x4062:
			SsVabClose(*((u16 *)data + 2));
			break;
		case 0x4063:
			ret = SsVabOpenHead(*((u8 **)data + 1), *((u16 *)data + 4));
			break;
		case 0x4064:
			ret = SsVabTransBodyPartly(*((u8 **)data + 1), *((u32 *)data + 2), *((u16 *)data + 6));
			break;
		case 0x4065:
			ret = SsVabTransCompleted(*((u16 *)data + 2));
			break;
		case 0x4066:
			SsVabTransBody(*((u8 **)data + 1), *((u16 *)data + 4));
			break;
		case 0x4067:
			ret = SsVoiceCheck(*((u32 *)data + 1), *((u32 *)data + 2), *((u16 *)data + 6));
			break;
		case 0x4068:
			ret = SsVoKeyOff(*((u32 *)data + 1), *((u32 *)data + 2));
			break;
		case 0x4069:
			ret = SsVoKeyOn(*((u32 *)data + 1), *((u32 *)data + 2), *((u16 *)data + 6), *((u16 *)data + 8));
			break;
		case 0x4070:
			ret = SsVabOpenHeadSticky(*((u8 **)data + 1), *((u16 *)data + 4), *((u32 *)data + 3));
			break;
#if 0
		case 0x5001:
			StInit();
			break;
		case 0x5002:
			StQuit();
			break;
		case 0x5003:
			StCalledVSync();
			break;
		case 0x5005:
			ret = (s16)StVabOpen(*((s16 **)data + 1), *((u32 *)data + 2), *((u32 *)data + 3));
			break;
		case 0x5006:
			ret = (s16)StVabOpenFakeBody(*((u32 *)data + 1), *((u32 *)data + 2));
			break;
		case 0x5007:
			StVabOpenCompleted();
			break;
		case 0x5008:
			ret = (s16)StVabClose(*((u16 *)data + 2));
			break;
		case 0x5009:
			ret = (s16)StBgmOpen(*((u16 *)data + 2), *((u32 *)data + 2));
			break;
		case 0x500A:
			StSetTickMode(*((u16 *)data + 2));
			break;
		case 0x500B:
			ret = (s16)StBgmClose(*((u16 *)data + 2));
			break;
		case 0x500C:
			StSetReverbType(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x500D:
			StSetReverbDepth(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6));
			break;
		case 0x500E:
			StSetReverbDelaytime(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x500F:
			StSetReverbFeedback(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x5010:
			ret = StGetSlotStatus(*((u16 *)data + 2));
			break;
		case 0x5011:
			StSetSbClear(*((u32 *)data + 1));
			break;
		case 0x5012:
			StSetMasterVol(*((u16 *)data + 2), *((u16 *)data + 4), *((u16 *)data + 6));
			break;
		case 0x5013:
			ret = (s16)StSetBgmVol(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x5014:
			StBgmPlay(*((u16 *)data + 2));
			break;
		case 0x5015:
			StBgmStop(*((u16 *)data + 2), *((u16 *)data + 4), *((u32 *)data + 3));
			break;
		case 0x5016:
			StSetBgmTempo(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x5017:
			ret = (s16)StGetBgmTempo(*((u16 *)data + 2));
			break;
		case 0x5018:
			ret = (s16)StGetBgmStatus();
			break;
		case 0x5019:
			ret = (s16)StGetBgmChStatus();
			break;
		case 0x501A:
			ret = (s16)StDmaWrite(*((s16 **)data + 1), *((u32 *)data + 2), *((u32 *)data + 3));
			break;
		case 0x501B:
			ret = (s16)StDmaRead(*((u32 *)data + 1), *((u8 **)data + 2), *((u32 *)data + 3));
			break;
		case 0x5100:
			ret = SetTimer(&common);
			break;
		case 0x5101:
			ret = ReleaseTimer();
			break;
		case 0x5200:
			ret = StSePlay(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
		case 0x5201:
			ret = StSetSeVol(*((u16 *)data + 2), *((u16 *)data + 4));
			break;
#endif
		case 0x6128:
		{
			SpuGetCommonAttr(&c_attr);
			return &c_attr;
		}
		case 0x6240:
		{
			s_attr.voice = *((u32 *)data + 2);
			SpuGetVoiceAttr(&s_attr);
			return &s_attr;
		}
		case 0x6314:
		{
			SpuGetReverbModeParam(&r_attr);
			return &r_attr;
		}
		case 0x6418:
		{
			SpuGetAllKeysStatus(status);
			return status;
		}
		case 0x7128:
			SpuSetCommonAttr((SpuCommonAttr *)data);
			break;
		case 0x7240:
			SpuSetVoiceAttr((SpuVoiceAttr *)data);
			break;
		case 0x7314:
			SpuSetReverbModeParam((SpuReverbAttr *)data);
			break;
		case 0x7440:
			SpuSetKeyOnWithAttr((SpuVoiceAttr *)data);
			break;
		case 0x7508:
			SpuSetEnv((const SpuEnv *)data);
			break;
		case 0x7600:
		{
			int i;

			for ( i = 0; i < gMultiVoiceNum; i += 1 )
				SpuSetVoiceAttr((SpuVoiceAttr *)data + i);
			break;
		}
		case 0x8100:
			SpuSetTransferCallback(DMA1CallBackProc);
			break;
		case 0x8200:
			SpuSetIRQCallback(IRQCallBackProc);
			break;
		case 0x8600:
			SpuAutoDMASetCallback(DMA0CallBackProc);
			break;
		case 0xE621:
		{
			iop_thread_t param;

			param.attr = TH_C;
			param.thread = sce_spust_loop;
			param.priority = 34;
#ifdef LIB_OSD_100
			param.stacksize = 2048;
#else
			param.stacksize = 4096;
#endif
			param.option = 0;
			gStThid = CreateThread(&param);
			StartThread(gStThid, 0);
			break;
		}
	}

	return &ret;
}

// rspu2drv/rsd_cb.o

void sceSifCmdLoop2(void)
{
	while ( 1 )
	{
		if ( eeCBData.mode )
		{
			sceSifCallRpc(&cd, 0, 0, &eeCBData, 16, 0, 0, 0, 0);
			if ( eeCBData.mode < 4 )
				memcpy(gStPtr, &gStBuff, sizeof(SpuStEnv));
			eeCBData.mode = 0;
		}
		SleepThread();
	}
}

void DMA0CallBackProc(void)
{
	eeCBData.mode = 4;
	iWakeupThread(gStThid);
}

void DMA1CallBackProc(void)
{
	eeCBData.mode = 5;
	iWakeupThread(gStThid);
}

void IRQCallBackProc(void)
{
	eeCBData.mode = 6;
	iWakeupThread(gStThid);
}

void spustCB_preparation_finished(unsigned int voice_bit, int p_status)
{
	eeCBData.mode = 1;
	eeCBData.voice_bit = voice_bit;
	eeCBData.status = p_status;
	iWakeupThread(gStThid);
}

void spustCB_transfer_finished(unsigned int voice_bit, int t_status)
{
	eeCBData.mode = 2;
	eeCBData.voice_bit = voice_bit;
	eeCBData.status = t_status;
	iWakeupThread(gStThid);
}

void spustCB_stream_finished(unsigned int voice_bit, int s_status)
{
	eeCBData.mode = 3;
	eeCBData.voice_bit = voice_bit;
	eeCBData.status = s_status;
	iWakeupThread(gStThid);
}

void sce_spust_loop(void *userdata)
{
	int i;

	(void)userdata;

	eeCBData.mode = 0;
	while ( sceSifBindRpc(&cd, sce_SPUST_CB, 0) >= 0 )
	{
		for ( i = 0; i < 10000; i += 1 )
		{
			__asm__ __volatile__("" : "+g"(i) : :);
		}
		if ( cd.server )
			sceSifCmdLoop2();
	}
	while ( 1 )
		;
}

// libspu2/config.o

void _spu2_config_iop(void)
{
	*((vu32 *)0xBF801404) = 0xBF900000;
	*((vu32 *)0xBF80140C) = 0xBF900800;
	*((vu32 *)0xBF8010F0) |= 0x80000u;
	*((vu32 *)0xBF801570) |= 8u;
	*((vu32 *)0xBF801014) = 0x200B31E1;
	*((vu32 *)0xBF801414) = 0x200B31E1;
}

static void _spu2_config_SPDIF(int flag)
{
	*((vu16 *)0xBF9007C6) = 2304;
	*((vu16 *)0xBF9007C8) = 512;
	if ( flag )
		*((vu16 *)0xBF9007C8) = 0;
	*((vu16 *)0xBF9007CA) = 8;
}

void _spu2_config_initialize(void)
{
	_spu2_config_iop();
	_spu2_config_SPDIF(0);
}

void _spu2_config_initialize_typically(void)
{
	*((vu16 *)0xBF9007C0) = 0xC032;
	*((vu16 *)0xBF90019A) = 0xC000;
	*((vu16 *)0xBF90059A) = 0xC001;
	*((vu16 *)0xBF900188) = 0xFFFF;
	*((vu16 *)0xBF90018A) = 0xFF;
	*((vu16 *)0xBF900190) = 0xFFFF;
	*((vu16 *)0xBF900192) = 0xFF;
	*((vu16 *)0xBF90018C) = 0xFFFF;
	*((vu16 *)0xBF90018E) = 0xFF;
	*((vu16 *)0xBF900194) = 0xFFFF;
	*((vu16 *)0xBF900196) = 0xFF;
	*((vu16 *)0xBF900588) = 0xFFFF;
	*((vu16 *)0xBF90058A) = 0xFF;
	*((vu16 *)0xBF900590) = 0xFFFF;
	*((vu16 *)0xBF900592) = 0xFF;
	*((vu16 *)0xBF90058C) = 0xFFFF;
	*((vu16 *)0xBF90058E) = 0xFF;
	*((vu16 *)0xBF900594) = 0xFFFF;
	*((vu16 *)0xBF900596) = 0xFF;
	*((vu16 *)0xBF900198) = 0xFFF;
	*((vu16 *)0xBF900598) = 0xFFF;
	*((vu16 *)0xBF900760) = 0;
	*((vu16 *)0xBF900762) = 0;
	*((vu16 *)0xBF900788) = 0;
	*((vu16 *)0xBF90078A) = 0;
	*((vu16 *)0xBF900764) = 0;
	*((vu16 *)0xBF900766) = 0;
	*((vu16 *)0xBF90078C) = 0;
	*((vu16 *)0xBF90078E) = 0;
	*((vu16 *)0xBF900768) = 0;
	*((vu16 *)0xBF90076A) = 0;
	*((vu16 *)0xBF900790) = 0x7FFF;
	*((vu16 *)0xBF900792) = 0x7FFF;
	*((vu16 *)0xBF90076C) = 0;
	*((vu16 *)0xBF90076E) = 0;
	*((vu16 *)0xBF900794) = 0;
	*((vu16 *)0xBF900796) = 0;
	*((vu16 *)0xBF90033C) = 0xE;
	*((vu16 *)0xBF90073C) = 0xF;
}

void _spu2_config_initialize_hot(void)
{
	*((vu16 *)0xBF9007C0) = 0xC032;
	*((vu16 *)0xBF90019A) = 0xC080;
	*((vu16 *)0xBF90059A) = 0xC081;
	*((vu16 *)0xBF900188) = 0xFFFF;
	*((vu16 *)0xBF90018A) = 0xFF;
	*((vu16 *)0xBF900190) = 0xFFFF;
	*((vu16 *)0xBF900192) = 0xFF;
	*((vu16 *)0xBF90018C) = 0xFFFF;
	*((vu16 *)0xBF90018E) = 0xFF;
	*((vu16 *)0xBF900194) = 0xFFFF;
	*((vu16 *)0xBF900196) = 0xFF;
	*((vu16 *)0xBF900588) = 0xFFFF;
	*((vu16 *)0xBF90058A) = 0xFF;
	*((vu16 *)0xBF900590) = 0xFFFF;
	*((vu16 *)0xBF900592) = 0xFF;
	*((vu16 *)0xBF90058C) = 0xFFFF;
	*((vu16 *)0xBF90058E) = 0xFF;
	*((vu16 *)0xBF900594) = 0xFFFF;
	*((vu16 *)0xBF900596) = 0xFF;
	*((vu16 *)0xBF900198) = 0xFFF;
	*((vu16 *)0xBF900598) = 0xFFF;
	*((vu16 *)0xBF900768) = 0;
	*((vu16 *)0xBF90076A) = 0;
	*((vu16 *)0xBF900790) = 0x7FFF;
	*((vu16 *)0xBF900792) = 0x7FFF;
	*((vu16 *)0xBF90076C) = 0;
	*((vu16 *)0xBF90076E) = 0;
	*((vu16 *)0xBF900794) = 0;
	*((vu16 *)0xBF900796) = 0;
}

void _spu2_config_before_compatible(void)
{
	*((vu16 *)0xBF9007C0) = 0xC032;
	*((vu16 *)0xBF900188) = 0xFFFF;
	*((vu16 *)0xBF90018A) = 0xFF;
	*((vu16 *)0xBF900190) = 0xFFFF;
	*((vu16 *)0xBF900192) = 0xFF;
	*((vu16 *)0xBF90018C) = 0xFFFF;
	*((vu16 *)0xBF90018E) = 0xFF;
	*((vu16 *)0xBF900194) = 0xFFFF;
	*((vu16 *)0xBF900196) = 0xFF;
	*((vu16 *)0xBF900198) = 0xFFF;
	*((vu16 *)0xBF90033C) = 3;
	_spu2_config_SPDIF(1);
}

// libspu2/spu.o

static void _spu_FsetDelayW(int flag);
static void _spu_FsetDelayR(int flag);

int _spu_init(int flag)
{
	if ( !flag )
	{
		vu16 *v2;

		*((vu32 *)0xBF8010F0) |= 0xB0000u;
		v2 = &_spu_RXX[20 * _spu_core];
		v2[944] = 0;
		v2[945] = 0;
		v2[1456] = 0;
		v2[1457] = 0;
#ifndef LIB_1300
		// Added in OSDSND 110U
		*((vu16 *)0xBF9007C0) = 0;
		_spu_Fw1ts();
		_spu_Fw1ts();
		*((vu16 *)0xBF9007C0) = 0x8000;
		_spu_Fw1ts();
#endif
		for ( _spu_core = 0; (unsigned int)_spu_core < 2; _spu_core += 1 )
		{
			vu16 *v7;
			vu16 *v8;
			unsigned int v9;
			vu16 *v11;
			vu16 *v12;
			int v13;

			_spu_transMode = 0;
			_spu_tsa[_spu_core] = 0;
#ifndef LIB_1300
			// Added in OSDSND 110U
			*(u16 *)((_spu_core << 10) + 0xbf9001b0) = 0;
#endif
			_spu_RXX[512 * _spu_core + 205] = 0;
			_spu_Fw1ts();
			_spu_Fw1ts();
			v7 = &_spu_RXX[512 * _spu_core];
			v7[205] = 0x8000;
			v8 = &_spu_RXX[20 * _spu_core];
			v8[944] = 0;
			v8[945] = 0;
			v9 = 1;
			while ( (v7[418] & 0x7FF) != 0 )
			{
				if ( v9 >= 0xF01 )
				{
					printf("SPU:T/O [%s]\n", "wait (reset)");
					break;
				}
				v9 += 1;
			}
			v11 = &_spu_RXX[20 * _spu_core];
			v12 = &_spu_RXX[512 * _spu_core];
			v11[946] = 0;
			v11[947] = 0;
			v12[210] = -1;
			v12[211] = -1;
			_spu_RXX[205] &= ~0x80u;
			for ( v13 = 0; v13 < 10; v13 += 1 )
			{
				_spu_RQ[v13] = 0;
			}
		}
		for ( _spu_core = 0; (unsigned int)_spu_core < 2; _spu_core += 1 )
		{
			vu16 *v17;
			vu16 *v18;

			v17 = &_spu_RXX[512 * _spu_core];
			v17[192] = 0;
			v17[193] = 0;
			v17[194] = 0;
			v17[195] = 0;
			v18 = &_spu_RXX[20 * _spu_core];
			v18[968] = 0;
			v18[969] = 0;
			v18[970] = 0;
			v18[971] = 0;
		}
	}
	_spu_core = 0;
	SpuStopFreeRun();
	_spu_inTransfer = 1;
	_spu_transferCallback = 0;
	_spu_IRQCallback = 0;
	return 0;
}

int spu_do_set_DmaCoreIndex(int dma_core_index)
{
	int (*v1)(void *);

	g_DmaCoreIndex = dma_core_index;
	if ( dma_core_index )
	{
		_SpuDataCallback(_spu_FiAutoDMA);
		v1 = _spu_FiDMA;
	}
	else
	{
		_SpuDataCallback(_spu_FiDMA);
		v1 = _spu_FiAutoDMA;
	}
	_SpuAutoDMACallback(v1);
	return g_DmaCoreIndex;
}

int spu_do_get_DmaCoreIndex(void)
{
	return g_DmaCoreIndex;
}

static void _spu_FwriteByIO(void *addr, u32 size)
{
	_spu_RXX[725] = _spu_tsa[1];
	_spu_RXX[724] = (_spu_tsa[1] >> 16) & 0xFFFF;
	while ( size )
	{
		s32 v6;
		s32 i;
		unsigned int v9;

		v6 = 64;
		if ( size <= 64 )
			v6 = size;
		for ( i = 0; i < v6; i += 2 )
		{
			*((vu16 *)0xBF9001AC) = *(u16 *)((char *)addr + 2 * i);
		}
		*((vu16 *)0xBF90019A) = (*((vu16 *)0xBF90019A) & ~0x30) | 0x10;
		v9 = 1;
		while ( (*((vu16 *)0xBF900344) & 0x400) != 0 )
		{
			if ( v9 >= 0xF01 )
			{
				printf("SPU:T/O [%s]\n", "wait (SPU2_STATX_WRDY_M)");
				break;
			}
			v9 += 1;
		}
		size -= v6;
	}
	*((vu16 *)0xBF90019A) &= ~0x30;
}

int _spu_FiDMA(void *userdata)
{
	int v1;
	unsigned int v3;

	(void)userdata;

	v1 = 1;
	while ( (*((vu16 *)0xBF900744) & 0x80) != 0 )
	{
		if ( v1 > 0x1000000 )
		{
			printf("SPU:T/O [%s]\n", "wait (SPU2_STATX_DREQ)");
			break;
		}
		v1 += 1;
	}
	_spu_RXX[717] &= ~0x30;
	v3 = 1;
	while ( (_spu_RXX[717] & 0x30) != 0 )
	{
		if ( v3 >= 0xF01 )
			break;
		v3 += 1;
	}
	if ( _spu_transferCallback )
		_spu_transferCallback();
	else
		gDMADeliverEvent = 1;
	FlushDcache();
	return 1;
}

int _spu_FiAutoDMA(void *userdata)
{
	(void)userdata;

#ifdef LIB_1600
	if ( gMode != SPU_AUTODMA_ONESHOT )
	{
		gWhichBuff = 1 - gWhichBuff;
		if ( gWhichBuff )
			*((vu32 *)0xBF8010C0) = (u32)&gHostAddr[512 * (gBufferSize48 / 512)];
		else
			*((vu32 *)0xBF8010C0) = (u32)&gHostAddr[0];
		if ( gWhichBuff )
		{
			int v1;
			int v2;

			v1 = (gBufferSize48 / 512) << 9;
			v2 = (2 * gBufferSize48 - v1) >> 6;
			if ( 2 * gBufferSize48 - v1 < 0 )
				v2 = (2 * gBufferSize48 - v1 + 63) >> 6;
			*((vu16 *)0xBF8010C6) = v2 + ((2 * gBufferSize48 - ((gBufferSize48 / 512) << 9)) % 64 > 0);
		}
		else
		{
			*((vu16 *)0xBF8010C6) = 8 * (gBufferSize48 / 512);
		}
		*((vu32 *)0xBF8010C8) = 0x1000201;
	}
#else
	if ( (gMode & SPU_AUTODMA_LOOP) != 0 )
	{
		gWhichBuff = 1 - gWhichBuff;
		if ( gWhichBuff )
			*(u32 *)(1088 * g_DmaCoreIndex + 0xBF8010C0) = (u32)&gHostAddr[512 * (gBufferSize48 / 512)];
		else
			*(u32 *)(1088 * g_DmaCoreIndex + 0xBF8010C0) = (u32)gHostAddr;
		if ( gWhichBuff )
			*(u16 *)(1088 * g_DmaCoreIndex + 0xBF8010C6) = (2 * gBufferSize48 - ((gBufferSize48 / 512) << 9)) / 64
																									 + ((2 * gBufferSize48 - ((gBufferSize48 / 512) << 9)) % 64 > 0);
		else
			*(u16 *)(1088 * g_DmaCoreIndex + 0xBF8010C6) = 8 * (gBufferSize48 / 512);
		*(u32 *)(1088 * g_DmaCoreIndex + 0xBF8010C8) = 0x1000201;
	}
#endif
	else
	{
		*((vu16 *)0xBF90019A) &= ~0x30;
		*((vu16 *)0xBF900198) &= ~0xc0;
		*((vu16 *)0xBF9001B0) = 0;
	}
	if ( _spu_AutoDMACallback )
		_spu_AutoDMACallback();
	FlushDcache();
	return 1;
}

void _spu_Fr_(void *data, int addr, u32 size)
{
	_spu_RXX[725] = addr;
	_spu_RXX[724] = (addr >> 16) & 0xFFFF;
	_spu_RXX[717] |= 0x30u;
	_spu_FsetDelayR(1);
	*((vu32 *)0xBF8010C0) = (vu32)data;
	*((vu32 *)0xBF8010C4) = (size << 16) | 0x10;
	_spu_dma_mode = 1;
	*((vu32 *)0xBF8010C8) = 16777728;
}

int _spu_t(int count, ...)
{
	u32 v6;
	int spu_tmp;
	unsigned int ck;
	va_list va;

	va_start(va, count);
	spu_tmp = va_arg(va, u32);
	ck = va_arg(va, u32);
	va_end(va);
	switch ( count )
	{
		case 0:
			_spu_dma_mode = 1;
			_spu_RXX[717] = _spu_RXX[717] | 0x30;
			break;
		case 1:
			_spu_dma_mode = 0;
			_spu_RXX[717] = (_spu_RXX[717] & ~0x30) | 0x20;
			break;
		case 2:
			_spu_tsa[1] = spu_tmp;
			_spu_RXX[725] = spu_tmp;
			_spu_RXX[724] = (_spu_tsa[1] >> 16) & 0xFFFF;
			break;
		case 3:
			if ( _spu_dma_mode == 1 )
				_spu_FsetDelayR(1);
			else
				_spu_FsetDelayW(1);
			_spu_transfer_startaddr = spu_tmp;
			_spu_transfer_time = (ck >> 6) + ((ck & 0x3F) != 0);
			((vu32 *)0xBF8010C0)[272] = spu_tmp;
			((vu32 *)0xBF8010C4)[272] = (_spu_transfer_time << 16) | 0x10;
			v6 = 0x1000201;
			if ( _spu_dma_mode == 1 )
				v6 = 16777728;
			((vu32 *)0xBF8010C8)[272] = v6;
			break;
		default:
			break;
	}
	return 0;
}

int _spu_Fw(void *addr, u32 size)
{
	if ( _spu_transMode )
	{
		_spu_FwriteByIO(addr, size);
	}
	else
	{
		_spu_t(2, _spu_tsa[1]);
		_spu_t(1);
		_spu_t(3, addr, size);
	}
	return size;
}

int _spu_StopAutoDMA(void)
{
#ifdef LIB_1300
	*((vu16 *)0xBF90019A) &= ~0x30;
#else
	int v0;

	v0 = 0;
#ifdef LIB_1600
	if ( *((vu16 *)0xBF9001B0) )
		v0 = *((vu32 *)0xBF8010C0);
	*((vu32 *)0xBF8010C8) &= ~0x1000000u;
#else
	int do_set_dmacoreindex;
	u16 *v2;

	do_set_dmacoreindex = 0;
	if ( (*((vu16 *)0xBF9007C0) & 4) != 0 )
	{
		do_set_dmacoreindex = 1;
		*((vu16 *)0xBF9007C0) &= ~0xc0;
	}
	v2 = (u16 *)((g_DmaCoreIndex << 10) + 0xBF9001B0);
	if ( *v2 )
		v0 = *(u32 *)(1088 * g_DmaCoreIndex + 0xBF8010C0);
	*(u32 *)(1088 * g_DmaCoreIndex + 0xBF8010C8) &= ~0x1000000u;
#endif
#endif
#ifdef LIB_1600
	*((vu16 *)0xBF900198) &= ~0xf0;
	*((vu16 *)0xBF9001B0) = 0;
	*((vu16 *)0xBF90076E) = 0;
	*((vu16 *)0xBF90076C) = 0;
#else
	*(u16 *)((g_DmaCoreIndex << 10) + 0xBF900198) &= ~0xf0;
	*v2 = 0;
	*(u16 *)((g_DmaCoreIndex << 10) + 0xBF90076E) = 0;
	*(u16 *)((g_DmaCoreIndex << 10) + 0xBF90076C) = *(u16 *)((g_DmaCoreIndex << 10) + 0xBF90076E);
	if ( (*((vu16 *)0xBF9007C0) & 4) != 0 )
		*((vu16 *)0xBF9007C0) &= ~0xc4;
	if ( do_set_dmacoreindex )
		spu_do_set_DmaCoreIndex(0);
#endif
#ifdef LIB_1300
	return 0;
#else
	return (gWhichBuff << 24) | (v0 & 0xFFFFFF);
#endif
}

int _spu_AutoDMAGetStatus(void)
{
	int v0;

	v0 = 0;
#ifdef LIB_1600
	if ( *((vu16 *)0xBF9001B0) )
		v0 = *((vu32 *)0xBF8010C0);
#else
	if ( *(u16 *)((g_DmaCoreIndex << 10) + 0xBF9001B0) )
		v0 = *(u32 *)(1088 * g_DmaCoreIndex + 0xBF8010C0);
#endif
	return (gWhichBuff << 24) | (v0 & 0xFFFFFF);
}

unsigned int _spu_FwAutoDMA(u8 *addr, unsigned int size, int mode)
{
	gHostAddr = addr;
	gWhichBuff = 0;
	gBufferSize48 = size;
	gMode = mode;
#ifdef LIB_1600
	*((vu16 *)0xBF90019A) &= ~0x30;
	*((vu16 *)0xBF9001A8) = 0;
	*((vu16 *)0xBF9001AA) = 0;
	*((vu16 *)0xBF9001B0) = 1;
	*((vu32 *)0xBF8010C0) = (u32)addr;
	*((vu32 *)0xBF8010C4) = 16;
	*((vu16 *)0xBF8010C6) = 8 * ((int)size / 512);
	*((vu32 *)0xBF8010C8) = 0x1000201;
	*((vu16 *)0xBF900198) |= 0xC0u;
	*((vu16 *)0xBF90076E) = 0x7FFF;
	*((vu16 *)0xBF90076C) = 0x7FFF;
#else
	if ( (mode & (SPU_AUTODMA_BIT4 | SPU_AUTODMA_LOOP)) != 0 )
	{
		spu_do_set_DmaCoreIndex(1);
		*((vu16 *)0xBF9007C0) |= 4u;
	}
	*(u16 *)((g_DmaCoreIndex << 10) + 0xBF90019A) &= ~0x30;
	*(u16 *)((g_DmaCoreIndex << 10) + 0xBF9001A8) = 0;
	*(u16 *)((g_DmaCoreIndex << 10) + 0xBF9001AA) = 0;
	if ( g_DmaCoreIndex != 0 )
		*(u16 *)((g_DmaCoreIndex << 10) + 0xBF9001B0) = 2;
	else
		*(u16 *)((g_DmaCoreIndex << 10) + 0xBF9001B0) = 1;
	_spu_FsetDelayW(g_DmaCoreIndex);
	*(u32 *)((1088 * g_DmaCoreIndex) + 0xBF8010C0) = (u32)addr;
	*(u16 *)((1088 * g_DmaCoreIndex) + 0xBF8010C4) = 16;
	*(u16 *)((1088 * g_DmaCoreIndex) + 0xBF8010C6) = 8 * ((int)size / 512);
	if ( (mode & (SPU_AUTODMA_BIT4 | SPU_AUTODMA_LOOP)) != 0 )
	{
		*((vu16 *)0xBF9007C0) |= (mode & SPU_AUTODMA_BIT6) | (mode & SPU_AUTODMA_BIT7);
	}
	*(u32 *)((1088 * g_DmaCoreIndex) + 0xBF8010C8) = 0x1000201;
	if ( (mode & SPU_AUTODMA_BIT4) == 0 )
	{
		*(u16 *)((g_DmaCoreIndex << 10) + 0xBF900198) |= 0xC0u;
		*(u16 *)((g_DmaCoreIndex << 10) + 0xBF90076E) = 0x7FFF;
		*(u16 *)((g_DmaCoreIndex << 10) + 0xBF90076C) = 0x7FFF;
	}
#endif
	return size;
}

unsigned int _spu_FwAutoDMAfrom(u8 *addr, unsigned int size, int mode, u8 *unk_a4)
{
	u8 *v4;
	int v5;
#ifdef LIB_1600
	int v7;
#endif

	v4 = unk_a4;
	if ( !unk_a4 )
		v4 = addr;
	gHostAddr = addr;
	gWhichBuff = 0;
	gBufferSize48 = size;
	gMode = mode;
	v5 = size - (v4 - addr);
	if ( (unsigned int)(v4 - addr) >= size )
	{
#ifdef LIB_1600
		if ( mode != SPU_AUTODMA_LOOP )
#else
		if ( (mode & SPU_AUTODMA_LOOP) == 0 )
#endif
			return 0;
		gWhichBuff += 1;
		v5 = size - (v4 - addr - size);
	}
	if ( v5 % 1024 > 0 )
	{
		v5 = (v5 / 1024 + 1) << 10;
		v4 = &addr[gWhichBuff * size + size - v5];
	}
#ifdef LIB_1600
	*((vu16 *)0xBF90019A) &= ~0x30;
	*((vu16 *)0xBF9001A8) = 0;
	*((vu16 *)0xBF9001AA) = 0;
	*((vu16 *)0xBF9001B0) = 1;
	*((vu32 *)0xBF8010C0) = (u32)v4;
	*((vu32 *)0xBF8010C4) = 16;
	v7 = v5 >> 6;
	if ( v5 < 0 )
		v7 = (v5 + 63) >> 6;
	*((vu16 *)0xBF8010C6) = v7 + (v5 - (v7 << 6) > 0);
	*((vu32 *)0xBF8010C8) = 0x1000201;
	*((vu16 *)0xBF900198) |= 0xC0u;
	*((vu16 *)0xBF90076E) = 0x7FFF;
	*((vu16 *)0xBF90076C) = 0x7FFF;
#else
	if ( (mode & (SPU_AUTODMA_BIT4 | SPU_AUTODMA_LOOP)) != 0 )
	{
		spu_do_set_DmaCoreIndex(1);
		*((vu16 *)0xBF9007C0) |= 4u;
	}
	*(u16 *)((g_DmaCoreIndex << 10) + 0xBF90019A) &= ~0x30;
	*(u16 *)((g_DmaCoreIndex << 10) + 0xBF9001A8) = 0;
	*(u16 *)((g_DmaCoreIndex << 10) + 0xBF9001AA) = 0;
	if ( g_DmaCoreIndex != 0 )
		*(u16 *)((g_DmaCoreIndex << 10) + 0xBF9001B0) = 2;
	else
		*(u16 *)((g_DmaCoreIndex << 10) + 0xBF9001B0) = 1;
	*(u32 *)((1088 * g_DmaCoreIndex) + 0xBF8010C0) = (u32)v4;
	*(u16 *)((1088 * g_DmaCoreIndex) + 0xBF8010C4) = 16;
	*(u16 *)((1088 * g_DmaCoreIndex) + 0xBF8010C6) = v5 / 64 + (v5 % 64 > 0);
	if ( (mode & (SPU_AUTODMA_BIT4 | SPU_AUTODMA_LOOP)) != 0 )
	{
		*((vu16 *)0xBF9007C0) |= (mode & SPU_AUTODMA_BIT6) | (mode & SPU_AUTODMA_BIT7);
	}
	*(u32 *)(1088 * g_DmaCoreIndex + 0xBF8010C8) = 0x1000201;
	if ( (mode & SPU_AUTODMA_BIT4) == 0 )
	{
		*(u16 *)((g_DmaCoreIndex << 10) + 0xBF900198) |= 0xC0u;
		*(u16 *)((g_DmaCoreIndex << 10) + 0xBF90076E) = 0x7FFF;
		*(u16 *)((g_DmaCoreIndex << 10) + 0xBF90076C) = 0x7FFF;
	}
#endif
	return size;
}

void _spu_Fr(void *addr, u32 size)
{
	_spu_t(2, _spu_tsa[1]);
	_spu_t(0);
	_spu_t(3, addr, size);
}

void _spu_MGFsetRXX2(int offset, int value)
{
	int v2;
	vu16 *v3;

	v2 = 4 * value;
	v3 = &_spu_RXX[512 * _spu_core + offset];
	*v3 = (v2 >> 16) & 0xFFFF;
	v3[1] = v2;
}

void _spu_FsetRXX(int l, u32 addr, int flag)
{
	vu16 *v3;

	v3 = &_spu_RXX[512 * _spu_core + l];
	if ( flag )
	{
		*v3 = addr >> 17;
		v3[1] = addr >> 1;
	}
	else
	{
		*v3 = addr >> 14;
		v3[1] = 4 * addr;
	}
}

int _spu_FsetRXXa(int l, u32 flag)
{
	if ( l == -2 )
		return flag;
	if ( l == -1 )
		return flag >> 1;
	_spu_RXX[512 * _spu_core + l] = flag >> 1;
	return flag;
}

int _spu_MGFgetRXX2(int offset)
{
	return 2 * (_spu_RXX[512 * _spu_core + 1 + offset] | (_spu_RXX[512 * _spu_core + offset] << 16));
}

void _spu_FsetPCR(int flag)
{
	(void)flag;
}

static void _spu_FsetDelayW(int flag)
{
	((vu32 *)0xBF801014)[256 * flag] = (((vu32 *)0xBF801014)[256 * flag] & ~0x2f000000) | 0x20000000;
}

static void _spu_FsetDelayR(int flag)
{
	((vu32 *)0xBF801014)[256 * flag] = (((vu32 *)0xBF801014)[256 * flag] & ~0x2f000000) | 0x22000000;
}

void __attribute__((optimize("no-unroll-loops"))) _spu_Fw1ts(void)
{
	int i;
	int v1;

	v1 = 13;
	for ( i = 0; i < 60; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

// libspu2/s_cb.o

void _SpuCallback(SpuIRQCallbackProc cb)
{
	_spu_irq_callback = cb;
}

// libspu2/s_dcb.o

void _SpuDataCallback(int (*callback)(void *userdata))
{
	char dummyarg[8];

	ReleaseIntrHandler(IOP_IRQ_DMA_SPU2);
	RegisterIntrHandler(IOP_IRQ_DMA_SPU2, 1, callback, dummyarg);
}

void _SpuAutoDMACallback(int (*callback)(void *userdata))
{
	char dummyarg[8];

	ReleaseIntrHandler(IOP_IRQ_DMA_SPU);
	RegisterIntrHandler(IOP_IRQ_DMA_SPU, 1, callback, dummyarg);
}

// libspu2/s_do.o

void SpuSetDigitalOut(int mode)
{
	s16 v1;
	s16 v3;

	v1 = *((vu16 *)0xBF9007C0);
	v3 = *((vu16 *)0xBF9007C6);
	switch ( mode & 0xF )
	{
		case SPU_SPDIF_OUT_OFF:
			v1 &= ~0x128;
			break;
		case SPU_SPDIF_OUT_PCM:
			v3 &= ~2;
			v1 &= ~0x128;
			v1 |= 0x20;
			break;
		case SPU_SPDIF_OUT_BITSTREAM:
			v3 |= 2;
			v1 &= ~0x128;
			v1 |= 0x100;
			break;
		case SPU_SPDIF_OUT_BYPASS:
			v1 &= ~0x128;
			v1 |= 8;
			break;
		default:
			break;
	}
	switch ( mode & 0xF0 )
	{
		case SPU_SPDIF_COPY_PROHIBIT:
			v3 |= 0x8000;
			break;
		case SPU_SPDIF_COPY_NORMAL:
		default:
			v3 &= ~0x8000;
			break;
	}
	switch ( mode & 0xF00 )
	{
		case SPU_SPDIF_MEDIA_DVD:
			*((vu16 *)0xBF9007C8) = 512;
			v3 |= 0x1800;
			break;
		case SPU_SPDIF_MEDIA_CD:
			*((vu16 *)0xBF9007C8) = 0;
			v3 &= ~0x1800;
			break;
		default:
			*((vu16 *)0xBF9007C8) = 512;
			v3 &= ~0x1800;
			v3 |= 0x800;
			break;
	}
	*((vu16 *)0xBF9007C0) = v1;
	*((vu16 *)0xBF9007C6) = v3;
}

// libspu2/s_ini.o

void _SpuInit(int mode)
{
	_spu_init(mode);
	if ( !mode )
	{
		int v2;

		for ( v2 = 0; v2 < 2; v2 += 1 )
		{
			int v4;

			for ( v4 = 0; v4 < 24; v4 += 1 )
			{
				_spu_voice_centerNote[v2][v4] = -16384;
			}
		}
	}
	SpuStart();
	if ( !mode )
	{
		_spu_rev_flag = 0;
		_spu_rev_reserve_wa = 0;
		_spu_rev_attr.mode = 0;
		_spu_rev_attr.depth.left = 0;
		_spu_rev_attr.depth.right = 0;
		_spu_rev_attr.delay = 0;
		_spu_rev_attr.feedback = 0;
		_spu_rev_offsetaddr = SpuGetReverbEndAddr() - (8 * _spu_rev_workareasize[0] - 2);
		_spu_FsetRXX(368, _spu_rev_offsetaddr, 1);
	}
	_spu_keystat[0] = 0;
	_spu_keystat[1] = 0;
	_spu_AllocBlockNum = 0;
	_spu_AllocLastNum = 0;
	_spu_memList = 0;
	_spu_trans_mode = SPU_TRANSFER_BY_DMA;
	_spu_transMode = 0;
	_spu_RQmask = 0;
	_spu_RQvoice = 0;
	_spu_env = 0;
}

int _SpuDefaultCallback(void *userdata)
{
	(void)userdata;

	_spu_irq_callback();
	return 0;
}

void SpuStart(void)
{
	int v0;

	v0 = 0;
	_spu_isCalled = 1;
	CpuDisableIntr();
	_SpuDataCallback(_spu_FiDMA);
	_SpuAutoDMACallback(_spu_FiAutoDMA);
	gDMADeliverEvent = 0;
	CpuEnableIntr();
	EnableIntr(IOP_IRQ_DMA_SPU);
	EnableIntr(IOP_IRQ_DMA_SPU2);
	ReleaseIntrHandler(IOP_IRQ_SPU);
	RegisterIntrHandler(IOP_IRQ_SPU, 1, _SpuDefaultCallback, &v0);
}

// libspu2/s_sfr.o

void SpuStopFreeRun(void)
{
	u16 *v1;
	s16 *v2;
	u16 *v3;
	u16 *v4;
	int v15;
	int i;
	int j;
	int k;

	v1 = (u16 *)0xBF900000;
	v2 = (s16 *)0xBF900400;
	v3 = (u16 *)0xBF9001C0;
	v4 = (u16 *)0xBF9005C0;
	*((vu16 *)0xBF9001A8) = 0;
	*((vu16 *)0xBF9001AA) = 10240;
	// Unofficial: Fixed out of bounds dummy array access by replacing with constant setting
	for ( v15 = 0; v15 < 16; v15 += 1 )
	{
		*((vu16 *)0xBF9001AC) = 1799u;
	}
	*((vu16 *)0xBF90019A) = (*((vu16 *)0xBF90019A) & ~0x30) | 0x10;
	while ( (*((vu16 *)0xBF900344) & 0x400) != 0 )
		;
	*((vu16 *)0xBF90019A) &= ~0x30;
	for ( i = 0; i < 24; i += 1 )
	{
		s16 *v6;
		u16 *v7;
		u16 *v13;
		u16 *v14;

		v6 = v2 + (i * 8);
		v7 = v1 + (i * 8);
		v13 = v4 + (i * 6);
		v14 = v3 + (i * 6);
		v6[0] = 0;
		v7[0] = v6[0];
		v6[1] = 0;
		v7[1] = v6[1];
		v6[2] = 0x3FFF;
		v7[2] = v6[2];
		v6[3] = 0;
		v7[3] = v6[3];
		v6[4] = 0;
		v7[4] = v6[4];
		v13[0] = 0;
		v14[0] = v13[0];
		v13[1] = 10240;
		v14[1] = v13[1];
	}
	*((vu16 *)0xBF9005A0) = -1;
	*((vu16 *)0xBF9001A0) = -1;
	*((vu16 *)0xBF9005A2) = 255;
	*((vu16 *)0xBF9001A2) = 255;
	for ( j = 0; j < 3124; j += 1 )
	{
		__asm__ __volatile__("" : "+g"(j) : :);
	}
	*((vu16 *)0xBF9005A4) = -1;
	*((vu16 *)0xBF9001A4) = -1;
	*((vu16 *)0xBF9005A6) = 255;
	*((vu16 *)0xBF9001A6) = 255;
	for ( k = 0; k < 3124; k += 1 )
	{
		__asm__ __volatile__("" : "+g"(k) : :);
	}
	*((vu16 *)0xBF900342) = 0;
	*((vu16 *)0xBF900340) = 0;
}

// libspu2/s_i.o

void SpuInit(void)
{
	_spu_core = 0;
	_spu2_config_initialize();
	_SpuInit(0);
	_spu2_config_initialize_typically();
}

unsigned int SpuSetCore(unsigned int which_core)
{
	unsigned int result;

	result = _spu_core;
	_spu_core = which_core & 1;
	return result;
}

unsigned int SpuGetCore(void)
{
	return _spu_core;
}

void SpuSetReverbEndAddr(unsigned int eea)
{
	_spu_eea[_spu_core] = (eea >> 17) & 0xF;
	_spu_RXX[512 * _spu_core + 207] = _spu_eea[_spu_core];
}

unsigned int SpuGetReverbEndAddr(void)
{
	return (_spu_RXX[512 * _spu_core + 414] << 17) | 0x1FFFF;
}

// libspu2/s_ih.o

void SpuInitHot(void)
{
	_spu2_config_initialize();
	_SpuInit(1);
	_spu2_config_initialize_hot();
}

// libspu2/s_q.o

void SpuQuit(void)
{
	if ( _spu_isCalled == 1 )
	{
#ifndef LIB_1300
		// Added in OSDSND 110U
		int v0[2];
#endif

		_spu_isCalled = 0;
		CpuDisableIntr();
		_spu_transferCallback = 0;
		_spu_IRQCallback = 0;
		_SpuDataCallback(0);
		_SpuAutoDMACallback(0);
#ifndef LIB_1300
		// Added in OSDSND 110U
		ReleaseIntrHandler(IOP_IRQ_DMA_SPU2);
		ReleaseIntrHandler(IOP_IRQ_DMA_SPU);
		ReleaseIntrHandler(IOP_IRQ_SPU);
		DisableIntr(IOP_IRQ_DMA_SPU2, v0);
		DisableIntr(IOP_IRQ_DMA_SPU, v0);
		DisableIntr(IOP_IRQ_SPU, v0);
#endif
		CpuEnableIntr();
	}
}

// libspu2/s_sm.o

int SpuSetMute(int on_off)
{
	vu16 *v2;

	v2 = &_spu_RXX[512 * _spu_core];
	switch ( on_off )
	{
		case SPU_OFF:
			v2[205] |= 0x4000;
			break;
		case SPU_ON:
			v2[205] &= ~0x4000;
			break;
		default:
			break;
	}
	return on_off;
}

// libspu2/s_gm.o

int SpuGetMute(void)
{
	return ((_spu_RXX[512 * _spu_core + 205] & 0x4000) == 0) ? SPU_ON : SPU_OFF;
}

// libspu2/s_m_int.o

void _spu_gcSPU(void)
{
	int counter_1;
	libspu2_malloc_t *p_cur_block_2;
	int counter_3;
	libspu2_malloc_t *p_next_block;
	u32 addr_area;
	u32 size_area_1;
	int idx;
	const libspu2_malloc_t *p_cur_block_3;
	u32 size_area_2;
	int alloc_last_num_1;
	u32 size_area_3;

	for ( counter_1 = 0; counter_1 <= _spu_AllocLastNum; counter_1 += 1 )
	{
		while ( (_spu_memList[counter_1].addr_area & 0x80000000) != 0 )
		{
			int list_idx;

			for ( list_idx = counter_1 + 1; _spu_memList[list_idx].addr_area == 0x2fffffff; list_idx += 1 )
			{
			}
			p_cur_block_2 = &_spu_memList[list_idx];
			if (
				(p_cur_block_2->addr_area & 0x80000000) != 0
				&& (p_cur_block_2->addr_area & 0xFFFFFFF)
						 == (_spu_memList[counter_1].addr_area & 0xFFFFFFF) + _spu_memList[counter_1].size_area )
			{
				p_cur_block_2->addr_area = 0x2fffffff;
				_spu_memList[counter_1].size_area += p_cur_block_2->size_area;
				continue;
			}
			break;
		}
	}
	if ( _spu_AllocLastNum >= 0 )
	{
		if ( !_spu_memList[0].size_area )
			_spu_memList[0].addr_area = 0x2fffffff;
	}
	for ( counter_3 = 0; counter_3 <= _spu_AllocLastNum; counter_3 += 1 )
	{
		int counter_next;

		if ( (_spu_memList[counter_3].addr_area & 0x40000000) != 0 )
			break;
		for ( counter_next = counter_3 + 1; _spu_AllocLastNum >= counter_next; counter_next += 1 )
		{
			p_next_block = &_spu_memList[counter_next];
			if ( (p_next_block->addr_area & 0x40000000) != 0 )
				break;
			addr_area = _spu_memList[counter_3].addr_area;
			if ( (p_next_block->addr_area & 0xFFFFFFF) < (_spu_memList[counter_3].addr_area & 0xFFFFFFF) )
			{
				_spu_memList[counter_3].addr_area = p_next_block->addr_area;
				size_area_1 = _spu_memList[counter_3].size_area;
				_spu_memList[counter_3].size_area = p_next_block->size_area;
				p_next_block->addr_area = addr_area;
				p_next_block->size_area = size_area_1;
			}
		}
	}
	for ( idx = 0; idx <= _spu_AllocLastNum; idx += 1 )
	{
		if ( (_spu_memList[idx].addr_area & 0x40000000) != 0 )
		{
			break;
		}
		if ( _spu_memList[idx].addr_area == 0x2fffffff )
		{
			p_cur_block_3 = &_spu_memList[_spu_AllocLastNum];
			_spu_memList[idx].addr_area = p_cur_block_3->addr_area;
			size_area_2 = p_cur_block_3->size_area;
			_spu_AllocLastNum = idx;
			_spu_memList[idx].size_area = size_area_2;
			break;
		}
	}
	for ( alloc_last_num_1 = _spu_AllocLastNum - 1; alloc_last_num_1 >= 0; alloc_last_num_1 -= 1 )
	{
		int alloc_last_num_2;
		libspu2_malloc_t *p_prev_block;

		p_prev_block = &_spu_memList[alloc_last_num_1];
		if ( (p_prev_block->addr_area & 0x80000000) == 0 )
			break;
		alloc_last_num_2 = _spu_AllocLastNum;
		p_prev_block->addr_area = (p_prev_block->addr_area & 0xFFFFFFF) | 0x40000000;
		size_area_3 = p_prev_block->size_area;
		_spu_AllocLastNum = alloc_last_num_1;
		p_prev_block->size_area = size_area_3 + _spu_memList[alloc_last_num_2].size_area;
	}
}

// libspu2/s_m_init.o

int SpuInitMalloc(int num, char *top)
{
	libspu2_malloc_t *top_tmp;

	if ( num <= 0 )
		return 0;
	top_tmp = (libspu2_malloc_t *)top;
	_spu_memList = top_tmp;
	_spu_AllocLastNum = 0;
	top_tmp->addr_area = 0x40005010;
	_spu_AllocBlockNum = num;
	top_tmp->size_area = 0x1FAFF0;
	return num;
}

// libspu2/s_m_util.o

int _SpuIsInAllocateArea(u32 addr)
{
	libspu2_malloc_t *p_a;
	unsigned int ptr;

	if ( !_spu_memList )
		return 0;
	for ( p_a = _spu_memList;; p_a += 1 )
	{
		if ( (p_a->addr_area & 0x80000000) != 0 )
			continue;
		ptr = p_a->addr_area & 0xFFFFFFF;
		if ( (p_a->addr_area & 0x40000000) != 0 )
			break;
		if ( ptr >= addr || addr < ptr + p_a->size_area )
			return 1;
	}
	return 0;
}

int _SpuIsInAllocateArea_(u32 addr)
{
	return _SpuIsInAllocateArea(addr);
}

// libspu2/s_m_m.o

int SpuMalloc(int size)
{
	int found_block_idx;
	u32 rev_size_zero;
	unsigned int size_adjusted;
	int p_allocated;
	libspu2_malloc_t *p_cur_block;
	u32 addr_area;
	u32 addr_area_1;
	u32 p_alloc_last_addr;
	libspu2_malloc_t *p_last_block_2;
	u32 addr_area_2;
	u32 size_area_1;
	libspu2_malloc_t *p_last_block_3;

	found_block_idx = -1;
	if ( _spu_rev_reserve_wa )
		rev_size_zero = 0x200000 - _spu_rev_offsetaddr;
	else
		rev_size_zero = 0;
	size_adjusted = 2 * (size >> 1);
	if ( (_spu_memList->addr_area & 0x40000000) != 0 )
	{
		found_block_idx = 0;
	}
	else
	{
		int cur_idx;

		_spu_gcSPU();
		for ( cur_idx = 0; cur_idx < _spu_AllocBlockNum; cur_idx += 1 )
		{
			if (
				!((_spu_memList[cur_idx].addr_area & 0x40000000) == 0
					&& ((_spu_memList[cur_idx].addr_area & 0x80000000) == 0 || _spu_memList[cur_idx].size_area < size_adjusted)) )
			{
				found_block_idx = cur_idx;
				break;
			}
		}
	}
	p_allocated = found_block_idx;
	if ( found_block_idx == -1 )
	{
		return -1;
	}
	p_cur_block = &_spu_memList[p_allocated];
	addr_area = _spu_memList[p_allocated].addr_area;
	if ( (addr_area & 0x40000000) != 0 )
	{
		libspu2_malloc_t *p_last_block_1;

		if ( found_block_idx >= _spu_AllocBlockNum )
		{
			return -1;
		}
		if ( p_cur_block->size_area - rev_size_zero < size_adjusted )
		{
			return -1;
		}
		p_last_block_1 = &_spu_memList[found_block_idx + 1];
		p_last_block_1->addr_area = ((p_cur_block->addr_area & 0xFFFFFFF) + size_adjusted) | 0x40000000;
		p_last_block_1->size_area = p_cur_block->size_area - size_adjusted;
		addr_area_1 = p_cur_block->addr_area;
		_spu_AllocLastNum = found_block_idx + 1;
		p_cur_block->size_area = size_adjusted;
		p_cur_block->addr_area = addr_area_1 & 0xFFFFFFF;
		_spu_gcSPU();
		return _spu_memList[p_allocated].addr_area;
	}
	else
	{
		unsigned int size_area;

		size_area = p_cur_block->size_area;
		if ( size_adjusted < size_area )
		{
			p_alloc_last_addr = addr_area + size_adjusted;
			if ( _spu_AllocLastNum < _spu_AllocBlockNum )
			{
				p_last_block_2 = &_spu_memList[_spu_AllocLastNum];
				addr_area_2 = p_last_block_2->addr_area;
				size_area_1 = p_last_block_2->size_area;
				p_last_block_2->addr_area = p_alloc_last_addr | 0x80000000;
				p_last_block_2->size_area = size_area - size_adjusted;
				_spu_AllocLastNum += 1;
				p_last_block_2[1].addr_area = addr_area_2;
				p_last_block_2[1].size_area = size_area_1;
			}
		}
		p_last_block_3 = &_spu_memList[found_block_idx];
		p_last_block_3->size_area = size_adjusted;
		p_last_block_3->addr_area = p_last_block_3->addr_area & 0xFFFFFFF;
		_spu_gcSPU();
		return _spu_memList[found_block_idx].addr_area;
	}
}

// libspu2/s_m_wsa.o

static int getNeedBlock(int unk_a1, int unk_a2, int addr_area, int unk_a4);

int SpuMallocWithStartAddr(unsigned int addr, int size)
{
	int v2;
	int NeedBlock;
	int size_area;
	unsigned int v5;
	u32 v7;
	int v8;
	int v9;
	int v11;
	int v12;
	int v13;
	int v15;
	const libspu2_malloc_t *v17;
	int v20;
	libspu2_malloc_t *v22;
	int v29;

	if ( _spu_rev_reserve_wa )
		v7 = 0x200000 - _spu_rev_offsetaddr;
	else
		v7 = 0;
	v8 = 2 * ((int)addr >> 1);
	v9 = 2 * (size >> 1);
	if ( v8 < 0x5010 || (int)(0x200000 - v7) < v8 + v9 )
		return -1;
	_spu_gcSPU();
	v11 = _spu_AllocBlockNum;
	v12 = -1;
	for ( v13 = 0; v13 < _spu_AllocBlockNum; v13 += 1 )
	{
		if ( (_spu_memList[v13].addr_area & 0x40000000) != 0 )
		{
			v11 = v13;
			break;
		}
	}
	v29 = _spu_AllocBlockNum - v11;
	for ( v15 = 0; v15 < _spu_AllocBlockNum; v15 += 1 )
	{
		int addr_area;
		int v19;

		v17 = &_spu_memList[v15];
		size_area = v17->size_area;
		addr_area = v17->addr_area;
		v2 = v17->addr_area & 0xFFFFFFF;
		v19 = size_area;
		if ( v2 < v8 )
			v19 = size_area - (v8 - v2);
		if ( v19 >= v9 )
		{
			v5 = addr_area & 0xF0000000;
			if ( (addr_area & 0xF0000000) != 0 )
			{
				NeedBlock = getNeedBlock(v8, v9, addr_area, v19);
				if ( v29 >= NeedBlock )
				{
					v12 = v15;
					break;
				}
			}
		}
	}
	if ( v12 < 0 )
	{
		return -1;
	}
	v20 = -1;
	if ( NeedBlock )
	{
		int v21;

		for ( v21 = v11; v21 > v12; v21 -= 1 )
		{
			const libspu2_malloc_t *v25;

			v25 = &_spu_memList[v11];
			if ( _spu_AllocBlockNum >= v21 + NeedBlock )
			{
				libspu2_malloc_t *v26;

				v26 = &_spu_memList[v21 + NeedBlock];
				v26->addr_area = v25->addr_area;
				v26->size_area = v25->size_area;
			}
		}
		if ( v2 >= v8 )
		{
			libspu2_malloc_t *v28;

			v20 = v2;
			v28 = &_spu_memList[v12];
			v28[1].addr_area = (v2 + v9) | v5;
			v28->addr_area = v2;
			v28->size_area = v9;
			v28[1].size_area = size_area - v9;
		}
		else
		{
			libspu2_malloc_t *v27;

			v27 = &_spu_memList[v12];
			v27->addr_area = v2 | 0x80000000;
			v27->size_area = v8 - v2;
			v27[1].addr_area = v8;
			v27[1].size_area = v9;
			if ( NeedBlock == 2 )
			{
				v27[2].addr_area = (v8 + v9) | v5;
				v27[2].size_area = size_area - (v8 - v2) - v9;
			}
			return v8;
		}
	}
	else
	{
		v22 = &_spu_memList[v12];
		v20 = v22->addr_area & 0xFFFFFFF;
		v22->addr_area = v20;
	}
	return v20;
}

static int getNeedBlock(int unk_a1, int unk_a2, int addr_area, int unk_a4)
{
	if ( (addr_area & 0xFFFFFFF) >= unk_a1 )
	{
		if ( unk_a2 != unk_a4 )
			return 1;
		return (addr_area & 0x40000000) != 0;
	}
	else
	{
		if ( unk_a2 == unk_a4 )
		{
			if ( (addr_area & 0x40000000) != 0 )
				return 2;
			return 1;
		}
	}
	return 2;
}

// libspu2/s_m_f.o

void SpuFree(unsigned int addr)
{
	int block_counter;

	for ( block_counter = 0; block_counter < _spu_AllocBlockNum; block_counter += 1 )
	{
		if ( (_spu_memList[block_counter].addr_area & 0x40000000) != 0 )
		{
			break;
		}
		if ( _spu_memList[block_counter].addr_area == addr )
		{
			_spu_memList[block_counter].addr_area = addr | 0x80000000;
			break;
		}
	}
	_spu_gcSPU();
}

// libspu2/s_m_x.o

void _spu_print(void)
{
	int v0;

	for ( v0 = 0; v0 <= _spu_AllocBlockNum; v0 += 1 )
	{
		printf(
			"[%d] %08lx / %08lx (%08ld)\n",
			v0,
			_spu_memList[v0].addr_area,
			_spu_memList[v0].size_area,
			_spu_memList[v0].size_area);
		if ( (_spu_memList[v0].addr_area & 0x40000000) != 0 )
		{
			break;
		}
	}
}

// libspu2/s_se.o

void SpuSetEnv(const SpuEnv *env)
{
	int mask;

	mask = env->mask;
	if ( mask == 0 )
	{
		mask = 0xFFFFFFFF;
	}
	if ( (mask & SPU_ENV_EVENT_QUEUEING) != 0 )
	{
		switch ( env->queueing )
		{
			case SPU_ON:
				_spu_env |= 1u;
				break;
			case SPU_OFF:
			default:
				_spu_env &= ~1u;
				break;
		}
	}
}

// libspu2/s_f.o

unsigned int SpuFlush(unsigned int ev)
{
	// Unofficial: Fixed _spu_RQ and _spu_RQmask access offsets
	unsigned int retval;
	unsigned int ev_tmp;

	retval = 0;
	ev_tmp = ev;
	if ( ev_tmp == 0 )
	{
		ev_tmp = 0xFFFFFFFF;
	}
	if ( ((ev_tmp & SPU_EVENT_PITCHLFO) != 0) && (_spu_RQmask & 2) != 0 )
	{
		vu16 *regstmp1;

		_spu_RQmask &= ~2u;
		regstmp1 = &_spu_RXX[512 * _spu_core];
		regstmp1[192] = _spu_RQ[4];
		retval |= SPU_EVENT_PITCHLFO;
		regstmp1[193] = _spu_RQ[5];
	}
	if ( ((ev_tmp & SPU_EVENT_NOISE) != 0) && (_spu_RQmask & 4) != 0 )
	{
		vu16 *regstmp2;

		_spu_RQmask &= ~4u;
		regstmp2 = &_spu_RXX[512 * _spu_core];
		regstmp2[194] = _spu_RQ[6];
		retval |= SPU_EVENT_NOISE;
		regstmp2[195] = _spu_RQ[7];
	}
	if ( ((ev_tmp & SPU_EVENT_REVERB) != 0) && (_spu_RQmask & 8) != 0 )
	{
		vu16 *regstmp3;
		_spu_RQmask &= ~8u;
		regstmp3 = &_spu_RXX[512 * _spu_core];
		regstmp3[198] = _spu_RQ[10];
		regstmp3[202] = _spu_RQ[14];
		regstmp3[199] = _spu_RQ[11];
		retval |= SPU_EVENT_REVERB;
		regstmp3[203] = _spu_RQ[15];
	}
	if ( ((ev_tmp & SPU_EVENT_KEY) != 0) && (_spu_RQmask & 1) != 0 )
	{
		vu16 *regstmp4;
		int i1;

		_spu_RQmask &= ~1u;
		regstmp4 = &_spu_RXX[512 * _spu_core];
		regstmp4[208] = _spu_RQ[0];
		regstmp4[209] = _spu_RQ[1];
		regstmp4[210] = _spu_RQ[2];
		regstmp4[211] = _spu_RQ[3];
		for ( i1 = 0; i1 < 4; i1 += 1 )
		{
			_spu_RQ[i1] = 0;
		}
		retval |= SPU_EVENT_KEY;
		if ( (_spu_env & 1) != 0 )
			_spu_keystat[_spu_core] = _spu_RQvoice;
	}
	return retval;
}

// libspu2/s_sav.o

unsigned int _SpuSetAnyVoice(int on_off_flags, unsigned int voice_bits, int word_idx1, int word_idx2)
{
	// Unofficial: Fixed _spu_RQ and _spu_RQmask access offsets
	int p_register_1;
	int p_register_2;
	unsigned int ret_bits;

	if ( (_spu_env & 1) != 0 )
	{
		p_register_1 = _spu_RQ[word_idx1 - 188];
		p_register_2 = (u8)_spu_RQ[word_idx2 - 188];
	}
	else
	{
		p_register_1 = _spu_RXX[512 * _spu_core + word_idx1];
		p_register_2 = (u8)_spu_RXX[512 * _spu_core + word_idx2];
	}
	ret_bits = p_register_1 | (p_register_2 << 16);
	switch ( on_off_flags )
	{
		case SPU_OFF:
			if ( (_spu_env & 1) != 0 )
			{
				_spu_RQ[word_idx1 - 188] &= ~(u16)voice_bits;
				_spu_RQ[word_idx2 - 188] &= ~((voice_bits >> 16) & 0xFF);
				_spu_RQmask |= 1 << ((word_idx1 - 190) >> 1);
				if ( (1 << ((word_idx1 - 190) >> 1)) == 16 )
				{
					_spu_RQmask |= 8;
				}
			}
			else
			{
				_spu_RXX[512 * _spu_core + word_idx1] &= ~(u16)voice_bits;
				_spu_RXX[512 * _spu_core + word_idx2] &= ~((voice_bits >> 16 & 0xFF));
			}
			ret_bits &= ~(voice_bits & 0xFFFFFF);
			break;
		case SPU_ON:
			if ( (_spu_env & 1) != 0 )
			{
				_spu_RQ[word_idx1 - 188] |= voice_bits;
				_spu_RQ[word_idx2 - 188] |= (voice_bits >> 16) & 0xFF;
				_spu_RQmask |= 1 << ((word_idx1 - 190) >> 1);
				if ( (1 << ((word_idx1 - 190) >> 1)) == 16 )
				{
					_spu_RQmask |= 8;
				}
			}
			else
			{
				_spu_RXX[512 * _spu_core + word_idx1] |= voice_bits;
				_spu_RXX[512 * _spu_core + word_idx2] |= (voice_bits >> 16) & 0xFF;
			}
			ret_bits |= voice_bits & 0xFFFFFF;
			break;
		case SPU_BIT:
			if ( (_spu_env & 1) != 0 )
			{
				_spu_RQ[word_idx1 - 188] = voice_bits;
				_spu_RQ[word_idx2 - 188] = (voice_bits >> 16) & 0xFF;
				_spu_RQmask |= 1 << ((word_idx1 - 190) >> 1);
				if ( (1 << ((word_idx1 - 190) >> 1)) == 16 )
				{
					_spu_RQmask |= 8;
				}
			}
			else
			{
				_spu_RXX[512 * _spu_core + word_idx1] = voice_bits;
				_spu_RXX[512 * _spu_core + word_idx2] = (voice_bits >> 16) & 0xFF;
			}
			ret_bits = voice_bits & 0xFFFFFF;
			break;
		default:
			break;
	}
	return ret_bits & 0xFFFFFF;
}

// libspu2/s_gav.o

unsigned int _SpuGetAnyVoice(int word_idx1, int word_idx2)
{
	return _spu_RXX[512 * _spu_core + word_idx1] | ((u8)_spu_RXX[512 * _spu_core + word_idx2] << 16);
}

// libspu2/s_snv.o

unsigned int SpuSetNoiseVoice(int on_off, unsigned int voice_bit)
{
	return _SpuSetAnyVoice(on_off, voice_bit, 194, 195);
}

// libspu2/s_gnv.o

unsigned int SpuGetNoiseVoice(void)
{
	return _SpuGetAnyVoice(194, 195);
}

// libspu2/s_snc.o

int SpuSetNoiseClock(int n_clock)
{
	int n_clock_fixed;

	n_clock_fixed = 0;
	if ( n_clock >= 0 )
	{
		n_clock_fixed = n_clock;
		if ( n_clock >= 64 )
			n_clock_fixed = 63;
	}
	_spu_RXX[512 * _spu_core + 205] = (_spu_RXX[512 * _spu_core + 205] & ~0x3F00) | ((n_clock_fixed & 0x3F) << 8);
	return n_clock_fixed;
}

// libspu2/s_gnc.o

int SpuGetNoiseClock(void)
{
	return (u16)(_spu_RXX[512 * _spu_core + 205] & 0x3F00) >> 8;
}

// libspu2/s_sr.o

int SpuSetReverb(int on_off)
{
	vu16 *v1;

	switch ( on_off )
	{
		case SPU_OFF:
			v1 = &_spu_RXX[512 * _spu_core];
			_spu_rev_flag = SPU_OFF;
			v1[205] = v1[205] & ~0x80;
			break;
		case SPU_ON:
			v1 = &_spu_RXX[512 * _spu_core];
			_spu_rev_flag = SPU_ON;
			v1[205] = v1[205] | 0x80;
			break;
		default:
			break;
	}
	return _spu_rev_flag;
}

// libspu2/s_gr.o

int SpuGetReverb(void)
{
	return ((_spu_RXX[512 * _spu_core + 205] & 0x80) != 0) ? SPU_ON : SPU_OFF;
}

// libspu2/s_srmp.o

int SpuSetReverbModeParam(SpuReverbAttr *attr)
{
	int b_set_spucnt;
	int b_r_mode_in_bounds;
	int b_mode_is_7_to_9_bit0x8;
	unsigned int mask;
	int b_mode_is_7_to_9_bit0x10;
	u32 flagstmp;
	libspu2_reverb_param_entry_t entry;
	int b_clear_reverb_work_area;

	b_set_spucnt = 0;
	b_r_mode_in_bounds = 0;
	b_mode_is_7_to_9_bit0x8 = 0;
	b_clear_reverb_work_area = 0;
	mask = attr->mask;
	b_mode_is_7_to_9_bit0x10 = 0;
	entry.flags = 0;
	if ( mask == 0 )
		mask = 0xFFFFFFFF;
	if ( (mask & SPU_REV_MODE) != 0 )
	{
		unsigned int mode;

		mode = attr->mode;
		if ( (mode & SPU_REV_MODE_CLEAR_WA) != 0 )
		{
			mode &= ~SPU_REV_MODE_CLEAR_WA;
			b_clear_reverb_work_area = 1;
		}
		b_r_mode_in_bounds = 1;
		if ( mode >= SPU_REV_MODE_MAX )
			return SPU_ERROR;
		_spu_rev_attr.mode = mode;
		_spu_rev_offsetaddr = SpuGetReverbEndAddr() - (8 * _spu_rev_workareasize[mode] - 2);
		printf("_spu_rev_offsetaddr %x\n", _spu_rev_offsetaddr);
		memcpy(&entry, &_spu_rev_param[_spu_rev_attr.mode], sizeof(entry));
		switch ( _spu_rev_attr.mode )
		{
			case SPU_REV_MODE_ECHO:
				_spu_rev_attr.feedback = 127;
				_spu_rev_attr.delay = 127;
				break;
			case SPU_REV_MODE_DELAY:
				_spu_rev_attr.feedback = 0;
				_spu_rev_attr.delay = 127;
				break;
			default:
				_spu_rev_attr.feedback = 0;
				_spu_rev_attr.delay = 0;
				break;
		}
	}
	if (
		((mask & SPU_REV_DELAYTIME) != 0) && _spu_rev_attr.mode <= SPU_REV_MODE_DELAY
		&& _spu_rev_attr.mode >= SPU_REV_MODE_ECHO )
	{
		int delay_converted;

		b_mode_is_7_to_9_bit0x8 = 1;
		if ( !b_r_mode_in_bounds )
		{
			memcpy(&entry, &_spu_rev_param[_spu_rev_attr.mode], sizeof(entry));
			entry.flags = 0xc011c00;
		}
		_spu_rev_attr.delay = attr->delay;
		entry.mLSAME = (s16)((_spu_rev_attr.delay & 0xFFFF) << 13) / 127 - entry.dAPF1;
		delay_converted = (_spu_rev_attr.delay << 12) / 127;
		entry.mRSAME = delay_converted - entry.dAPF2;
		entry.dLSAME = entry.dRSAME + delay_converted;
		entry.mLCOMB1 = entry.mRCOMB1 + delay_converted;
		entry.mRAPF1 = entry.mRAPF2 + delay_converted;
		entry.mLAPF1 = entry.mLAPF2 + delay_converted;
	}
	if (
		((mask & SPU_REV_FEEDBACK) != 0) && _spu_rev_attr.mode <= SPU_REV_MODE_DELAY
		&& _spu_rev_attr.mode >= SPU_REV_MODE_ECHO )
	{
		b_mode_is_7_to_9_bit0x10 = 1;
		if ( !b_r_mode_in_bounds )
		{
			if ( b_mode_is_7_to_9_bit0x8 )
			{
				flagstmp = entry.flags | 0x80;
			}
			else
			{
				memcpy(&entry, &_spu_rev_param[_spu_rev_attr.mode], sizeof(entry));
				flagstmp = 128;
			}
			entry.flags = flagstmp;
		}
		_spu_rev_attr.feedback = attr->feedback;
		entry.vWALL = 33024 * _spu_rev_attr.feedback / 127;
	}
	if ( b_r_mode_in_bounds )
	{
		vu16 *regsptr;
		vu16 *regstmp1;

		regsptr = &_spu_RXX[512 * _spu_core];
		b_set_spucnt = (regsptr[205] >> 7) & 1;
		if ( b_set_spucnt )
			regsptr[205] &= ~0x80u;
		regstmp1 = &_spu_RXX[20 * _spu_core];
		regstmp1[946] = 0;
		regstmp1[947] = 0;
		_spu_rev_attr.depth.left = 0;
		_spu_rev_attr.depth.right = 0;
	}
	else
	{
		if ( (mask & SPU_REV_DEPTHL) != 0 )
		{
			_spu_RXX[20 * _spu_core + 946] = attr->depth.left;
			_spu_rev_attr.depth.left = attr->depth.left;
		}
		if ( (mask & SPU_REV_DEPTHR) != 0 )
		{
			_spu_RXX[20 * _spu_core + 947] = attr->depth.right;
			_spu_rev_attr.depth.right = attr->depth.right;
		}
	}
	if ( b_r_mode_in_bounds || b_mode_is_7_to_9_bit0x8 || b_mode_is_7_to_9_bit0x10 )
		_spu_setReverbAttr(&entry);
	if ( b_clear_reverb_work_area )
		SpuClearReverbWorkArea(_spu_rev_attr.mode);
	if ( b_r_mode_in_bounds )
	{
		_spu_FsetRXX(368, _spu_rev_offsetaddr, 1);
		if ( b_set_spucnt )
			_spu_RXX[512 * _spu_core + 205] |= 0x80u;
	}
	return 0;
}

// libspu2/s_grmp.o

void SpuGetReverbModeParam(SpuReverbAttr *attr)
{
	attr->mode = _spu_rev_attr.mode;
	attr->delay = _spu_rev_attr.delay;
	attr->feedback = _spu_rev_attr.feedback;
	attr->depth = _spu_rev_attr.depth;
}

// libspu2/s_sra.o

void _spu_setReverbAttr(const libspu2_reverb_param_entry_t *p_rev_param_entry)
{
	u32 flags;

	flags = p_rev_param_entry->flags;
	if ( flags == 0 )
		flags = 0xFFFFFFFF;
	if ( (flags & 1) != 0 )
		_spu_MGFsetRXX2(370, p_rev_param_entry->dAPF1);
	if ( (flags & 2) != 0 )
		_spu_MGFsetRXX2(372, p_rev_param_entry->dAPF2);
	if ( (flags & 4) != 0 )
		_spu_RXX[20 * _spu_core + 954] = p_rev_param_entry->vIIR;
	if ( (flags & 8) != 0 )
		_spu_RXX[20 * _spu_core + 955] = p_rev_param_entry->vCOMB1;
	if ( (flags & 0x10) != 0 )
		_spu_RXX[20 * _spu_core + 956] = p_rev_param_entry->vCOMB2;
	if ( (flags & 0x20) != 0 )
		_spu_RXX[20 * _spu_core + 957] = p_rev_param_entry->vCOMB3;
	if ( (flags & 0x40) != 0 )
		_spu_RXX[20 * _spu_core + 958] = p_rev_param_entry->vCOMB4;
	if ( (flags & 0x80) != 0 )
		_spu_RXX[20 * _spu_core + 959] = p_rev_param_entry->vWALL;
	if ( (flags & 0x100) != 0 )
		_spu_RXX[20 * _spu_core + 960] = p_rev_param_entry->vAPF1;
	if ( (flags & 0x200) != 0 )
		_spu_RXX[20 * _spu_core + 961] = p_rev_param_entry->vAPF2;
	if ( (flags & 0x400) != 0 )
		_spu_MGFsetRXX2(374, p_rev_param_entry->mLSAME);
	if ( (flags & 0x800) != 0 )
		_spu_MGFsetRXX2(376, p_rev_param_entry->mRSAME);
	if ( (flags & 0x1000) != 0 )
		_spu_MGFsetRXX2(378, p_rev_param_entry->mLCOMB1);
	if ( (flags & 0x2000) != 0 )
		_spu_MGFsetRXX2(380, p_rev_param_entry->mRCOMB1);
	if ( (flags & 0x4000) != 0 )
		_spu_MGFsetRXX2(382, p_rev_param_entry->mLCOMB2);
	if ( (flags & 0x8000) != 0 )
		_spu_MGFsetRXX2(384, p_rev_param_entry->mRCOMB2);
	if ( (flags & 0x10000) != 0 )
		_spu_MGFsetRXX2(386, p_rev_param_entry->dLSAME);
	if ( (flags & 0x20000) != 0 )
		_spu_MGFsetRXX2(388, p_rev_param_entry->dRSAME);
	if ( (flags & 0x40000) != 0 )
		_spu_MGFsetRXX2(390, p_rev_param_entry->mLDIFF);
	if ( (flags & 0x80000) != 0 )
		_spu_MGFsetRXX2(392, p_rev_param_entry->mRDIFF);
	if ( (flags & 0x100000) != 0 )
		_spu_MGFsetRXX2(394, p_rev_param_entry->mLCOMB3);
	if ( (flags & 0x200000) != 0 )
		_spu_MGFsetRXX2(396, p_rev_param_entry->mRCOMB3);
	if ( (flags & 0x400000) != 0 )
		_spu_MGFsetRXX2(398, p_rev_param_entry->mLCOMB4);
	if ( (flags & 0x800000) != 0 )
		_spu_MGFsetRXX2(400, p_rev_param_entry->mRCOMB4);
	if ( (flags & 0x1000000) != 0 )
		_spu_MGFsetRXX2(402, p_rev_param_entry->dLDIFF);
	if ( (flags & 0x2000000) != 0 )
		_spu_MGFsetRXX2(404, p_rev_param_entry->dRDIFF);
	if ( (flags & 0x4000000) != 0 )
		_spu_MGFsetRXX2(406, p_rev_param_entry->mLAPF1);
	if ( (flags & 0x8000000) != 0 )
		_spu_MGFsetRXX2(408, p_rev_param_entry->mRAPF1);
	if ( (flags & 0x10000000) != 0 )
		_spu_MGFsetRXX2(410, p_rev_param_entry->mLAPF2);
	if ( (flags & 0x20000000) != 0 )
		_spu_MGFsetRXX2(412, p_rev_param_entry->mRAPF2);
	if ( (flags & 0x40000000) != 0 )
		_spu_RXX[20 * _spu_core + 962] = p_rev_param_entry->vLIN;
	if ( (flags & 0x80000000) != 0 )
		_spu_RXX[20 * _spu_core + 963] = p_rev_param_entry->vRIN;
}

// libspu2/s_rrwa.o

int SpuReserveReverbWorkArea(int on_off)
{
	switch ( on_off )
	{
		case SPU_ON:
			_spu_rev_reserve_wa = SPU_ON;
			break;
		case SPU_OFF:
		default:
			_spu_rev_reserve_wa = SPU_OFF;
			break;
	}
	return _spu_rev_reserve_wa;
}

// libspu2/s_irwar.o

int SpuIsReverbWorkAreaReserved(int on_off)
{
	switch ( on_off )
	{
		case SPU_CHECK:
			return _spu_rev_reserve_wa;
		case SPU_DIAG:
		default:
			return (_SpuIsInAllocateArea_(_spu_rev_offsetaddr) == 0) ? SPU_ON : SPU_OFF;
	}
}

// libspu2/s_srd.o

int SpuSetReverbDepth(SpuReverbAttr *attr)
{
	unsigned int mask;

	mask = attr->mask;
	if ( mask == 0 )
		mask = 0xFFFFFFFF;
	if ( (mask & SPU_REV_DEPTHL) != 0 )
	{
		_spu_RXX[20 * _spu_core + 946] = attr->depth.left;
		_spu_rev_attr.depth.left = attr->depth.left;
	}
	if ( (mask & SPU_REV_DEPTHR) != 0 )
	{
		_spu_RXX[20 * _spu_core + 947] = attr->depth.right;
		_spu_rev_attr.depth.right = attr->depth.right;
	}
	return 0;
}

// libspu2/s_srv.o

unsigned int SpuSetReverbVoice(int on_off, unsigned int voice_bit)
{
	_SpuSetAnyVoice(on_off, voice_bit, 198, 199);
	return _SpuSetAnyVoice(on_off, voice_bit, 202, 203);
}

// libspu2/s_grv.o

unsigned int SpuGetReverbVoice(void)
{
	return 0;
}

// libspu2/s_crwa.o

int SpuClearReverbWorkArea(int mode)
{
	int ck_1;
	unsigned int m;
	unsigned int n;
	u32 t;
	int ck_2;
	void (*bk)(void);

	bk = 0;
	ck_1 = 0;
	if ( (unsigned int)mode >= SPU_REV_MODE_MAX )
		return -1;
	if ( mode )
	{
		m = 8 * _spu_rev_workareasize[mode];
		n = (SpuGetReverbEndAddr() - m) >> 1;
	}
	else
	{
		m = 32;
		n = 2097120;
	}
	printf("### addr = %u  size = %u\n", n, m);
	t = _spu_transMode;
	if ( _spu_transMode == 1 )
	{
		_spu_transMode = 0;
		ck_1 = 1;
	}
	ck_2 = 1;
	if ( _spu_transferCallback )
	{
		bk = _spu_transferCallback;
		_spu_transferCallback = 0;
	}
	while ( ck_2 )
	{
		int m_tmp;

		m_tmp = 1024;
		if ( m < 0x401 )
		{
			m_tmp = m;
			ck_2 = 0;
		}
		gDMADeliverEvent = 0;
		_spu_t(2, n);
		_spu_t(1);
		_spu_t(3, _spu_zerobuf, m_tmp);
		while ( !gDMADeliverEvent )
			;
		gDMADeliverEvent = 0;
		m -= 1024;
		n += 512;
	}
	if ( ck_1 )
		_spu_transMode = t;
	if ( bk )
	{
		_spu_transferCallback = bk;
	}
	return 0;
}

// libspu2/s_rdd.o

int SpuReadDecodedData(SpuDecodedData *d_data, int flag)
{
	int v3;
	u32 v4;

	v3 = 0;
	v4 = 32;
	switch ( flag )
	{
		case SPU_CDONLY:
			break;
		case SPU_VOICEONLY:
			d_data = (SpuDecodedData *)((char *)d_data + 2048);
			v3 = 256;
			break;
		case SPU_ALL:
		default:
			v4 = 64;
			break;
	}
	_spu_Fr_(d_data, v3, v4);
	return ((_spu_RXX[512 * _spu_core + 418] & 0x800) != 0) ? SPU_DECODED_SECONDHALF : SPU_DECODED_FIRSTHALF;
}

// libspu2/s_si.o

int SpuSetIRQ(int on_off)
{
	int v7;

	switch ( on_off )
	{
		case SPU_OFF:
		case SPU_RESET:
		{
			vu16 *v2;
			unsigned int v3;

			v2 = &_spu_RXX[512 * _spu_core];
			v2[205] &= ~0x40u;
			v3 = 1;
			while ( (v2[205] & 0x40) != 0 )
			{
				if ( v3 >= 0xF01 )
				{
					printf("SPU:T/O [%s]\n", "wait (IRQ/ON)");
					return -1;
				}
				v3 += 1;
			}
			DisableIntr(IOP_IRQ_SPU, &v7);
			break;
		}
		default:
			break;
	}
	switch ( on_off )
	{
		case SPU_ON:
		case SPU_RESET:
		{
			vu16 *v5;
			unsigned int v6;

			v5 = &_spu_RXX[512 * _spu_core];
			v5[205] |= 0x40u;
			v6 = 1;
			while ( (v5[205] & 0x40) == 0 )
			{
				if ( v6 >= 0xF01 )
				{
					printf("SPU:T/O [%s]\n", "wait (IRQ/OFF)");
					return -1;
				}
				v6 += 1;
			}
			EnableIntr(IOP_IRQ_SPU);
			break;
		}
		default:
			break;
	}
	return on_off;
}

// libspu2/s_gi.o

int SpuGetIRQ(void)
{
	return ((_spu_RXX[512 * _spu_core + 205] & 0x40) != 0) ? SPU_ON : SPU_OFF;
}

// libspu2/s_sia.o

unsigned int SpuSetIRQAddr(unsigned int addr)
{
	if ( addr > 0x1FFFF8 )
		return 0;
	_spu_FsetRXX(206, addr, 1);
#ifdef LIB_OSD_100
	return 2 * addr;
#else
	// Added in OSDSND 110U (but not in libspu2 1600)
	return 2 * (addr >> 1);
#endif
}

// libspu2/s_gia.o

unsigned int SpuGetIRQAddr(void)
{
	return _spu_MGFgetRXX2(206);
}

unsigned int SpuGetNextAddr(int v_num)
{
	return _spu_MGFgetRXX2(6 * v_num + 228);
}

// libspu2/s_sic.o

SpuIRQCallbackProc SpuSetIRQCallback(SpuIRQCallbackProc func)
{
	void (*v1)(void);

	v1 = _spu_IRQCallback;
	if ( func != _spu_IRQCallback )
	{
		_spu_IRQCallback = func;
		_SpuCallback(func);
	}
	return v1;
}

// libspu2/s_sk.o

void SpuSetKey(int on_off, unsigned int voice_bit)
{
	unsigned int voice_bit_tmp;

	voice_bit_tmp = voice_bit & 0xFFFFFF;
	switch ( on_off )
	{
		case SPU_OFF:
			if ( (_spu_env & 1) != 0 )
			{
				_spu_RQ[2] = voice_bit_tmp & 0xFFFF;
				_spu_RQ[3] = (voice_bit_tmp >> 16) & 0xFFFF;
				_spu_RQmask |= 1u;
				_spu_RQvoice &= ~voice_bit_tmp;
				if ( (_spu_RQ[0] & (u16)voice_bit_tmp) != 0 )
					_spu_RQ[0] &= ~(u16)voice_bit_tmp;
				if ( (_spu_RQ[1] & ((voice_bit_tmp >> 16) & 0xFFFF)) != 0 )
					_spu_RQ[1] &= ~((voice_bit_tmp >> 16) & 0xFFFF);
			}
			else
			{
				_spu_RXX[512 * _spu_core + 210] = voice_bit_tmp & 0xFFFF;
				_spu_RXX[512 * _spu_core + 211] = (voice_bit_tmp >> 16) & 0xFFFF;
				_spu_keystat[_spu_core] &= ~voice_bit_tmp;
			}
			break;
		case SPU_ON:
			if ( (_spu_env & 1) != 0 )
			{
				_spu_RQ[0] = voice_bit_tmp & 0xFFFF;
				_spu_RQ[1] = (voice_bit_tmp >> 16) & 0xFFFF;
				_spu_RQmask |= 1u;
				_spu_RQvoice |= voice_bit_tmp;
				if ( (_spu_RQ[2] & (u16)voice_bit_tmp) != 0 )
					_spu_RQ[2] &= ~(u16)voice_bit_tmp;
				if ( (_spu_RQ[3] & ((voice_bit_tmp >> 16) & 0xFFFF)) != 0 )
					_spu_RQ[3] &= ~((voice_bit_tmp >> 16) & 0xFFFF);
			}
			else
			{
				_spu_RXX[512 * _spu_core + 208] = voice_bit_tmp & 0xFFFF;
				_spu_RXX[512 * _spu_core + 209] = (voice_bit_tmp >> 16) & 0xFFFF;
				_spu_keystat[_spu_core] |= voice_bit_tmp;
			}
			break;
		default:
			break;
	}
}

// libspu2/s_gks.o

int SpuGetKeyStatus(unsigned int voice_bit)
{
	int v1;
	int v2;

	v1 = -1;
	for ( v2 = 0; v2 < 24; v2 += 1 )
	{
		if ( (voice_bit & (1 << v2)) != 0 )
		{
			v1 = v2;
			break;
		}
	}
	if ( v1 == -1 )
	{
		return -1;
	}
	if ( (_spu_keystat[_spu_core] & (1 << v1)) != 0 )
	{
		if ( _spu_RXX[512 * _spu_core + 5 + 8 * v1] != 0 )
		{
			return SPU_ON;
		}
		else
		{
			return SPU_ON_ENV_OFF;
		}
	}
	else
	{
		if ( _spu_RXX[512 * _spu_core + 5 + 8 * v1] != 0 )
		{
			return SPU_OFF_ENV_ON;
		}
		else
		{
			return SPU_OFF;
		}
	}
}

// libspu2/s_skowa.o

void SpuSetKeyOnWithAttr(SpuVoiceAttr *attr)
{
	SpuSetVoiceAttr(attr);
	SpuSetKey(SPU_ON, attr->voice);
}

// libspu2/s_gvea.o

void SpuGetVoiceEnvelopeAttr(int v_num, int *key_stat, s16 *envx)
{
	int v3;

	v3 = _spu_RXX[512 * _spu_core + 5 + 8 * v_num];
	*envx = v3;
	if ( (_spu_keystat[_spu_core] & (1 << v_num)) != 0 )
	{
		if ( v3 )
		{
			*key_stat = SPU_ON;
		}
		else
		{
			*key_stat = SPU_ON_ENV_OFF;
		}
	}
	else
	{
		if ( v3 )
		{
			*key_stat = SPU_OFF_ENV_ON;
		}
		else
		{
			*key_stat = SPU_OFF;
		}
	}
}

// libspu2/s_r.o

unsigned int SpuRead(u8 *addr, unsigned int size)
{
	unsigned int size_tmp;

	size_tmp = size;
	if ( size > 0x1FAFF0 )
		size_tmp = 0x1FAFF0;
	_spu_Fr(addr, size_tmp);
	if ( !_spu_transferCallback )
		_spu_inTransfer = 0;
	return size_tmp;
}

// libspu2/s_w.o

unsigned int SpuWrite(u8 *addr, unsigned int size)
{
	unsigned int size_tmp;

	size_tmp = size;
	if ( size > 0x1FAFF0 )
		size_tmp = 0x1FAFF0;
	_spu_Fw(addr, size_tmp);
	if ( !_spu_transferCallback )
		_spu_inTransfer = 0;
	return size_tmp;
}

unsigned int SpuAutoDMAWrite(u8 *addr, unsigned int size, unsigned int mode, ...)
{
#ifdef LIB_1300
	if ( mode == SPU_AUTODMA_LOOP )
		size >>= 1;
	_spu_FwAutoDMA(addr, size, mode);
	return size;
#else
	u8 *v6;
	va_list va;
	unsigned int mode_masked_1;

	va_start(va, mode);
	v6 = va_arg(va, u8 *);
	va_end(va);
#ifdef LIB_1600
	mode_masked_1 = mode & 1;
#else
	mode_masked_1 = mode;
#endif
	if ( (mode & SPU_AUTODMA_LOOP) != 0 )
		size >>= 1;
	if ( (mode & SPU_AUTODMA_START_ADDR) != 0 )
		return _spu_FwAutoDMAfrom(addr, size, mode_masked_1, v6);
	return _spu_FwAutoDMA(addr, size, mode_masked_1);
#endif
}

int SpuAutoDMAStop(void)
{
	return _spu_StopAutoDMA();
}

int SpuAutoDMAGetStatus(void)
{
	return _spu_AutoDMAGetStatus();
}

// libspu2/s_w0.o

unsigned int SpuWrite0(unsigned int size)
{
	u32 old_tmode;
	int ck_1;
	int ck_2;
	u32 tsa;
	unsigned int written;
	void (*bk)(void);

	old_tmode = _spu_transMode;
	bk = 0;
	ck_1 = 0;
	if ( _spu_transMode == 1 )
	{
		_spu_transMode = 0;
		ck_1 = 1;
	}
	ck_2 = 1;
	tsa = _spu_tsa[1];
	written = 0;
	if ( _spu_transferCallback )
	{
		bk = _spu_transferCallback;
		_spu_transferCallback = 0;
		written = 0;
	}
	while ( ck_2 )
	{
		unsigned int bsize_1;
		int bsize_2;

		bsize_1 = size >> 6;
		if ( size < 0x401 )
		{
			bsize_2 = bsize_1 << 6;
			ck_2 = 0;
			if ( (unsigned int)bsize_2 < size )
				bsize_2 += 64;
		}
		else
		{
			bsize_2 = 1024;
		}
		_spu_t(2, tsa);
		_spu_t(1);
		FlushDcache();
		_spu_t(3, _spu_zerobuf, bsize_2);
		while ( !gDMADeliverEvent )
			;
		gDMADeliverEvent = 0;
		size -= 1024;
		tsa += 512;
		written += bsize_2;
	}
	if ( ck_1 )
		_spu_transMode = old_tmode;
	if ( bk )
	{
		_spu_transferCallback = bk;
	}
	return written;
}

// libspu2/s_stsa.o

unsigned int SpuSetTransferStartAddr(unsigned int addr)
{
	if ( addr - 0x5010 > 0x1FAFE8 )
		return 0;
	_spu_tsa[1] = addr >> 1;
	return 2 * (addr >> 1);
}

// libspu2/s_gtsa.o

unsigned int SpuGetTransferStartAddr(void)
{
	return 2 * _spu_tsa[1];
}

// libspu2/s_stm.o

int SpuSetTransferMode(int mode)
{
	int result;

	if ( mode == SPU_TRANSFER_BY_DMA )
		result = SPU_TRANSFER_BY_DMA;
	else
		result = (mode == SPU_TRANSFER_BY_IO) ? SPU_TRANSFER_BY_IO : SPU_TRANSFER_BY_DMA;
	_spu_trans_mode = mode;
	_spu_transMode = result;
	return result;
}

// libspu2/s_gtm.o

int SpuGetTransferMode(void)
{
	if ( _spu_transMode == SPU_TRANSFER_BY_IO )
		_spu_trans_mode = SPU_TRANSFER_BY_IO;
	else
		_spu_trans_mode = SPU_TRANSFER_BY_DMA;
	return _spu_trans_mode;
}

// libspu2/s_wp.o

unsigned int SpuWritePartly(u8 *addr, unsigned int size)
{
	unsigned int size_tmp;

	size_tmp = size;
	if ( size > 0x1FAFF0 )
		size_tmp = 0x1FAFF0;
	_spu_Fw(addr, size_tmp);
	_spu_tsa[1] = ((2 * _spu_tsa[1]) + size_tmp) >> 1;
	if ( !_spu_transferCallback )
		_spu_inTransfer = 0;
	return size_tmp;
}

// libspu2/s_itc.o

int SpuIsTransferCompleted(int flag)
{
	int result;

	if ( _spu_trans_mode == SPU_TRANSFER_BY_IO || _spu_inTransfer == 1 )
		return 1;
	result = (s16)gDMADeliverEvent;
	if ( flag == SPU_TRANSFER_WAIT )
	{
		while ( !gDMADeliverEvent )
			;
		gDMADeliverEvent = 0;
		_spu_inTransfer = 1;
		return 1;
	}
	else if ( gDMADeliverEvent == 1 )
	{
		_spu_inTransfer = (s16)gDMADeliverEvent;
#ifndef LIB_1300
		// Added in OSDSND 110U
		gDMADeliverEvent = 0;
#endif
	}
	return result;
}

// libspu2/s_stc.o

SpuTransferCallbackProc SpuSetTransferCallback(SpuTransferCallbackProc func)
{
	SpuTransferCallbackProc result;

	result = _spu_transferCallback;
	if ( func != _spu_transferCallback )
		_spu_transferCallback = func;
	return result;
}

SpuTransferCallbackProc SpuAutoDMASetCallback(SpuTransferCallbackProc func)
{
	SpuTransferCallbackProc result;

	result = _spu_AutoDMACallback;
	if ( func != _spu_AutoDMACallback )
		_spu_AutoDMACallback = func;
	return result;
}

// libspu2/s_it.o

void _spu_setInTransfer(int mode)
{
	_spu_inTransfer = mode != 1;
}

int _spu_getInTransfer(void)
{
	return _spu_inTransfer != 1;
}

// libspu2/s_splv.o

unsigned int SpuSetPitchLFOVoice(int on_off, unsigned int voice_bit)
{
	return _SpuSetAnyVoice(on_off, voice_bit, 192, 193);
}

// libspu2/s_gplv.o

unsigned int SpuGetPitchLFOVoice(void)
{
	return _SpuGetAnyVoice(192, 193);
}

// libspu2/s_sca.o

void SpuSetCommonAttr(SpuCommonAttr *attr)
{
	s16 left_1;
	unsigned int mask;
	s16 right_1;
	int mov_left_part1;
	int mov_right_part1;
	vu16 *regstmp1;
	u16 attrtmp1;
	vu16 *regstmp2;
	u16 attrtmp2;
	vu16 *regstmp3;
	u16 attrtmp3;

	left_1 = 0;
	mask = attr->mask;
	right_1 = 0;
	mov_left_part1 = 0;
	mov_right_part1 = 0;
	if ( mask == 0 )
	{
		mask = 0xFFFFFFFF;
	}
	if ( (mask & SPU_COMMON_MVOLL) != 0 )
	{
		if ( (mask & SPU_COMMON_MVOLMODEL) != 0 )
		{
			switch ( attr->mvolmode.left )
			{
				case SPU_VOICE_LINEARIncN:
					mov_left_part1 = 0x8000;
					break;
				case SPU_VOICE_LINEARIncR:
					mov_left_part1 = 0x9000;
					break;
				case SPU_VOICE_LINEARDecN:
					mov_left_part1 = 0xA000;
					break;
				case SPU_VOICE_LINEARDecR:
					mov_left_part1 = 0xB000;
					break;
				case SPU_VOICE_EXPIncN:
					mov_left_part1 = 0xC000;
					break;
				case SPU_VOICE_EXPIncR:
					mov_left_part1 = 0xD000;
					break;
				case SPU_VOICE_EXPDec:
					mov_left_part1 = 0xE000;
					break;
				default:
					left_1 = attr->mvol.left;
					break;
			}
		}
		if ( mov_left_part1 )
		{
			int left_2;

			left_2 = attr->mvol.left;
			left_1 = 127;
			if ( left_2 < 128 )
			{
				left_1 = 0;
				if ( left_2 >= 0 )
					left_1 = attr->mvol.left;
			}
		}
		_spu_RXX[20 * _spu_core + 944] = (left_1 & ~0x8000) | mov_left_part1;
	}
	if ( (mask & SPU_COMMON_MVOLR) != 0 )
	{
		s16 right_masked;

		if ( (mask & SPU_COMMON_MVOLMODER) != 0 )
		{
			switch ( attr->mvolmode.right )
			{
				case SPU_VOICE_LINEARIncN:
					mov_right_part1 = 0x8000;
					break;
				case SPU_VOICE_LINEARIncR:
					mov_right_part1 = 0x9000;
					break;
				case SPU_VOICE_LINEARDecN:
					mov_right_part1 = 0xa000;
					break;
				case SPU_VOICE_LINEARDecR:
					mov_right_part1 = 0xb000;
					break;
				case SPU_VOICE_EXPIncN:
					mov_right_part1 = 0xc000;
					break;
				case SPU_VOICE_EXPIncR:
					mov_right_part1 = 0xd000;
					break;
				case SPU_VOICE_EXPDec:
					mov_right_part1 = 0xe000;
					break;
				default:
					right_1 = attr->mvol.right;
					break;
			}
		}
		right_masked = right_1 & ~0x8000;
		if ( mov_right_part1 )
		{
			int right_2;
			s16 right_3;

			right_2 = attr->mvol.right;
			right_3 = 127;
			if ( right_2 < 128 )
			{
				right_3 = 0;
				if ( right_2 >= 0 )
					right_3 = attr->mvol.right;
			}
			right_masked = right_3 & ~0x8000;
		}
		_spu_RXX[20 * _spu_core + 945] = right_masked | mov_right_part1;
	}
	if ( (mask & SPU_COMMON_CDVOLL) != 0 )
		_spu_RXX[20 * _spu_core + 968] = attr->cd.volume.left;
	if ( (mask & SPU_COMMON_CDVOLR) != 0 )
		_spu_RXX[20 * _spu_core + 969] = attr->cd.volume.right;
	if ( (mask & SPU_COMMON_EXTVOLL) != 0 )
		_spu_RXX[20 * _spu_core + 970] = attr->ext.volume.left;
	if ( (mask & SPU_COMMON_EXTVOLR) != 0 )
		_spu_RXX[20 * _spu_core + 971] = attr->ext.volume.right;
	if ( (mask & SPU_COMMON_CDREV) != 0 )
	{
		regstmp1 = &_spu_RXX[512 * _spu_core];
		if ( attr->cd.reverb == SPU_ON )
			attrtmp1 = regstmp1[205] | 4;
		else
			attrtmp1 = regstmp1[205] & ~4;
		regstmp1[205] = attrtmp1;
	}
	if ( (mask & SPU_COMMON_CDMIX) != 0 )
	{
		regstmp2 = &_spu_RXX[512 * _spu_core];
		if ( attr->cd.mix == SPU_ON )
			attrtmp2 = regstmp2[205] | 1;
		else
			attrtmp2 = regstmp2[205] & ~1;
		regstmp2[205] = attrtmp2;
	}
	if ( (mask & SPU_COMMON_EXTREV) != 0 )
	{
		regstmp3 = &_spu_RXX[512 * _spu_core];
		if ( attr->ext.reverb == SPU_ON )
			attrtmp3 = regstmp3[205] | 8;
		else
			attrtmp3 = regstmp3[205] & ~8;
		regstmp3[205] = attrtmp3;
	}
	if ( (mask & SPU_COMMON_EXTMIX) != 0 )
	{
		if ( attr->ext.mix == SPU_ON )
			_spu_RXX[512 * _spu_core + 205] |= 2u;
		else
			_spu_RXX[512 * _spu_core + 205] &= ~2u;
	}
}

// libspu2/s_gca.o

void SpuGetCommonAttr(SpuCommonAttr *attr)
{
	s16 v2;
	const vu16 *v3;
	u16 v4;
	u16 v5;
	s16 v6;
	const vu16 *v11;
	const vu16 *v13;

	v2 = 0;
	v3 = &_spu_RXX[20 * _spu_core];
	v4 = v3[944];
	v5 = v3[945];
	v6 = 0;
	if ( (v4 & 0x8000) != 0 )
	{
		switch ( v4 & 0xF000 )
		{
			case 0x8000:
				v2 = SPU_VOICE_LINEARIncN;
				break;
			case 0x9000:
				v2 = SPU_VOICE_LINEARIncR;
				break;
			case 0xa000:
				v2 = SPU_VOICE_LINEARDecN;
				break;
			case 0xb000:
				v2 = SPU_VOICE_LINEARDecR;
				break;
			case 0xc000:
				v2 = SPU_VOICE_EXPIncN;
				break;
			case 0xd000:
				v2 = SPU_VOICE_EXPIncR;
				break;
			case 0xe000:
			case 0xf000:
				v2 = SPU_VOICE_EXPDec;
				break;
			default:
				break;
		}
		v4 &= ~0xF000;
	}
	if ( (v5 & 0x8000) != 0 )
	{
		switch ( v5 & 0xF000 )
		{
			case 0x8000:
				v6 = SPU_VOICE_LINEARIncN;
				break;
			case 0x9000:
				v6 = SPU_VOICE_LINEARIncR;
				break;
			case 0xa000:
				v6 = SPU_VOICE_LINEARDecN;
				break;
			case 0xb000:
				v6 = SPU_VOICE_LINEARDecR;
				break;
			case 0xc000:
				v6 = SPU_VOICE_EXPIncN;
				break;
			case 0xd000:
				v6 = SPU_VOICE_EXPIncR;
				break;
			case 0xe000:
			case 0xf000:
				v6 = SPU_VOICE_EXPDec;
				break;
			default:
				break;
		}
		v5 &= ~0xF000;
	}
	if ( v4 < 0x4000u )
		attr->mvol.left = v4;
	else
		attr->mvol.left = v4 + 0x8000;
	if ( v5 < 0x4000u )
		attr->mvol.right = v5;
	else
		attr->mvol.right = v5 + 0x8000;
	attr->mvolmode.right = v6;
	attr->mvolmode.left = v2;
	v11 = &_spu_RXX[20 * _spu_core];
	attr->mvolx.left = v11[972];
	attr->mvolx.right = v11[973];
	attr->cd.volume.left = v11[968];
	attr->cd.volume.right = v11[969];
	attr->cd.reverb = (_spu_RXX[512 * _spu_core + 205] & 4) != 0;
	attr->cd.mix = (_spu_RXX[512 * _spu_core + 205] & 1) != 0;
	v13 = &_spu_RXX[20 * _spu_core];
	attr->ext.volume.left = v13[970];
	attr->ext.volume.right = v13[971];
	attr->ext.reverb = (_spu_RXX[512 * _spu_core + 205] & 8) != 0;
	attr->ext.mix = (_spu_RXX[512 * _spu_core + 205] & 2) != 0;
}

// libspu2/s_n2p.o

u16 _spu_note2pitch(u16 cen_note_high, u16 cen_note_low, u16 note_high, u16 note_low)
{
	u16 max_lo;
	int calc_note;
	u16 max_lo_idx;
	int calc_note_div12;
	int calc_note_div12_min12;
	int calc_note_mod12;
	int calc_note_mod12_idx;

	max_lo = note_low + cen_note_low;
	calc_note = (s16)(note_high + (max_lo >> 7) - cen_note_high);
	max_lo_idx = max_lo & 0x7F;
	calc_note_div12 = calc_note / 12;
	calc_note_div12_min12 = calc_note / 12 - 2;
	calc_note_mod12 = calc_note % 12;
	calc_note_mod12_idx = calc_note_mod12;
	if ( (calc_note_mod12 & 0x8000) != 0 )
	{
		calc_note_mod12_idx = calc_note_mod12 + 12;
		calc_note_div12_min12 = calc_note_div12 - 3;
	}
	if ( (calc_note_div12_min12 & 0x8000u) == 0 )
		return 0x3FFF;
	return (unsigned int)(((_spu_NTable[calc_note_mod12_idx] * (u16)_spu_FTable[max_lo_idx]) >> 16)
												+ (1 << (-(s16)calc_note_div12_min12 - 1)))
			>> -(s16)calc_note_div12_min12;
}

int _spu_pitch2note(s16 note_high, s16 note_low, u16 pitch)
{
	s16 v3;
	u16 v4;
	s16 v5;
	int v6;
	int v8;
	int v9;
	int v11;

	v3 = 0;
	v4 = 0;
	v5 = 0;
	if ( pitch >= 0x4000u )
		pitch = 0x3FFF;
	for ( v6 = 0; v6 < 14; v6 += 1 )
	{
		if ( (((int)pitch >> v6) & 1) != 0 )
			v5 = v6;
	}
	v8 = pitch << (15 - v5);
	for ( v9 = 11; v9 >= 0; v9 -= 1 )
	{
		if ( (u16)v8 >= (unsigned int)(u16)_spu_NTable[v9] )
		{
			v4 = v9;
			break;
		}
	}
	if ( !_spu_NTable[v4] )
		__builtin_trap();
	for ( v11 = 127; v11 >= 0; v11 -= 1 )
	{
		if ( (u16)(((u16)v8 << 15) / (unsigned int)(u16)_spu_NTable[v4]) >= (unsigned int)(u16)_spu_FTable[v11] )
		{
			v3 = v11;
			break;
		}
	}
	return ((u16)(v4 + note_high + 12 * (v5 - 12) + ((u16)(note_low + v3 + 1) >> 7)) << 8) | ((note_low + v3 + 1) & 0x7E);
}

// libspu2/sr_gaks.o

int SpuRGetAllKeysStatus(int min_, int max_, char *status)
{
	int voice;

	if ( min_ < 0 )
	{
		min_ = 0;
	}
	if ( min_ < 0 || min_ >= 24 )
		return SPU_INVALID_ARGS;
	if ( max_ >= 24 )
		max_ = 23;
	if ( max_ < 0 )
		return SPU_INVALID_ARGS;
	if ( max_ < min_ )
		return SPU_INVALID_ARGS;
	for ( voice = min_; voice < (max_ + 1); voice += 1 )
	{
		const vu16 *v9;

		v9 = &_spu_RXX[512 * _spu_core + 8 * voice];
		if ( (_spu_keystat[_spu_core] & (1 << voice)) != 0 )
		{
			if ( v9[5] )
			{
				status[voice] = SPU_ON;
			}
			else
			{
				status[voice] = SPU_ON_ENV_OFF;
			}
		}
		else
		{
			if ( v9[5] )
			{
				status[voice] = SPU_OFF_ENV_ON;
			}
			else
			{
				status[voice] = SPU_OFF;
			}
		}
	}
	return SPU_SUCCESS;
}

void SpuGetAllKeysStatus(char *status)
{
	SpuRGetAllKeysStatus(0, 23, status);
}

// libspu2/st.o

static void _SpuStSetMarkSTART(int voice)
{
	u8 *v1;

	v1 = (u8 *)(_spu_st_Info.voice[voice].data_addr + 1);
	*v1 = 6;
	v1[16] = 2;
	v1[_spu_st_buf_sizeSBhalf - 16] = 2;
	FlushDcache();
}

static void _SpuStSetMarkEND(int voice)
{
	u8 *v1;

	v1 = (u8 *)(_spu_st_Info.voice[voice].data_addr + 1);
	*v1 = 2;
	v1[16] = 2;
	v1[_spu_st_buf_sizeSBhalf - 16] = 3;
	FlushDcache();
}

static void _SpuStSetMarkFINAL(int voice)
{
	unsigned int v1;
	int *v2;
	u8 *v3;
	int v4;
	u8 *v5;
	u8 *v6;

	v1 = 16 * voice;
	v2 = &_spu_st_save_final_block[v1 / 4];
	v3 = (u8 *)(_spu_st_Info.voice[v1 / 0x10].data_addr + _spu_st_Info.voice[v1 / 0x10].last_size - 16);
	*(u8 *)v2 = *v3;
	*v3 = 0;
	v3 += 1;
	v2 = (int *)((char *)v2 + 1);
	*(u8 *)v2 = *v3;
	v5 = (u8 *)v2 + 1;
	*v3 = 7;
	v6 = v3 + 1;
	for ( v4 = 0; v4 < 14; v4 += 1 )
	{
		v5[v4] = v6[v4];
		v6[v4] = 0;
	}
	FlushDcache();
}

static void _SpuStSetMarkFINALrecover(int voice)
{
	unsigned int v1;
	int *v2;
	int v3;
	u8 *v4;

	v1 = 16 * voice;
	v2 = &_spu_st_save_final_block[v1 / 4];
	v4 = (u8 *)(_spu_st_Info.voice[v1 / 0x10].data_addr + _spu_st_Info.voice[v1 / 0x10].last_size - 16);
	for ( v3 = 0; v3 < 16; v3 += 1 )
	{
		v4[v3] = ((u8 *)v2)[v3];
	}
	FlushDcache();
}

static SpuStVoiceAttr *_SpuStSetPrepareEnv(int voice)
{
	SpuStVoiceAttr *v2;

	v2 = &_spu_st_Info.voice[voice];
	_spu_t(2, 8 * (v2->buf_addr >> 4));
	_SpuStSetMarkSTART(voice);
	_spu_t(1);
	return v2;
}

void _SpuStCBPrepare(void)
{
	int v0;

	v0 = _spu_st_start_prepare_voice_bit & ~(1 << _spu_st_start_prepare_voice_current);
	_spu_st_start_prepare_voice_bit = v0;
	if ( v0 )
	{
		int v1;

		for ( v1 = _spu_st_start_prepare_voice_current + 1; v1 < 24; v1 += 1 )
		{
			if ( (v0 & (1 << v1)) != 0 )
				break;
		}
		_spu_st_start_prepare_voice_current = v1;
		if ( v1 < 24 )
		{
			_spu_t(3, _SpuStSetPrepareEnv(v1)->data_addr, _spu_st_buf_sizeSBhalf);
		}
	}
	else
	{
		SpuSetTransferCallback(_spu_st_cb_transfer_saved);
		if ( _spu_st_Info.low_priority == SPU_ON )
			_spu_FsetPCR(1);
		_spu_st_stat_int = 34;
		if ( _spu_st_cb_prepare_finished )
		{
			_spu_st_cb_prepare_finished(_spu_st_start_prepare_tmp_voice_bit, SPU_ST_PREPARE);
			_spu_st_start_prepare_tmp_voice_bit = 0;
		}
	}
	FlushDcache();
}

static int _SpuStStartPrepare(int voice_bit)
{
	int v1;
	int v3;

	for ( v1 = 0; v1 < 24; v1 += 1 )
	{
		if ( (voice_bit & (1 << v1)) != 0 )
			break;
	}
	v3 = _spu_st_stat_int & 0xF0;
	if ( v3 == 32 )
		return SPU_ST_WRONG_STATUS;
	if ( (_spu_st_stat_int & 0xF0u) >= 0x21 )
	{
		if ( v3 == 48 )
		{
			_spu_st_start_prepare_tmp_voice_bit = voice_bit;
			_spu_st_start_prepare_voice_bit = voice_bit;
			_spu_st_start_prepare_voice_current = v1;
			_spu_st_start_prepare_lock = 0;
			return SPU_ST_ACCEPT;
		}
	}
	else
	{
		if ( v3 == 16 )
		{
			unsigned int data_addr;

			_spu_st_stat_int = 32;
			_spu_st_start_prepare_tmp_voice_bit = voice_bit;
			_spu_st_start_prepare_voice_bit = voice_bit;
			_spu_st_buf_sizeSBhalf = _spu_st_Info.size >> 1;
			_spu_st_cb_transfer_saved = SpuSetTransferCallback(_SpuStCBPrepare);
			if ( _spu_st_Info.low_priority == SPU_ON )
				_spu_FsetPCR(0);
			_spu_st_bufferP = 0;
			_spu_st_start_prepare_voice_current = v1;
			data_addr = _SpuStSetPrepareEnv(v1)->data_addr;
			_spu_st_stat_int = 33;
			_spu_t(3, data_addr, _spu_st_buf_sizeSBhalf);
			return SPU_ST_ACCEPT;
		}
	}
	return SPU_ST_WRONG_STATUS;
}

int IntFunc(void)
{
	Kprintf("*********------------\n");
	Kprintf("*********------------\n");
	Kprintf("*********------------\n");
	Kprintf("*********------------\n");
	Kprintf("*********------------\n");
	FlushDcache();
	return 1;
}

static SpuStVoiceAttr *_SpuStSetTransferEnv(int voice)
{
	SpuStVoiceAttr *v2;
	int v3;

	v2 = &_spu_st_Info.voice[voice];
	v3 = (v2->buf_addr >> 4) << 4;
	if ( _spu_st_bufferP )
	{
		v3 += _spu_st_buf_sizeSBhalf;
		_SpuStSetMarkEND(voice);
	}
	else
	{
		_SpuStSetMarkSTART(voice);
	}
	_spu_t(2, v3 >> 1);
	if ( v2->status == 2 )
	{
		int v4;

		_spu_st_start_voice_bit &= ~(1 << voice);
		_spu_st_stop_voice_bit |= 1 << voice;
		_SpuStSetMarkFINAL(voice);
		if ( _spu_st_start_voice_bit )
		{
			for ( v4 = 0; v4 < 24; v4 += 1 )
			{
				if ( (_spu_st_start_voice_bit & (1 << v4)) != 0 )
					break;
			}
			_spu_st_start_voice_smallest = v4;
		}
		else
		{
			_spu_st_start_voice_smallest = 24;
			for ( v4 = 0; v4 < 24; v4 += 1 )
			{
				if ( (_spu_st_stop_voice_bit & (1 << v4)) != 0 )
					break;
			}
			_spu_st_stop_voice_smallest = v4;
		}
	}
	_spu_t(1);
	return v2;
}

void _SpuStCB_IRQfinal(void)
{
	unsigned int v0;

	v0 = SpuSetCore(_st_core);
	SpuSetIRQ(SPU_OFF);
	SpuSetCore(v0);
	_spu_st_stat_int = 67;
	SpuSetIRQCallback(_spu_st_cb_IRQ_saved);
	SpuSetTransferCallback(_spu_st_cb_transfer_saved);
	if ( _spu_st_Info.low_priority == SPU_ON )
		_spu_FsetPCR(1);
	if ( _spu_st_cb_stream_finished && _spu_st_stop_voice_bit )
		_spu_st_cb_stream_finished(_spu_st_stop_voice_bit, SPU_ST_FINAL);
	_spu_st_stop_voice_bit = 0;
	_spu_st_stop_saved_voice_bit = 0;
	_spu_st_stat_int = 16;
}

static void _SpuStCB_IRQ(void)
{
	int v0;
	unsigned int v1;
	int v2;
	int v3;

	FlushDcache();
	v0 = -1;
	v1 = SpuSetCore(_st_core);
	SpuSetIRQ(SPU_OFF);
	SpuSetCore(v1);
	v2 = 0;
	if ( (_spu_st_stat_int & 0xF0) == 64 )
		v3 = 66;
	else
		v3 = 51;
	_spu_st_stat_int = v3;
	if ( _spu_st_stop_voice_bit )
	{
		int v4;

		for ( v4 = 0; v4 < 24; v4 += 1 )
		{
			if ( (_spu_st_stop_voice_bit & (1 << v4)) != 0 )
			{
				int last_size;
				unsigned int v8;
				int v9;

				last_size = _spu_st_Info.voice[v4].last_size;
#ifdef LIB_1300
				v8 = ((_spu_st_Info.voice[v4].buf_addr >> 4) << 4) + last_size - 8;
#else
				// Added in OSDSND 110U
				v8 = ((_spu_st_Info.voice[v4].buf_addr >> 4) << 4) + last_size - 16;
#endif
				if ( !_spu_st_bufferP )
					v8 += _spu_st_buf_sizeSBhalf;
				v9 = SpuSetCore(_st_core);
				_spu_FsetRXX(226 + (v4 * 6), (v8 >> 4) << 4, 1);
				_spu_core = v9;
				if ( v2 < last_size )
				{
					v2 = last_size;
					v0 = v4;
				}
			}
		}
	}
	if ( !_spu_st_start_voice_bit )
	{
		unsigned int v10;
		unsigned int v11;

#ifdef LIB_1300
		if ( v2 < 9 )
#else
		// Added in OSDSND 110U
		if ( v2 < 17 )
#endif
		{
			_SpuStCB_IRQfinal();
			return;
		}
		SpuSetIRQCallback(_SpuStCB_IRQfinal);
#ifdef LIB_1300
		v10 = ((_spu_st_Info.voice[v0].buf_addr >> 4) << 4) + v2 - 8;
#else
		// Added in OSDSND 110U
		v10 = ((_spu_st_Info.voice[v0].buf_addr >> 4) << 4) + v2 - 16;
#endif
		_spu_st_addrIRQ = v10;
		if ( !_spu_st_bufferP )
			_spu_st_addrIRQ = v10 + _spu_st_buf_sizeSBhalf;
		v11 = SpuSetCore(_st_core);
		SpuSetIRQAddr(_spu_st_addrIRQ);
		SpuSetCore(v11);
	}
	if ( _spu_st_cb_stream_finished && _spu_st_stop_saved_voice_bit )
		_spu_st_cb_stream_finished(_spu_st_stop_saved_voice_bit, SPU_ST_PLAY);
	if ( _spu_st_start_voice_bit )
	{
		_spu_st_start_tmp_voice_bit = _spu_st_start_voice_bit;
		_spu_st_stop_saved_voice_bit = _spu_st_stop_voice_bit;
		_spu_st_start_tmp_voice_current = _spu_st_start_voice_smallest;
		if ( _spu_st_bufferP )
		{
			if ( _spu_st_start_add_voice_bit && _spu_st_start_prepared_voice_bit && !_spu_st_start_add_lock )
			{
				int v16;
				unsigned int v17;
				int v18;
				int v20;

				v16 = _spu_st_start_add_voice_bit & _spu_st_start_prepared_voice_bit;
				v17 = SpuSetCore(_st_core);
				SpuSetKey(SPU_ON, v16);
				SpuSetCore(v17);
				if ( (_spu_env & 1) != 0 )
				{
					unsigned int v19;

					v19 = SpuSetCore(_st_core);
					SpuFlush(SPU_EVENT_KEY);
					SpuSetCore(v19);
				}
				_spu_st_start_prepared_voice_bit = 0;
				_spu_st_start_add_voice_bit = 0;
				v20 = _spu_st_start_voice_bit | v16;
				_spu_st_start_voice_bit = v20;
				_spu_st_start_tmp_voice_bit = v20;
				for ( v18 = 0; v18 < 24; v18 += 1 )
				{
					if ( (v20 & (1 << v18)) != 0 )
						break;
				}
				_spu_st_start_tmp_voice_current = v18;
				_spu_st_start_voice_smallest = v18;
			}
		}
		else
		{
			int v13;

			v13 = _spu_st_start_prepare_voice_bit;
			if ( _spu_st_start_prepare_voice_bit && !_spu_st_start_prepare_lock )
			{
				int v14;

				_spu_st_start_tmp_voice_bit = _spu_st_start_voice_bit | _spu_st_start_prepare_voice_bit;
				_spu_st_start_prepared_voice_bit = _spu_st_start_prepare_voice_bit;
				_spu_st_start_prepare_tmp_voice_bit = _spu_st_start_prepare_voice_bit;
				_spu_st_start_prepare_voice_bit = 0;
				for ( v14 = 0; v14 < 24; v14 += 1 )
				{
					if ( ((_spu_st_start_voice_bit | v13) & (1 << v14)) != 0 )
						break;
				}
				_spu_st_start_tmp_voice_current = v14;
			}
		}
		_spu_st_stop_voice_bit = 0;
		_spu_st_stat_int = 49;
		_spu_t(3, _SpuStSetTransferEnv(_spu_st_start_tmp_voice_current)->data_addr, _spu_st_buf_sizeSBhalf);
	}
	else
	{
		unsigned int v12;

		_spu_st_stat_int = 65;
		v12 = SpuSetCore(_st_core);
		SpuSetIRQ(SPU_ON);
		SpuSetCore(v12);
	}
	FlushDcache();
}

static void _SpuStCB_Transfer(void)
{
	SpuStVoiceAttr *v0;
	unsigned int v1;

	FlushDcache();
	_spu_st_start_tmp_voice_bit &= ~(1 << _spu_st_start_tmp_voice_current);
	v0 = &_spu_st_Info.voice[_spu_st_start_tmp_voice_current];
	if ( v0->status == 2 )
	{
		_SpuStSetMarkFINALrecover(_spu_st_start_tmp_voice_current);
		v0->status = 6;
	}
	v1 = SpuSetCore(_st_core);
	_spu_FsetRXX(6 * _spu_st_start_tmp_voice_current + 226, (v0->buf_addr >> 4) << 4, 1);
	SpuSetCore(v1);
	if ( _spu_st_start_tmp_voice_bit )
	{
		int v6;

		for ( v6 = _spu_st_start_tmp_voice_current + 1; v6 < 24; v6 += 1 )
		{
			if ( (_spu_st_start_tmp_voice_bit & (1 << v6)) != 0 )
				break;
		}
		_spu_st_start_tmp_voice_current = v6;
		_spu_t(3, _SpuStSetTransferEnv(v6)->data_addr, _spu_st_buf_sizeSBhalf);
	}
	else
	{
		int v2;
		unsigned int v3;
		unsigned int v4;
		unsigned int v5;

		if ( !_spu_st_bufferP && _spu_st_cb_prepare_finished && _spu_st_start_prepare_tmp_voice_bit )
		{
			_spu_st_cb_prepare_finished(_spu_st_start_prepare_tmp_voice_bit, SPU_ST_PLAY);
			_spu_st_start_prepare_tmp_voice_bit = 0;
		}
		if ( _spu_st_cb_transfer_finished && _spu_st_start_voice_bit )
			_spu_st_cb_transfer_finished(_spu_st_start_voice_bit, SPU_ST_PLAY);
		v2 = _spu_st_stop_voice_smallest;
		if ( _spu_st_start_voice_smallest < 24 )
			v2 = _spu_st_start_voice_smallest;
		v3 = (_spu_st_Info.voice[v2].buf_addr >> 4) << 4;
		_spu_st_addrIRQ = v3;
		_spu_st_bufferP = _spu_st_bufferP != 1;
		if ( _spu_st_bufferP != 1 )
			_spu_st_addrIRQ = v3 + _spu_st_buf_sizeSBhalf;
		v4 = SpuSetCore(_st_core);
		SpuSetIRQAddr(_spu_st_addrIRQ);
		SpuSetCore(v4);
		v5 = SpuSetCore(_st_core);
		SpuSetIRQ(SPU_ON);
		SpuSetCore(v5);
		_spu_st_stat_int = 64;
		if ( _spu_st_start_voice_smallest < 24 )
			_spu_st_stat_int = 50;
	}
	FlushDcache();
}

static int _SpuStStart(unsigned int voice_bit)
{
	FlushDcache();
	if ( (_spu_st_stat_int & 0xF0) == 32 )
	{
		if ( _spu_st_stat_int == 34 )
		{
			int v3;
			unsigned int v5;
			const SpuStVoiceAttr *v6;
			unsigned int v7;

			_spu_st_stat_int = 48;
			for ( v3 = 0; v3 < 24; v3 += 1 )
			{
				if ( (voice_bit & (1 << v3)) != 0 )
					break;
			}
			v5 = SpuSetCore(_st_core);
			SpuSetKey(SPU_ON, voice_bit);
			SpuSetCore(v5);
			if ( (_spu_env & 1) != 0 )
				SpuFlush(SPU_EVENT_KEY);
			_spu_st_start_voice_bit = voice_bit;
			_spu_st_start_tmp_voice_bit = voice_bit;
			_spu_st_stop_saved_voice_bit = 0;
			_spu_st_stop_voice_bit = 0;
			_spu_st_cb_transfer_saved = SpuSetTransferCallback(_SpuStCB_Transfer);
			if ( _spu_st_Info.low_priority == SPU_ON )
				_spu_FsetPCR(0);
			_spu_st_cb_IRQ_saved = SpuSetIRQCallback(_SpuStCB_IRQ);
			_spu_st_bufferP = 1;
			_spu_st_start_tmp_voice_current = v3;
			_spu_st_start_voice_smallest = v3;
			v6 = _SpuStSetTransferEnv(v3);
			v7 = SpuSetCore(_st_core);
			SpuSetIRQ(SPU_OFF);
			SpuSetCore(v7);
			_spu_st_stat_int = 49;
			_spu_t(3, v6->data_addr, _spu_st_buf_sizeSBhalf);
			FlushDcache();
			return SPU_ST_ACCEPT;
		}
	}
	else
	{
		if ( (_spu_st_stat_int & 0xF0u) >= 0x21 )
		{
			if ( (_spu_st_stat_int & 0xF0) == 48 )
			{
				_spu_st_start_add_voice_bit = voice_bit;
				_spu_st_start_add_lock = 0;
				return SPU_ST_ACCEPT;
			}
		}
	}
	return SPU_ST_WRONG_STATUS;
}

int SpuStTransfer(int flag, unsigned int voice_bit)
{
	unsigned int v4;

	if ( !_spu_st_stat_int )
		return 0;
	v4 = voice_bit & 0xFFFFFF;
	if ( (voice_bit & 0xFFFFFF) == 0 )
	{
		return SPU_ST_INVALID_ARGUMENT;
	}
	if ( flag == SPU_ST_PREPARE )
	{
		return _SpuStStartPrepare(v4);
	}
	if ( flag >= SPU_ST_PREPARE && flag <= SPU_ST_PLAY )
	{
		return _SpuStStart(v4);
	}
	return SPU_ST_INVALID_ARGUMENT;
}

static void _SpuStReset(void)
{
	int v0;

	_spu_st_cb_transfer_finished = 0;
	_spu_st_cb_prepare_finished = 0;
	_spu_st_cb_stream_finished = 0;
	_spu_st_cb_transfer_saved = 0;
	_spu_st_cb_IRQ_saved = 0;
	_spu_st_start_voice_bit = 0;
	_spu_st_start_tmp_voice_bit = 0;
	_spu_st_start_add_voice_bit = 0;
	_spu_st_start_prepare_voice_bit = 0;
	_spu_st_start_prepare_tmp_voice_bit = 0;
	_spu_st_start_prepared_voice_bit = 0;
	_spu_st_stop_voice_bit = 0;
	_spu_st_stop_saved_voice_bit = 0;
	_spu_st_tmp_voice_bit = 0;
	_spu_st_start_voice_smallest = 24;
	_spu_st_start_tmp_voice_current = 24;
	_spu_st_start_prepare_voice_current = 24;
	_spu_st_start_prepare_voice_smallest = 24;
	_spu_st_stop_voice_smallest = 24;
	for ( v0 = 0; v0 < 24; v0 += 1 )
	{
		_spu_st_Info.voice[v0].status = 6;
		_spu_st_Info.voice[v0].last_size = 0;
		_spu_st_Info.voice[v0].buf_addr = 0;
		_spu_st_Info.voice[v0].data_addr = 0;
	}
	_spu_st_Info.size = 0;
	_spu_st_Info.low_priority = SPU_OFF;
	_spu_st_buf_sizeSBhalf = 0;
	_spu_st_bufferP = 0;
	_spu_st_start_prepare_lock = 0;
	_spu_st_start_add_lock = 0;
}

SpuStEnv *SpuStInit(int mode)
{
	(void)mode;

	_spu_st_stat_int = 16;
	_SpuStReset();
	return &_spu_st_Info;
}

int SpuStQuit(void)
{
	if ( _spu_st_stat_int != 16 )
		return SPU_ST_WRONG_STATUS;
	_spu_st_stat_int = 0;
	_SpuStReset();
	return SPU_ST_ACCEPT;
}

int SpuStGetStatus(void)
{
	switch ( _spu_st_stat_int & 0xF0 )
	{
		case 0:
			return SPU_ST_NOT_AVAILABLE;
		case 16:
			return SPU_ST_IDLE;
		case 32:
			return SPU_ST_PREPARE;
		case 48:
			return SPU_ST_TRANSFER;
		case 64:
			return SPU_ST_FINAL;
		default:
			return SPU_ST_WRONG_STATUS;
	}
}

unsigned int SpuStGetVoiceStatus(void)
{
	return _spu_st_start_voice_bit;
}

SpuStCallbackProc SpuStSetPreparationFinishedCallback(SpuStCallbackProc func)
{
	SpuStCallbackProc result;

	result = _spu_st_cb_prepare_finished;
	if ( func != _spu_st_cb_prepare_finished )
		_spu_st_cb_prepare_finished = func;
	return result;
}

SpuStCallbackProc SpuStSetTransferFinishedCallback(SpuStCallbackProc func)
{
	SpuStCallbackProc result;

	result = _spu_st_cb_transfer_finished;
	if ( func != _spu_st_cb_transfer_finished )
		_spu_st_cb_transfer_finished = func;
	return result;
}

SpuStCallbackProc SpuStSetStreamFinishedCallback(SpuStCallbackProc func)
{
	SpuStCallbackProc result;

	result = _spu_st_cb_stream_finished;
	if ( func != _spu_st_cb_stream_finished )
		_spu_st_cb_stream_finished = func;
	return result;
}

unsigned int SpuStSetCore(unsigned int core)
{
	unsigned int result;

	result = _st_core;
	_st_core = core & 1;
	return result;
}

// libspu2/s_svv.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceVolume(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceVolume(int v_num, s16 voll, s16 volr)
{
	vu16 *regstmp;

	regstmp = &_spu_RXX[512 * _spu_core + 8 * v_num];
	regstmp[0] = voll & ~0x8000;
	regstmp[1] = volr & ~0x8000;
	_spu_wait_SpuSetVoiceVolume();
}

// libspu2/s_svva.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceVolumeAttr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceVolumeAttr(int v_num, s16 voll, s16 volr, s16 voll_mode, s16 volr_mode)
{
	s16 v5;
	s16 v6;
	int v7;
	s16 v8;
	s16 v9;

	v5 = voll & ~0x8000;
	v6 = 0;
	v7 = 8 * v_num;
	switch ( voll_mode )
	{
		case SPU_VOICE_LINEARIncN:
			v6 = 0x8000;
			break;
		case SPU_VOICE_LINEARIncR:
			v6 = 0x9000;
			break;
		case SPU_VOICE_LINEARDecN:
			v6 = 0xA000;
			break;
		case SPU_VOICE_LINEARDecR:
			v6 = 0xB000;
			break;
		case SPU_VOICE_EXPIncN:
			v6 = 0xC000;
			break;
		case SPU_VOICE_EXPIncR:
			v6 = 0xD000;
			break;
		case SPU_VOICE_EXPDec:
			v6 = 0xE000;
			break;
		default:
			break;
	}
	v8 = volr & ~0x8000;
	v9 = 0;
	_spu_RXX[512 * _spu_core + v7] = v5 | v6;
	switch ( volr_mode )
	{
		case SPU_VOICE_LINEARIncN:
			v9 = 0x8000;
			break;
		case SPU_VOICE_LINEARIncR:
			v9 = 0x9000;
			break;
		case SPU_VOICE_LINEARDecN:
			v9 = 0xA000;
			break;
		case SPU_VOICE_LINEARDecR:
			v9 = 0xB000;
			break;
		case SPU_VOICE_EXPIncN:
			v9 = 0xC000;
			break;
		case SPU_VOICE_EXPIncR:
			v9 = 0xD000;
			break;
		case SPU_VOICE_EXPDec:
			v9 = 0xE000;
			break;
		default:
			break;
	}
	_spu_RXX[512 * _spu_core + 1 + v7] = v8 | v9;
	_spu_wait_SpuSetVoiceVolumeAttr();
}

// libspu2/s_svp.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoicePitch(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoicePitch(int v_num, u16 pitch)
{
	_spu_RXX[512 * _spu_core + 2 + 8 * v_num] = pitch;
	_spu_wait_SpuSetVoicePitch();
}

// libspu2/s_svn.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceNote(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceNote(int v_num, u16 note)
{
	unsigned int v4;

	v4 = (u16)_spu_voice_centerNote[_spu_core][v_num];
	_spu_RXX[512 * _spu_core + 2 + 8 * v_num] = _spu_note2pitch(v4 >> 8, (u8)v4, (u16)(note & 0xFF00) >> 8, (u8)note);
	_spu_wait_SpuSetVoiceNote();
}

// libspu2/s_svsn.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceSampleNote(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceSampleNote(int v_num, u16 sample_note)
{
	_spu_voice_centerNote[_spu_core][v_num] = sample_note;
	_spu_wait_SpuSetVoiceSampleNote();
}

// libspu2/s_svsa.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceStartAddr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceStartAddr(int v_num, unsigned int start_addr)
{
	_spu_FsetRXX(6 * v_num + 224, (start_addr >> 4) << 4, 1);
	_spu_wait_SpuSetVoiceStartAddr();
}

// libspu2/s_svlsa.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceLoopStartAddr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceLoopStartAddr(int v_num, unsigned int lsa)
{
	_spu_FsetRXX(6 * v_num + 226, (lsa >> 4) << 4, 1);
	_spu_wait_SpuSetVoiceLoopStartAddr();
}

// libspu2/s_svar.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceAR(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceAR(int v_num, u16 ar)
{
	vu16 *v2;

	v2 = &_spu_RXX[512 * _spu_core + 8 * v_num];
	v2[3] = (u8)v2[3] | (u16)(ar << 8);
	_spu_wait_SpuSetVoiceAR();
}

// libspu2/s_svdr.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceDR(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceDR(int v_num, u16 dr)
{
	vu16 *v2;

	v2 = &_spu_RXX[512 * _spu_core + 8 * v_num];
	v2[3] = (v2[3] & ~0xf0) | (16 * dr);
	_spu_wait_SpuSetVoiceDR();
}

// libspu2/s_svsr.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceSR(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceSR(int v_num, u16 sr)
{
	vu16 *v2;

	v2 = &_spu_RXX[512 * _spu_core + 8 * v_num];
	v2[4] = (v2[4] & 0x3F) | ((sr | 0x100) << 6);
	_spu_wait_SpuSetVoiceSR();
}

// libspu2/s_svrro

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceRR(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceRR(int v_num, u16 rr)
{
	vu16 *v2;

	v2 = &_spu_RXX[512 * _spu_core + 8 * v_num];
	v2[4] = (v2[4] & ~0x3f) | rr;
	_spu_wait_SpuSetVoiceRR();
}

// libspu2/s_svsl.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceSL(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceSL(int v_num, u16 sl)
{
	vu16 *v2;

	v2 = &_spu_RXX[512 * _spu_core + 8 * v_num];
	v2[3] = (v2[3] & ~0xF) | sl;
	_spu_wait_SpuSetVoiceSL();
}

// libspu2/s_svara.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceARAttr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceARAttr(int v_num, u16 ar, int ar_mode)
{
	vu16 *v3;

	v3 = &_spu_RXX[512 * _spu_core + 8 * v_num];
	v3[3] = (u8)v3[3] | (u16)((ar | ((ar_mode == SPU_VOICE_EXPIncN) << 7)) << 8);
	_spu_wait_SpuSetVoiceARAttr();
}

// libspu2/s_svsra.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceSRAttr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceSRAttr(int v_num, u16 sr, int sr_mode)
{
	s16 v3;
	int v4;

	v4 = 8 * v_num;
	switch ( sr_mode )
	{
		case SPU_VOICE_LINEARIncN:
			v3 = 0;
			break;
		case SPU_VOICE_EXPIncN:
			v3 = 512;
			break;
		case SPU_VOICE_EXPDec:
			v3 = 768;
			break;
		default:
			v3 = 256;
			break;
	}
	_spu_RXX[512 * _spu_core + 4 + v4] = (_spu_RXX[512 * _spu_core + 4 + v4] & 0x3F) | ((sr | (u16)v3) << 6);
	_spu_wait_SpuSetVoiceSRAttr();
}

// libspu2/s_svrra.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceRRAttr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceRRAttr(int v_num, u16 rr, int rr_mode)
{
	s16 v3;
	int v4;

	v3 = 0;
	v4 = 8 * v_num;
	if ( rr_mode != SPU_VOICE_LINEARDecN )
		v3 = 32 * (rr_mode == SPU_VOICE_EXPDec);
	_spu_RXX[512 * _spu_core + 4 + v4] = (_spu_RXX[512 * _spu_core + 4 + v4] & ~0x3f) | rr | v3;
	_spu_wait_SpuSetVoiceRRAttr();
}

// libspu2/s_svad.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceADSR(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceADSR(int v_num, u16 ar, u16 dr, u16 sr, u16 rr, u16 sl)
{
	vu16 *v6;

	v6 = &_spu_RXX[512 * _spu_core + 8 * v_num];
	v6[3] = ((ar & 0x7F) << 8) | (16 * (dr & 0xF)) | (sl & 0xF);
	v6[4] = ((sr & 0x7F) << 6) | (rr & 0x1F) | 0x4000;
	_spu_wait_SpuSetVoiceADSR();
}

// libspu2/s_svada.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceADSRAttr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceADSRAttr(int v_num, u16 ar, u16 dr, u16 sr, u16 rr, u16 sl, int ar_mode, int sr_mode, int rr_mode)
{
	s16 v9;
	s16 v10;
	int v11;
	s16 v12;
	u16 v13;

	v9 = ((ar & 0x7F) << 8) | (16 * (dr & 0xF));
	v10 = ((sr & 0x7F) << 6) | (rr & 0x1F);
	v11 = 8 * v_num;
	_spu_RXX[512 * _spu_core + 3 + 8 * v_num] = v9 | (sl & 0xF) | ((ar_mode == SPU_VOICE_EXPIncN) << 15);
	switch ( sr_mode )
	{
		case SPU_VOICE_LINEARIncN:
			v12 = 0;
			break;
		case SPU_VOICE_EXPIncN:
			v12 = 0x8000;
			break;
		case SPU_VOICE_EXPDec:
			v12 = 0xC000;
			break;
		default:
			v12 = 0x4000;
			break;
	}
	v13 = v10 | v12;
	if ( rr_mode == SPU_VOICE_EXPDec )
		v13 = v10 | v12 | 0x20;
	_spu_RXX[512 * _spu_core + 4 + v11] = v13;
	_spu_wait_SpuSetVoiceADSRAttr();
}

// libspu2/s_sva.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuSetVoiceAttr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuSetVoiceAttr(SpuVoiceAttr *arg)
{
	int voice_num;
	unsigned int attr_mask;
	int regtmp;
	int vol_left_upper;
	s16 vol_left_clamped;
	int vol_left;
	int vol_right_upper;
	s16 vol_right_clamped;
	int vol_right;
	unsigned int attr_ar;
	s16 adsr_ar_part;
	unsigned int adsr_dr_part;
	unsigned int adsr_sr_part;
	s16 converted_s_mode;
	unsigned int adsr_rr_part;
	s16 attr_r_mode_converted;
	unsigned int attr_sl;

	attr_mask = arg->mask;
	if ( attr_mask == 0 )
	{
		attr_mask = 0xFFFFFFFF;
	}
	for ( voice_num = 0; voice_num < 24; voice_num += 1 )
	{
		if ( (arg->voice & (1 << voice_num)) != 0 )
		{
			int converted_voice_num;

			converted_voice_num = 8 * voice_num;
			regtmp = 2 * (voice_num * 2 + voice_num);
			if ( (attr_mask & SPU_VOICE_PITCH) != 0 )
				_spu_RXX[512 * _spu_core + 2 + converted_voice_num] = arg->pitch;
			if ( (attr_mask & SPU_VOICE_SAMPLE_NOTE) != 0 )
				_spu_voice_centerNote[_spu_core][voice_num] = arg->sample_note;
			if ( (attr_mask & SPU_VOICE_NOTE) != 0 )
				_spu_RXX[512 * _spu_core + 2 + converted_voice_num] = _spu_note2pitch(
					(_spu_voice_centerNote[_spu_core][voice_num] >> 8) & 0xFF,
					(u8)_spu_voice_centerNote[_spu_core][voice_num],
					(arg->note >> 8) & 0xFF,
					(u8)arg->note);
			if ( (attr_mask & SPU_VOICE_VOLL) != 0 )
			{
				vol_left_upper = 0;
				vol_left_clamped = arg->volume.left & ~0x8000;
				if ( (attr_mask & SPU_VOICE_VOLMODEL) != 0 )
				{
					switch ( arg->volmode.left )
					{
						case SPU_VOICE_LINEARIncN:
							vol_left_upper = 0x8000;
							break;
						case SPU_VOICE_LINEARIncR:
							vol_left_upper = 0x9000;
							break;
						case SPU_VOICE_LINEARDecN:
							vol_left_upper = 0xa000;
							break;
						case SPU_VOICE_LINEARDecR:
							vol_left_upper = 0xb000;
							break;
						case SPU_VOICE_EXPIncN:
							vol_left_upper = 0xc000;
							break;
						case SPU_VOICE_EXPIncR:
							vol_left_upper = 0xd000;
							break;
						case SPU_VOICE_EXPDec:
							vol_left_upper = 0xe000;
							break;
						default:
							break;
					}
				}
				if ( vol_left_upper )
				{
					vol_left = arg->volume.left;
					if ( vol_left < 128 )
					{
						if ( vol_left < 0 )
							vol_left_clamped = 0;
					}
					else
					{
						vol_left_clamped = 127;
					}
				}
				_spu_RXX[512 * _spu_core + converted_voice_num] = vol_left_clamped | vol_left_upper;
			}
			if ( (attr_mask & SPU_VOICE_VOLR) != 0 )
			{
				vol_right_upper = 0;
				vol_right_clamped = arg->volume.right & ~0x8000;
				if ( (attr_mask & SPU_VOICE_VOLMODER) != 0 )
				{
					switch ( arg->volmode.right )
					{
						case SPU_VOICE_LINEARIncN:
							vol_right_upper = 0x8000;
							break;
						case SPU_VOICE_LINEARIncR:
							vol_right_upper = 0x9000;
							break;
						case SPU_VOICE_LINEARDecN:
							vol_right_upper = 0xa000;
							break;
						case SPU_VOICE_LINEARDecR:
							vol_right_upper = 0xb000;
							break;
						case SPU_VOICE_EXPIncN:
							vol_right_upper = 0xc000;
							break;
						case SPU_VOICE_EXPIncR:
							vol_right_upper = 0xd000;
							break;
						case SPU_VOICE_EXPDec:
							vol_right_upper = 0xe000;
							break;
						default:
							break;
					}
				}
				if ( vol_right_upper )
				{
					vol_right = arg->volume.right;
					if ( vol_right < 128 )
					{
						if ( vol_right < 0 )
							vol_right_clamped = 0;
					}
					else
					{
						vol_right_clamped = 127;
					}
				}
				_spu_RXX[512 * _spu_core + 1 + converted_voice_num] = vol_right_clamped | vol_right_upper;
			}
			if ( (attr_mask & SPU_VOICE_WDSA) != 0 )
				_spu_FsetRXX(regtmp + 224, (arg->addr >> 4) << 4, 1);
			if ( (attr_mask & SPU_VOICE_LSAX) != 0 )
				_spu_FsetRXX(regtmp + 226, (arg->loop_addr >> 4) << 4, 1);
			if ( (attr_mask & SPU_VOICE_ADSR_ADSR1) != 0 )
				_spu_RXX[512 * _spu_core + 3 + converted_voice_num] = arg->adsr1;
			if ( (attr_mask & SPU_VOICE_ADSR_ADSR2) != 0 )
				_spu_RXX[512 * _spu_core + 4 + converted_voice_num] = arg->adsr2;
			if ( (attr_mask & SPU_VOICE_ADSR_AR) != 0 )
			{
				attr_ar = arg->ar;
				if ( attr_ar >= 0x80 )
					attr_ar = 127;
				adsr_ar_part = 0;
				if ( ((attr_mask & SPU_VOICE_ADSR_AMODE) != 0) && arg->a_mode == SPU_VOICE_EXPIncN )
					adsr_ar_part = 128;
				_spu_RXX[512 * _spu_core + 3 + converted_voice_num] =
					(u8)_spu_RXX[512 * _spu_core + 3 + converted_voice_num] | (u16)(((u16)attr_ar | (u16)adsr_ar_part) << 8);
			}
			if ( (attr_mask & SPU_VOICE_ADSR_DR) != 0 )
			{
				adsr_dr_part = arg->dr;
				if ( adsr_dr_part >= 0x10 )
					adsr_dr_part = 15;
				_spu_RXX[512 * _spu_core + 3 + converted_voice_num] =
					(_spu_RXX[512 * _spu_core + 3 + converted_voice_num] & ~0xf0) | (16 * adsr_dr_part);
			}
			if ( (attr_mask & SPU_VOICE_ADSR_SR) != 0 )
			{
				adsr_sr_part = arg->sr;
				if ( adsr_sr_part >= 0x80 )
					adsr_sr_part = 127;
				converted_s_mode = 256;
				if ( (attr_mask & SPU_VOICE_ADSR_SMODE) != 0 )
				{
					switch ( arg->s_mode )
					{
						case SPU_VOICE_LINEARIncN:
							converted_s_mode = 0;
							break;
						case SPU_VOICE_EXPIncN:
							converted_s_mode = 512;
							break;
						case SPU_VOICE_EXPDec:
							converted_s_mode = 768;
							break;
						default:
							break;
					}
				}
				_spu_RXX[512 * _spu_core + 4 + converted_voice_num] =
					(_spu_RXX[512 * _spu_core + 4 + converted_voice_num] & 0x3F)
					| (((u16)adsr_sr_part | (u16)converted_s_mode) << 6);
			}
			if ( (attr_mask & SPU_VOICE_ADSR_RR) != 0 )
			{
				adsr_rr_part = arg->rr;
				if ( adsr_rr_part >= 0x20 )
					adsr_rr_part = 31;
				attr_r_mode_converted = 0;
				if ( (attr_mask & SPU_VOICE_ADSR_RMODE) != 0 )
				{
					if ( arg->r_mode == SPU_VOICE_EXPDec )
						attr_r_mode_converted = 32;
				}
				_spu_RXX[512 * _spu_core + 4 + converted_voice_num] =
					(_spu_RXX[512 * _spu_core + 4 + converted_voice_num] & ~0x3f) | adsr_rr_part | attr_r_mode_converted;
			}
			if ( (attr_mask & SPU_VOICE_ADSR_SL) != 0 )
			{
				attr_sl = arg->sl;
				if ( attr_sl >= 0x10 )
					attr_sl = 15;
				_spu_RXX[512 * _spu_core + 3 + converted_voice_num] =
					(_spu_RXX[512 * _spu_core + 3 + converted_voice_num] & ~0xF) | attr_sl;
			}
		}
	}
	_spu_wait_SpuSetVoiceAttr();
}

// libspu2/sr_sva.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuRSetVoiceAttr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

int SpuRSetVoiceAttr(int min_, int max_, SpuVoiceAttr *arg)
{
	unsigned int attr_mask;
	int v5;
	int v8;
	int i;
	int v12;
	int v13;
	s16 v14;
	int left;
	int v16;
	s16 v17;
	int right;
	unsigned int ar;
	s16 v20;
	unsigned int dr;
	unsigned int sr;
	s16 v23;
	unsigned int rr;
	s16 v26;
	unsigned int sl;

	attr_mask = arg->mask;
	if ( attr_mask == 0 )
	{
		attr_mask = 0xFFFFFFFF;
	}
	v5 = max_;
	if ( min_ < 0 )
		min_ = 0;
	if ( min_ >= 24 )
		return SPU_INVALID_ARGS;
	if ( max_ >= 24 )
		v5 = 23;
	if ( v5 < 0 )
	{
		return SPU_INVALID_ARGS;
	}
	v8 = v5 + 1;
	if ( v5 < min_ )
		return SPU_INVALID_ARGS;
	for ( i = min_; i < v8; i += 1 )
	{
		if ( (arg->voice & (1 << i)) != 0 )
		{
			int v11;

			v11 = 8 * i;
			v12 = 2 * (i * 2 + i);
			if ( (attr_mask & SPU_VOICE_PITCH) != 0 )
				_spu_RXX[512 * _spu_core + 2 + v11] = arg->pitch;
			if ( (attr_mask & SPU_VOICE_SAMPLE_NOTE) != 0 )
				_spu_voice_centerNote[_spu_core][i] = arg->sample_note;
			if ( (attr_mask & SPU_VOICE_NOTE) != 0 )
				_spu_RXX[512 * _spu_core + 2 + v11] = _spu_note2pitch(
					(_spu_voice_centerNote[_spu_core][i] >> 8) & 0xFF,
					(u8)_spu_voice_centerNote[_spu_core][i],
					(arg->note >> 8) & 0xFF,
					(u8)arg->note);
			if ( (attr_mask & SPU_VOICE_VOLL) != 0 )
			{
				v13 = 0;
				v14 = arg->volume.left & ~0x8000;
				if ( (attr_mask & SPU_VOICE_VOLMODEL) != 0 )
				{
					switch ( arg->volmode.left )
					{
						case SPU_VOICE_LINEARIncN:
							v13 = 0x8000;
							break;
						case SPU_VOICE_LINEARIncR:
							v13 = 0x9000;
							break;
						case SPU_VOICE_LINEARDecN:
							v13 = 0xa000;
							break;
						case SPU_VOICE_LINEARDecR:
							v13 = 0xb000;
							break;
						case SPU_VOICE_EXPIncN:
							v13 = 0xc000;
							break;
						case SPU_VOICE_EXPIncR:
							v13 = 0xd000;
							break;
						case SPU_VOICE_EXPDec:
							v13 = 0xe000;
							break;
						default:
							break;
					}
				}
				if ( v13 )
				{
					left = arg->volume.left;
					if ( left < 128 )
					{
						if ( left < 0 )
							v14 = 0;
					}
					else
					{
						v14 = 127;
					}
				}
				_spu_RXX[512 * _spu_core + v11] = v14 | v13;
			}
			if ( (attr_mask & SPU_VOICE_VOLR) != 0 )
			{
				v16 = 0;
				v17 = arg->volume.right & ~0x8000;
				if ( (attr_mask & SPU_VOICE_VOLMODER) != 0 )
				{
					switch ( arg->volmode.right )
					{
						case SPU_VOICE_LINEARIncN:
							v16 = 0x8000;
							break;
						case SPU_VOICE_LINEARIncR:
							v16 = 0x9000;
							break;
						case SPU_VOICE_LINEARDecN:
							v16 = 0xa000;
							break;
						case SPU_VOICE_LINEARDecR:
							v16 = 0xb000;
							break;
						case SPU_VOICE_EXPIncN:
							v16 = 0xc000;
							break;
						case SPU_VOICE_EXPIncR:
							v16 = 0xd000;
							break;
						case SPU_VOICE_EXPDec:
							v16 = 0xe000;
							break;
						default:
							break;
					}
				}
				if ( v16 )
				{
					right = arg->volume.right;
					if ( right < 128 )
					{
						if ( right < 0 )
							v17 = 0;
					}
					else
					{
						v17 = 127;
					}
				}
				_spu_RXX[512 * _spu_core + 1 + v11] = v17 | v16;
			}
			if ( (attr_mask & SPU_VOICE_WDSA) != 0 )
				_spu_FsetRXX(v12 + 224, (arg->addr >> 4) << 4, 1);
			if ( (attr_mask & SPU_VOICE_LSAX) != 0 )
				_spu_FsetRXX(v12 + 226, (arg->loop_addr >> 4) << 4, 1);
			if ( (attr_mask & SPU_VOICE_ADSR_ADSR1) != 0 )
				_spu_RXX[512 * _spu_core + 3 + v11] = arg->adsr1;
			if ( (attr_mask & SPU_VOICE_ADSR_ADSR2) != 0 )
				_spu_RXX[512 * _spu_core + 4 + v11] = arg->adsr2;
			if ( (attr_mask & SPU_VOICE_ADSR_AR) != 0 )
			{
				ar = arg->ar;
				if ( ar >= 0x80 )
					ar = 127;
				v20 = 0;
				if ( ((attr_mask & SPU_VOICE_ADSR_AMODE) != 0) && arg->a_mode == SPU_VOICE_EXPIncN )
					v20 = 128;
				_spu_RXX[512 * _spu_core + 3 + v11] =
					(u8)_spu_RXX[512 * _spu_core + 3 + v11] | (u16)(((u16)ar | (u16)v20) << 8);
			}
			if ( (attr_mask & SPU_VOICE_ADSR_DR) != 0 )
			{
				dr = arg->dr;
				if ( dr >= 0x10 )
					dr = 15;
				_spu_RXX[512 * _spu_core + 3 + v11] = (_spu_RXX[512 * _spu_core + 3 + v11] & ~0xf0) | (16 * dr);
			}
			if ( (attr_mask & SPU_VOICE_ADSR_SR) != 0 )
			{
				sr = arg->sr;
				if ( sr >= 0x80 )
					sr = 127;
				v23 = 256;
				if ( (attr_mask & SPU_VOICE_ADSR_SMODE) != 0 )
				{
					switch ( arg->s_mode )
					{
						case SPU_VOICE_LINEARIncN:
							v23 = 0;
							break;
						case SPU_VOICE_EXPIncN:
							v23 = 512;
							break;
						case SPU_VOICE_EXPDec:
							v23 = 768;
							break;
						default:
							break;
					}
				}
				_spu_RXX[512 * _spu_core + 4 + v11] =
					(_spu_RXX[512 * _spu_core + 4 + v11] & 0x3F) | (((u16)sr | (u16)v23) << 6);
			}
			if ( (attr_mask & SPU_VOICE_ADSR_RR) != 0 )
			{
				rr = arg->rr;
				if ( rr >= 0x20 )
					rr = 31;
				v26 = 0;
				if ( (attr_mask & SPU_VOICE_ADSR_RMODE) != 0 )
				{
					if ( arg->r_mode == SPU_VOICE_EXPDec )
						v26 = 32;
				}
				_spu_RXX[512 * _spu_core + 4 + v11] = (_spu_RXX[512 * _spu_core + 4 + v11] & ~0x3f) | rr | v26;
			}
			if ( (attr_mask & SPU_VOICE_ADSR_SL) != 0 )
			{
				sl = arg->sl;
				if ( sl >= 0x10 )
					sl = 15;
				_spu_RXX[512 * _spu_core + 3 + v11] = (_spu_RXX[512 * _spu_core + 3 + v11] & ~0xF) | sl;
			}
		}
	}
	_spu_wait_SpuRSetVoiceAttr();
	return SPU_SUCCESS;
}

// libspu2/sn_sva.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuNSetVoiceAttr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuNSetVoiceAttr(int v_num, SpuVoiceAttr *arg)
{
	int v3;
	unsigned int attr_mask;
	int v5;

	v3 = 8 * v_num;
	attr_mask = arg->mask;
	if ( attr_mask == 0 )
	{
		attr_mask = 0xFFFFFFFF;
	}
	v5 = 6 * v_num;
	if ( (attr_mask & SPU_VOICE_PITCH) != 0 )
		_spu_RXX[512 * _spu_core + 2 + v3] = arg->pitch;
	if ( (attr_mask & SPU_VOICE_SAMPLE_NOTE) != 0 )
		_spu_voice_centerNote[_spu_core][v_num] = arg->sample_note;
	if ( (attr_mask & SPU_VOICE_NOTE) != 0 )
		_spu_RXX[512 * _spu_core + 2 + v3] = _spu_note2pitch(
			(_spu_voice_centerNote[_spu_core][v_num] >> 8) & 0xFF,
			(u8)_spu_voice_centerNote[_spu_core][v_num],
			(arg->note >> 8) & 0xFF,
			(u8)arg->note);
	if ( (attr_mask & SPU_VOICE_VOLL) != 0 )
	{
		int v6;
		s16 v7;

		v6 = 0;
		v7 = arg->volume.left & ~0x8000;
		if ( (attr_mask & SPU_VOICE_VOLMODEL) != 0 )
		{
			switch ( arg->volmode.left )
			{
				case SPU_VOICE_LINEARIncN:
					v6 = 0x8000;
					break;
				case SPU_VOICE_LINEARIncR:
					v6 = 0x9000;
					break;
				case SPU_VOICE_LINEARDecN:
					v6 = 0xa000;
					break;
				case SPU_VOICE_LINEARDecR:
					v6 = 0xb000;
					break;
				case SPU_VOICE_EXPIncN:
					v6 = 0xc000;
					break;
				case SPU_VOICE_EXPIncR:
					v6 = 0xd000;
					break;
				case SPU_VOICE_EXPDec:
					v6 = 0xe000;
					break;
				default:
					break;
			}
		}
		if ( v6 )
		{
			int left;

			left = arg->volume.left;
			if ( left < 128 )
			{
				if ( left < 0 )
					v7 = 0;
			}
			else
			{
				v7 = 127;
			}
		}
		_spu_RXX[512 * _spu_core + v3] = v7 | v6;
	}
	if ( (attr_mask & SPU_VOICE_VOLR) != 0 )
	{
		int v9;
		s16 v10;

		v9 = 0;
		v10 = arg->volume.right & ~0x8000;
		if ( (attr_mask & SPU_VOICE_VOLMODER) != 0 )
		{
			switch ( arg->volmode.right )
			{
				case SPU_VOICE_LINEARIncN:
					v9 = 0x8000;
					break;
				case SPU_VOICE_LINEARIncR:
					v9 = 0x9000;
					break;
				case SPU_VOICE_LINEARDecN:
					v9 = 0xa000;
					break;
				case SPU_VOICE_LINEARDecR:
					v9 = 0xb000;
					break;
				case SPU_VOICE_EXPIncN:
					v9 = 0xc000;
					break;
				case SPU_VOICE_EXPIncR:
					v9 = 0xd000;
					break;
				case SPU_VOICE_EXPDec:
					v9 = 0xe000;
					break;
				default:
					break;
			}
		}
		if ( v9 )
		{
			int right;

			right = arg->volume.right;
			if ( right < 128 )
			{
				if ( right < 0 )
					v10 = 0;
			}
			else
			{
				v10 = 127;
			}
		}
		_spu_RXX[512 * _spu_core + 1 + v3] = v10 | v9;
	}
	if ( (attr_mask & SPU_VOICE_WDSA) != 0 )
		_spu_FsetRXX(v5 + 224, (arg->addr >> 4) << 4, 1);
	if ( (attr_mask & SPU_VOICE_LSAX) != 0 )
		_spu_FsetRXX(v5 + 226, (arg->loop_addr >> 4) << 4, 1);
	if ( (attr_mask & SPU_VOICE_ADSR_ADSR1) != 0 )
		_spu_RXX[512 * _spu_core + 3 + v3] = arg->adsr1;
	if ( (attr_mask & SPU_VOICE_ADSR_ADSR2) != 0 )
		_spu_RXX[512 * _spu_core + 4 + v3] = arg->adsr2;
	if ( (attr_mask & SPU_VOICE_ADSR_AR) != 0 )
	{
		unsigned int ar;
		s16 v13;

		ar = arg->ar;
		if ( ar >= 0x80 )
			ar = 127;
		v13 = 0;
		if ( ((attr_mask & SPU_VOICE_ADSR_AMODE) != 0) && arg->a_mode == SPU_VOICE_EXPIncN )
			v13 = 128;
		_spu_RXX[512 * _spu_core + 3 + v3] = (u8)_spu_RXX[512 * _spu_core + 3 + v3] | (u16)(((u16)ar | (u16)v13) << 8);
	}
	if ( (attr_mask & SPU_VOICE_ADSR_DR) != 0 )
	{
		unsigned int dr;

		dr = arg->dr;
		if ( dr >= 0x10 )
			dr = 15;
		_spu_RXX[512 * _spu_core + 3 + v3] = (_spu_RXX[512 * _spu_core + 3 + v3] & ~0xf0) | (16 * dr);
	}
	if ( (attr_mask & SPU_VOICE_ADSR_SR) != 0 )
	{
		unsigned int sr;
		s16 v16;

		sr = arg->sr;
		if ( sr >= 0x80 )
			sr = 127;
		v16 = 256;
		if ( (attr_mask & SPU_VOICE_ADSR_SMODE) != 0 )
		{
			switch ( arg->s_mode )
			{
				case SPU_VOICE_LINEARIncN:
					v16 = 0;
					break;
				case SPU_VOICE_EXPIncN:
					v16 = 512;
					break;
				case SPU_VOICE_EXPDec:
					v16 = 768;
					break;
				default:
					break;
			}
		}
		_spu_RXX[512 * _spu_core + 4 + v3] = (_spu_RXX[512 * _spu_core + 4 + v3] & 0x3F) | (((u16)sr | (u16)v16) << 6);
	}
	if ( (attr_mask & SPU_VOICE_ADSR_RR) != 0 )
	{
		unsigned int rr;
		s16 v19;

		rr = arg->rr;
		if ( rr >= 0x20 )
			rr = 31;
		v19 = 0;
		if ( (attr_mask & SPU_VOICE_ADSR_RMODE) != 0 )
		{
			if ( arg->r_mode == SPU_VOICE_EXPDec )
				v19 = 32;
		}
		_spu_RXX[512 * _spu_core + 4 + v3] = (_spu_RXX[512 * _spu_core + 4 + v3] & ~0x3f) | rr | v19;
	}
	if ( (attr_mask & SPU_VOICE_ADSR_SL) != 0 )
	{
		unsigned int sl;

		sl = arg->sl;
		if ( sl >= 0x10 )
			sl = 15;
		_spu_RXX[512 * _spu_core + 3 + v3] = (_spu_RXX[512 * _spu_core + 3 + v3] & ~0xF) | sl;
	}
	_spu_wait_SpuNSetVoiceAttr();
}

// libspu2/sl_sva.o

static void __attribute__((optimize("no-unroll-loops"))) _spu_wait_SpuLSetVoiceAttr(void)
{
	int i;
	int v1;

	v1 = 1;
	for ( i = 0; i < 2; i += 1 )
	{
		v1 *= 13;
		__asm__ __volatile__("" : "+g"(v1) : :);
	}
}

void SpuLSetVoiceAttr(int num, SpuLVoiceAttr *arg_list)
{
	int v3;
	unsigned int v9;
	int v10;
	s16 v11;
	int v12;
	int v13;
	s16 v14;
	int v15;
	unsigned int v16;
	s16 v17;
	unsigned int v18;
	unsigned int v19;
	s16 v20;
	unsigned int v22;
	s16 v23;
	unsigned int v25;

	for ( v3 = 0; v3 < num; v3 += 1 )
	{
		int attr_mask;
		int voiceNum;
		int v7;
		int v8;

		attr_mask = arg_list[v3].attr.mask;
		if ( attr_mask == 0 )
		{
			attr_mask = 0xFFFFFFFF;
		}
		voiceNum = arg_list[v3].voiceNum;
		v7 = 8 * voiceNum;
		v8 = 6 * voiceNum;
		if ( (attr_mask & SPU_VOICE_PITCH) != 0 )
			_spu_RXX[512 * _spu_core + 2 + v7] = arg_list[v3].attr.pitch;
		if ( (attr_mask & SPU_VOICE_SAMPLE_NOTE) != 0 )
			_spu_voice_centerNote[_spu_core][voiceNum] = arg_list[v3].attr.sample_note;
		if ( (attr_mask & SPU_VOICE_NOTE) != 0 )
		{
			v9 = (u16)_spu_voice_centerNote[_spu_core][voiceNum];
			_spu_RXX[512 * _spu_core + 2 + v7] =
				_spu_note2pitch(v9 >> 8, (u8)v9, ((arg_list[v3].attr.note >> 8)) & 0xFF, (u8)arg_list[v3].attr.note);
		}
		if ( (attr_mask & SPU_VOICE_VOLL) != 0 )
		{
			v10 = 0;
			v11 = arg_list[v3].attr.volume.left & ~0x8000;
			if ( (attr_mask & SPU_VOICE_VOLMODEL) != 0 )
			{
				switch ( arg_list[v3].attr.volmode.left )
				{
					case SPU_VOICE_LINEARIncN:
						v10 = 0x8000;
						break;
					case SPU_VOICE_LINEARIncR:
						v10 = 0x9000;
						break;
					case SPU_VOICE_LINEARDecN:
						v10 = 0xa000;
						break;
					case SPU_VOICE_LINEARDecR:
						v10 = 0xb000;
						break;
					case SPU_VOICE_EXPIncN:
						v10 = 0xc000;
						break;
					case SPU_VOICE_EXPIncR:
						v10 = 0xd000;
						break;
					case SPU_VOICE_EXPDec:
						v10 = 0xe000;
						break;
					default:
						break;
				}
			}
			if ( v10 )
			{
				v12 = (s16)arg_list[v3].attr.volume.left;
				if ( v12 < 128 )
				{
					if ( v12 < 0 )
						v11 = 0;
				}
				else
				{
					v11 = 127;
				}
			}
			_spu_RXX[512 * _spu_core + v7] = v11 | v10;
		}
		if ( (attr_mask & SPU_VOICE_VOLR) != 0 )
		{
			v13 = 0;
			v14 = arg_list[v3].attr.volume.right & ~0x8000;
			if ( (attr_mask & SPU_VOICE_VOLMODER) != 0 )
			{
				switch ( arg_list[v3].attr.volmode.right )
				{
					case SPU_VOICE_LINEARIncN:
						v13 = 0x8000;
						break;
					case SPU_VOICE_LINEARIncR:
						v13 = 0x9000;
						break;
					case SPU_VOICE_LINEARDecN:
						v13 = 0xa000;
						break;
					case SPU_VOICE_LINEARDecR:
						v13 = 0xb000;
						break;
					case SPU_VOICE_EXPIncN:
						v13 = 0xc000;
						break;
					case SPU_VOICE_EXPIncR:
						v13 = 0xd000;
						break;
					case SPU_VOICE_EXPDec:
						v13 = 0xe000;
						break;
					default:
						break;
				}
			}
			if ( v13 )
			{
				v15 = (s16)arg_list[v3].attr.volume.right;
				if ( v15 < 128 )
				{
					if ( v15 < 0 )
						v14 = 0;
				}
				else
				{
					v14 = 127;
				}
			}
			_spu_RXX[512 * _spu_core + 1 + v7] = v14 | v13;
		}
		if ( (attr_mask & SPU_VOICE_WDSA) != 0 )
			_spu_FsetRXX(v8 + 224, (arg_list[v3].attr.addr >> 4) << 4, 1);
		if ( (attr_mask & SPU_VOICE_LSAX) != 0 )
			_spu_FsetRXX(v8 + 226, (arg_list[v3].attr.loop_addr >> 4) << 4, 1);
		if ( (attr_mask & SPU_VOICE_ADSR_ADSR1) != 0 )
			_spu_RXX[512 * _spu_core + 3 + v7] = arg_list[v3].attr.adsr1;
		if ( (attr_mask & SPU_VOICE_ADSR_ADSR2) != 0 )
			_spu_RXX[512 * _spu_core + 4 + v7] = arg_list[v3].attr.adsr2;
		if ( (attr_mask & SPU_VOICE_ADSR_AR) != 0 )
		{
			v16 = arg_list[v3].attr.ar;
			if ( v16 >= 0x80 )
				v16 = 127;
			v17 = 0;
			if ( ((attr_mask & SPU_VOICE_ADSR_AMODE) != 0) && arg_list[v3].attr.a_mode == SPU_VOICE_EXPIncN )
				v17 = 128;
			_spu_RXX[512 * _spu_core + 3 + v7] = (u8)_spu_RXX[512 * _spu_core + 3 + v7] | (u16)(((u16)v16 | (u16)v17) << 8);
		}
		if ( (attr_mask & SPU_VOICE_ADSR_DR) != 0 )
		{
			v18 = arg_list[v3].attr.dr;
			if ( v18 >= 0x10 )
				v18 = 15;
			_spu_RXX[512 * _spu_core + 3 + v7] = (_spu_RXX[512 * _spu_core + 3 + v7] & ~0xf0) | (16 * v18);
		}
		if ( (attr_mask & SPU_VOICE_ADSR_SR) != 0 )
		{
			v19 = arg_list[v3].attr.sr;
			if ( v19 >= 0x80 )
				v19 = 127;
			v20 = 256;
			if ( (attr_mask & SPU_VOICE_ADSR_SMODE) != 0 )
			{
				switch ( arg_list[v3].attr.s_mode )
				{
					case SPU_VOICE_LINEARIncN:
						v20 = 0;
						break;
					case SPU_VOICE_EXPIncN:
						v20 = 512;
						break;
					case SPU_VOICE_EXPDec:
						v20 = 768;
						break;
					default:
						break;
				}
			}
			_spu_RXX[512 * _spu_core + 4 + v7] = (_spu_RXX[512 * _spu_core + 4 + v7] & 0x3F) | (((u16)v19 | (u16)v20) << 6);
		}
		if ( (attr_mask & SPU_VOICE_ADSR_RR) != 0 )
		{
			v22 = arg_list[v3].attr.rr;
			if ( v22 >= 0x20 )
				v22 = 31;
			v23 = 0;
			if ( (attr_mask & SPU_VOICE_ADSR_RMODE) != 0 )
			{
				if ( arg_list[v3].attr.r_mode == SPU_VOICE_EXPDec )
					v23 = 32;
			}
			_spu_RXX[512 * _spu_core + 4 + v7] = (_spu_RXX[512 * _spu_core + 4 + v7] & ~0x3f) | v22 | v23;
		}
		if ( (attr_mask & SPU_VOICE_ADSR_SL) != 0 )
		{
			v25 = arg_list[v3].attr.sl;
			if ( v25 >= 0x10 )
				v25 = 15;
			_spu_RXX[512 * _spu_core + 3 + v7] = (_spu_RXX[512 * _spu_core + 3 + v7] & ~0xF) | v25;
		}
	}
	_spu_wait_SpuLSetVoiceAttr();
}

// libspu2/s_gvv.o

void SpuGetVoiceVolume(int v_num, s16 *voll, s16 *volr)
{
	const vu16 *v3;
	u16 v4;
	u16 v5;

	v3 = &_spu_RXX[512 * _spu_core + 8 * (v_num & 0x1F)];
	v4 = v3[1];
	v5 = v3[0];
	if ( v5 < 0x4000 )
		*voll = v5;
	else
		*voll = v5 + 0x8000;
	if ( v4 < 0x4000u )
		*volr = v4;
	else
		*volr = v4 + 0x8000;
}

// libspu2/s_gvva.o

void SpuGetVoiceVolumeAttr(int v_num, s16 *voll, s16 *volr, s16 *voll_mode, s16 *volr_mode)
{
	const vu16 *v5;
	u16 v6;
	u16 v7;
	s16 v8;
	s16 v10;

	v5 = &_spu_RXX[512 * _spu_core + 8 * (v_num & 0x1F)];
	v6 = *v5;
	v7 = v5[1];
	v8 = 0;
	if ( (v6 & 0x8000) != 0 )
	{
		switch ( v6 & 0xF000 )
		{
			case 0x8000:
				v8 = SPU_VOICE_LINEARIncN;
				break;
			case 0x9000:
				v8 = SPU_VOICE_LINEARIncR;
				break;
			case 0xa000:
				v8 = SPU_VOICE_LINEARDecN;
				break;
			case 0xb000:
				v8 = SPU_VOICE_LINEARDecR;
				break;
			case 0xc000:
				v8 = SPU_VOICE_EXPIncN;
				break;
			case 0xd000:
				v8 = SPU_VOICE_EXPIncR;
				break;
			case 0xe000:
			case 0xf000:
				v8 = SPU_VOICE_EXPDec;
				break;
			default:
				break;
		}
		v6 &= ~0xF000;
	}
	v10 = 0;
	if ( (v7 & 0x8000) != 0 )
	{
		switch ( v7 & 0xF000 )
		{
			case 0x8000:
				v10 = SPU_VOICE_LINEARIncN;
				break;
			case 0x9000:
				v10 = SPU_VOICE_LINEARIncR;
				break;
			case 0xa000:
				v10 = SPU_VOICE_LINEARDecN;
				break;
			case 0xb000:
				v10 = SPU_VOICE_LINEARDecR;
				break;
			case 0xc000:
				v10 = SPU_VOICE_EXPIncN;
				break;
			case 0xd000:
				v10 = SPU_VOICE_EXPIncR;
				break;
			case 0xe000:
			case 0xf000:
				v10 = SPU_VOICE_EXPDec;
				break;
			default:
				break;
		}
		v7 &= ~0xF000;
	}
	*voll_mode = v8;
	*volr_mode = v10;
	if ( v6 < 0x4000u )
		*voll = v6;
	else
		*voll = v6 + 0x8000;
	if ( v7 < 0x4000u )
		*volr = v7;
	else
		*volr = v7 + 0x8000;
}

// libspu2/s_gvvx.o

void SpuGetVoiceVolumeX(int v_num, s16 *voll_x, s16 *volr_x)
{
	int v3;

	v3 = 8 * v_num;
	*voll_x = _spu_RXX[512 * _spu_core + 6 + v3];
	*volr_x = _spu_RXX[512 * _spu_core + 7 + v3];
}

// libspu2/s_gvp.o

void SpuGetVoicePitch(int v_num, u16 *pitch)
{
	*pitch = _spu_RXX[512 * _spu_core + 2 + 8 * (v_num & 0x1F)];
}

// libspu2/s_gvn.o

void SpuGetVoiceNote(int v_num, u16 *note)
{
	unsigned int v3;
	int v4;

	v3 = (u16)_spu_voice_centerNote[_spu_core][v_num];
	v4 = _spu_pitch2note(v3 >> 8, (u8)v3, _spu_RXX[512 * _spu_core + 2 + 8 * (v_num & 0x1F)]);
	if ( v4 < 0 )
		*note = 0;
	else
		*note = v4;
}

// libspu2/s_gvsn.o

void SpuGetVoiceSampleNote(int v_num, u16 *sample_note)
{
	*sample_note = _spu_voice_centerNote[_spu_core][v_num];
}

// libspu2/s_gvex.o

void SpuGetVoiceEnvelope(int v_num, s16 *envx)
{
	*envx = _spu_RXX[512 * _spu_core + 5 + 8 * (v_num & 0x1F)];
}

// libspu2/s_gvsa.o

void SpuGetVoiceStartAddr(int v_num, unsigned int *start_addr)
{
	*start_addr = _spu_MGFgetRXX2(6 * (v_num & 0x1F) + 224);
}

// libspu2/s_gvlsa.o

void SpuGetVoiceLoopStartAddr(int v_num, unsigned int *loop_start_addr)
{
	*loop_start_addr = _spu_MGFgetRXX2(6 * (v_num & 0x1F) + 226);
}

// libspu2/s_gvar.o

void SpuGetVoiceAR(int v_num, u16 *ar)
{
	*ar = ((_spu_RXX[512 * _spu_core + 3 + 8 * (v_num & 0x1F)]) >> 8) & 0x3F;
}

// libspu2/s_gvdr.o

void SpuGetVoiceDR(int v_num, u16 *dr)
{
	*dr = (_spu_RXX[512 * _spu_core + 3 + 8 * (v_num & 0x1F)] & 0xF0u) >> 4;
}

// libspu2/s_gvsr.o

void SpuGetVoiceSR(int v_num, u16 *sr)
{
	*sr = (_spu_RXX[512 * _spu_core + 4 + 8 * (v_num & 0x1F)] >> 6) & 0x7F;
}

// libspu2/s_gvrr.o

void SpuGetVoiceRR(int v_num, u16 *rr)
{
	*rr = _spu_RXX[512 * _spu_core + 4 + 8 * (v_num & 0x1F)] & 0x1F;
}

// libspu2/s_gvsl.o

void SpuGetVoiceSL(int v_num, u16 *sl)
{
	*sl = _spu_RXX[512 * _spu_core + 3 + 8 * (v_num & 0x1F)] & 0xF;
}

// libspu2/s_gvara.o

void SpuGetVoiceARAttr(int v_num, u16 *ar, int *ar_mode)
{
	u16 v3;

	v3 = _spu_RXX[512 * _spu_core + 3 + 8 * (v_num & 0x1F)];
	*ar = (v3 >> 8) & 0x3F;
	*ar_mode = SPU_VOICE_LINEARIncN;
	if ( (v3 & 0x8000) != 0 )
		*ar_mode = SPU_VOICE_EXPIncN;
}

// libspu2/s_gvsra.o

void SpuGetVoiceSRAttr(int v_num, u16 *sr, int *sr_mode)
{
	u16 v3;

	v3 = _spu_RXX[512 * _spu_core + 4 + 8 * (v_num & 0x1F)];
	*sr = (v3 >> 6) & 0x7F;
	switch ( v3 & 0xE000 )
	{
		case 0xc000:
			*sr_mode = SPU_VOICE_EXPDec;
			break;
		case 0x8000:
			*sr_mode = SPU_VOICE_EXPIncN;
			break;
		case 0x4000:
			*sr_mode = SPU_VOICE_LINEARDecN;
			break;
		default:
			*sr_mode = SPU_VOICE_LINEARIncN;
			break;
	}
}

// libspu2/s_gvrra.o

void SpuGetVoiceRRAttr(int v_num, u16 *rr, int *rr_mode)
{
	u16 v3;

	v3 = _spu_RXX[512 * _spu_core + 4 + 8 * (v_num & 0x1F)];
	*rr = v3 & 0x1F;
	*rr_mode = SPU_VOICE_LINEARDecN;
	if ( (v3 & 0x20) != 0 )
		*rr_mode = SPU_VOICE_EXPDec;
}

// libspu2/s_gvad.o

void SpuGetVoiceADSR(int v_num, u16 *ar, u16 *dr, u16 *sr, u16 *rr, u16 *sl)
{
	const vu16 *v6;
	u16 v7;
	unsigned int v8;

	v6 = &_spu_RXX[512 * _spu_core + 8 * (v_num & 0x1F)];
	v7 = v6[3];
	v8 = v6[4];
	*ar = (v7 >> 8) & 0x3F;
	*dr = (u8)(v7 & 0xF0) >> 4;
	*sr = (v8 >> 6) & 0x7F;
	*rr = v8 & 0x1F;
	*sl = v7 & 0xF;
}

// libspu2/s_gvada.o

void SpuGetVoiceADSRAttr(
	int v_num, u16 *ar, u16 *dr, u16 *sr, u16 *rr, u16 *sl, int *ar_mode, int *sr_mode, int *rr_mode)
{
	const vu16 *v9;
	u16 v10;
	unsigned int v11;

	v9 = &_spu_RXX[512 * _spu_core + 8 * (v_num & 0x1F)];
	v10 = v9[3];
	v11 = v9[4];
	*ar = (v10 >> 8) & 0x3F;
	*ar_mode = SPU_VOICE_LINEARIncN;
	if ( (v10 & 0x8000) != 0 )
		*ar_mode = SPU_VOICE_EXPIncN;
	*dr = (u8)(v10 & 0xF0) >> 4;
	*sr = (v11 >> 6) & 0x7F;
	switch ( v11 & 0xE000 )
	{
		case 0xc000:
			*sr_mode = SPU_VOICE_EXPDec;
			break;
		case 0x8000:
			*sr_mode = SPU_VOICE_EXPIncN;
			break;
		case 0x4000:
			*sr_mode = SPU_VOICE_LINEARDecN;
			break;
		default:
			*sr_mode = SPU_VOICE_LINEARIncN;
			break;
	}
	*rr = v11 & 0x1F;
	*rr_mode = SPU_VOICE_LINEARDecN;
	if ( (v11 & 0x20) != 0 )
		*rr_mode = SPU_VOICE_EXPDec;
	*sl = v10 & 0xF;
}

// libspu2/s_scmv.o

void SpuSetCommonMasterVolume(s16 mvol_left, s16 mvol_right)
{
	vu16 *v2;

	v2 = &_spu_RXX[20 * _spu_core];
	v2[944] = mvol_left & ~0x8000;
	v2[945] = mvol_right & ~0x8000;
}

// libspu2/s_scmva.o

void SpuSetCommonMasterVolumeAttr(s16 mvol_left, s16 mvol_right, s16 mvolmode_left, s16 mvolmode_right)
{
	s16 v4;
	s16 v5;
	int v6;
	int v7;

	v4 = mvol_left;
	v5 = mvol_right;
	v6 = 0;
	v7 = 0;
	switch ( mvolmode_left )
	{
		case SPU_VOICE_LINEARIncN:
			v6 = 0x8000;
			break;
		case SPU_VOICE_LINEARIncR:
			v6 = 0x9000;
			break;
		case SPU_VOICE_LINEARDecN:
			v6 = 0xa000;
			break;
		case SPU_VOICE_LINEARDecR:
			v6 = 0xb000;
			break;
		case SPU_VOICE_EXPIncN:
			v6 = 0xc000;
			break;
		case SPU_VOICE_EXPIncR:
			v6 = 0xd000;
			break;
		case SPU_VOICE_EXPDec:
			v6 = 0xe000;
			break;
		default:
			break;
	}
	if ( v6 )
	{
		v4 = 127;
		if ( mvol_left < 128 )
		{
			v4 = mvol_left;
			if ( mvol_left < 0 )
				v4 = 0;
		}
	}
	_spu_RXX[20 * _spu_core + 944] = (v4 & ~0x8000) | v6;
	switch ( mvolmode_right )
	{
		case SPU_VOICE_LINEARIncN:
			v7 = 0x8000;
			break;
		case SPU_VOICE_LINEARIncR:
			v7 = 0x9000;
			break;
		case SPU_VOICE_LINEARDecN:
			v7 = 0xa000;
			break;
		case SPU_VOICE_LINEARDecR:
			v7 = 0xb000;
			break;
		case SPU_VOICE_EXPIncN:
			v7 = 0xc000;
			break;
		case SPU_VOICE_EXPIncR:
			v7 = 0xd000;
			break;
		case SPU_VOICE_EXPDec:
			v7 = 0xe000;
			break;
		default:
			break;
	}
	if ( v7 )
	{
		v5 = 127;
		if ( mvol_right < 128 )
		{
			v5 = mvol_right;
			if ( mvol_right < 0 )
				v5 = 0;
		}
	}
	_spu_RXX[20 * _spu_core + 945] = (v5 & ~0x8000) | v7;
}

// libspu2/s_sccv.o

void SpuSetCommonCDVolume(s16 cd_left, s16 cd_right)
{
	vu16 *v2;

	v2 = &_spu_RXX[20 * _spu_core];
	v2[968] = cd_left;
	v2[969] = cd_right;
}

// libspu2/s_sccr.o

void SpuSetCommonCDReverb(int cd_reverb)
{
	vu16 *v1;
	u16 v2;

	v1 = &_spu_RXX[512 * _spu_core];
	if ( cd_reverb )
		v2 = v1[205] | 4;
	else
		v2 = v1[205] & ~4;
	v1[205] = v2;
}

// libspu2/s_sccm.o

void SpuSetCommonCDMix(int cd_mix)
{
	vu16 *v1;
	u16 v2;

	v1 = &_spu_RXX[512 * _spu_core];
	if ( cd_mix )
		v2 = v1[205] | 1;
	else
		v2 = v1[205] & ~1;
	v1[205] = v2;
}

// libspu2/s_gcmv.o

void SpuGetCommonMasterVolume(s16 *mvol_left, s16 *mvol_right)
{
	const vu16 *v2;
	u16 v3;
	u16 v4;

	v2 = &_spu_RXX[20 * _spu_core];
	v3 = v2[944];
	v4 = v2[945];
	if ( (v3 & 0x8000) != 0 )
		v3 &= ~0xF000;
	if ( (v2[945] & 0x8000) != 0 )
		v4 &= ~0xF000;
	if ( v3 < 0x4000u )
		*mvol_left = v3;
	else
		*mvol_left = v3 + 0x8000;
	if ( v4 < 0x4000u )
		*mvol_right = v4;
	else
		*mvol_right = v4 + 0x8000;
}

// libspu2/s_gcmvx.o

void SpuGetCommonMasterVolumeX(s16 *mvolx_left, s16 *mvolx_right)
{
	*mvolx_left = _spu_RXX[20 * _spu_core + 972];
	*mvolx_right = _spu_RXX[20 * _spu_core + 973];
}

// libspu2/s_gcmva.o

void SpuGetCommonMasterVolumeAttr(s16 *mvol_left, s16 *mvol_right, s16 *mvolmode_left, s16 *mvolmode_right)
{
	s16 v4;
	const vu16 *v5;
	u16 v6;
	u16 v7;
	s16 v8;

	v4 = 0;
	v5 = &_spu_RXX[20 * _spu_core];
	v6 = v5[944];
	v7 = v5[945];
	v8 = 0;
	if ( (v6 & 0x8000) != 0 )
	{
		switch ( v6 & 0xF000 )
		{
			case 0x8000:
				v4 = SPU_VOICE_LINEARIncN;
				break;
			case 0x9000:
				v4 = SPU_VOICE_LINEARIncR;
				break;
			case 0xa000:
				v4 = SPU_VOICE_LINEARDecN;
				break;
			case 0xb000:
				v4 = SPU_VOICE_LINEARDecR;
				break;
			case 0xc000:
				v4 = SPU_VOICE_EXPIncN;
				break;
			case 0xd000:
				v4 = SPU_VOICE_EXPIncR;
				break;
			case 0xe000:
			case 0xf000:
				v4 = SPU_VOICE_EXPDec;
				break;
			default:
				break;
		}
		v6 &= ~0xF000;
	}
	v8 = 0;
	if ( (v7 & 0x8000) != 0 )
	{
		switch ( v7 & 0xF000 )
		{
			case 0x8000:
				v8 = SPU_VOICE_LINEARIncN;
				break;
			case 0x9000:
				v8 = SPU_VOICE_LINEARIncR;
				break;
			case 0xa000:
				v8 = SPU_VOICE_LINEARDecN;
				break;
			case 0xb000:
				v8 = SPU_VOICE_LINEARDecR;
				break;
			case 0xc000:
				v8 = SPU_VOICE_EXPIncN;
				break;
			case 0xd000:
				v8 = SPU_VOICE_EXPIncR;
				break;
			case 0xe000:
			case 0xf000:
				v8 = SPU_VOICE_EXPDec;
				break;
			default:
				break;
		}
		v7 &= ~0xF000;
	}
	*mvolmode_left = v4;
	*mvolmode_right = v8;
	if ( v6 < 0x4000u )
		*mvol_left = v6;
	else
		*mvol_left = v6 + 0x8000;
	if ( v7 < 0x4000u )
		*mvol_right = v7;
	else
		*mvol_right = v7 + 0x8000;
}

// libspu2/s_gccv.o

void SpuGetCommonCDVolume(s16 *cd_left, s16 *cd_right)
{
	*cd_left = _spu_RXX[20 * _spu_core + 968];
	*cd_right = _spu_RXX[20 * _spu_core + 969];
}

// libspu2/s_gccr.o

void SpuGetCommonCDReverb(int *cd_reverb)
{
	*cd_reverb = SPU_OFF;
	if ( (_spu_RXX[512 * _spu_core + 205] & 4) != 0 )
		*cd_reverb = SPU_ON;
}

// libspu2/s_gccm.o

void SpuGetCommonCDMix(int *cd_mix)
{
	*cd_mix = SPU_OFF;
	if ( (_spu_RXX[512 * _spu_core + 205] & 1) != 0 )
		*cd_mix = SPU_ON;
}

// libspu2/s_srmt.o

int SpuSetReverbModeType(int mode)
{
	unsigned int v1;
	int v2;
	vu16 *v4;
	int v5;
	vu16 *v6;
	libspu2_reverb_param_entry_t v7;

	v1 = mode;
	v2 = 0;
	if ( (mode & SPU_REV_MODE_CLEAR_WA) != 0 )
	{
		v1 = mode & ~SPU_REV_MODE_CLEAR_WA;
		v2 = 1;
	}
	if ( v1 >= SPU_REV_MODE_MAX )
	{
		return -1;
	}
	_spu_rev_attr.mode = v1;
	_spu_rev_offsetaddr = SpuGetReverbEndAddr() - (8 * _spu_rev_workareasize[v1] - 2);
	memcpy(&v7, &_spu_rev_param[v1], 0x44u);
	v7.flags = 0;
	switch ( v1 )
	{
		case SPU_REV_MODE_ECHO:
			_spu_rev_attr.feedback = 127;
			_spu_rev_attr.delay = 127;
			break;
		case SPU_REV_MODE_DELAY:
			_spu_rev_attr.feedback = 0;
			_spu_rev_attr.delay = 127;
			break;
		default:
			_spu_rev_attr.feedback = 0;
			_spu_rev_attr.delay = 0;
			break;
	}
	v4 = &_spu_RXX[512 * _spu_core];
	v5 = (v4[205] >> 7) & 1;
	if ( v5 )
		v4[205] &= ~0x80u;
	v6 = &_spu_RXX[20 * _spu_core];
	v6[946] = 0;
	v6[947] = 0;
	_spu_rev_attr.depth.left = 0;
	_spu_rev_attr.depth.right = 0;
	_spu_setReverbAttr(&v7);
	if ( v2 )
		SpuClearReverbWorkArea(v1);
	_spu_FsetRXX(368, _spu_rev_offsetaddr, 1);
	if ( v5 )
	{
		_spu_RXX[512 * _spu_core + 205] |= 0x80u;
	}
	return 0;
}

// libspu2/s_srmd.o

void SpuSetReverbModeDepth(s16 depth_left, s16 depth_right)
{
	vu16 *v2;

	v2 = &_spu_RXX[20 * _spu_core];
	v2[946] = depth_left;
	v2[947] = depth_right;
	_spu_rev_attr.depth.left = depth_left;
	_spu_rev_attr.depth.right = depth_right;
}

// libspu2/s_srmdt.o

void SpuSetReverbModeDelayTime(int delay)
{
	libspu2_reverb_param_entry_t v3;

	switch ( _spu_rev_attr.mode )
	{
		case SPU_REV_MODE_DELAY:
		case SPU_REV_MODE_ECHO:
		{
			int v2;

			memcpy(&v3, &_spu_rev_param[_spu_rev_attr.mode], 0x44u);
			v3.flags = 0xc011c00;
			_spu_rev_attr.delay = delay;
			v3.mLSAME = (s16)((u16)delay << 13) / 127 - v3.dAPF1;
			v2 = (delay << 12) / 127;
			v3.mRSAME = v2 - v3.dAPF2;
			v3.dLSAME = v3.dRSAME + v2;
			v3.mLCOMB1 = v3.mRCOMB1 + v2;
			v3.mRAPF1 = v3.mRAPF2 + v2;
			v3.mLAPF1 = v3.mLAPF2 + v2;
			_spu_setReverbAttr(&v3);
			break;
		}
		default:
			break;
	}
}

// libspu2/s_srmfb.o

void SpuSetReverbModeFeedback(int feedback)
{
	libspu2_reverb_param_entry_t v2;

	switch ( _spu_rev_attr.mode )
	{
		case SPU_REV_MODE_DELAY:
		case SPU_REV_MODE_ECHO:
		{
			memcpy(&v2, &_spu_rev_param[_spu_rev_attr.mode], 0x44u);
			v2.flags = 128;
			_spu_rev_attr.feedback = feedback;
			v2.vWALL = 33024 * feedback / 127;
			_spu_setReverbAttr(&v2);
			break;
		}
		default:
			break;
	}
}

// libspu2/s_grmt.o

void SpuGetReverbModeType(int *mode)
{
	*mode = _spu_rev_attr.mode;
}

// libspu2/s_grmd.o

void SpuGetReverbModeDepth(s16 *depth_left, s16 *depth_right)
{
	*depth_left = _spu_rev_attr.depth.left;
	*depth_right = _spu_rev_attr.depth.right;
}

// libspu2/s_grmdt.o

void SpuGetReverbModeDelayTime(int *delay)
{
	*delay = _spu_rev_attr.delay;
}

// libspu2/s_grmfb.o

void SpuGetReverbModeFeedback(int *feedback)
{
	*feedback = _spu_rev_attr.feedback;
}

// libspu2/s_gva.o

void SpuGetVoiceAttr(SpuVoiceAttr *arg)
{
	int v2;
	int v3;
	int v6;
	const vu16 *v7;
	u16 v8;
	u16 v9;
	s16 v10;
	s16 v12;
	const vu16 *v16;
	const vu16 *v21;

	v2 = -1;
	for ( v3 = 0; v3 < 24; v3 += 1 )
	{
		if ( (arg->voice & (1 << v3)) != 0 )
		{
			v2 = v3;
			break;
		}
	}
	v6 = 8 * v2;
	if ( v2 != -1 )
	{
		int v17;
		unsigned int v22;
		unsigned int v23;
		int v24;
		int v26;
		int v27;

		v7 = &_spu_RXX[512 * _spu_core + v6];
		v8 = *v7;
		v9 = v7[1];
		v10 = 0;
		if ( (v8 & 0x8000) != 0 )
		{
			switch ( v8 & 0xF000 )
			{
				case 0x8000:
					v10 = SPU_VOICE_LINEARIncN;
					break;
				case 0x9000:
					v10 = SPU_VOICE_LINEARIncR;
					break;
				case 0xa000:
					v10 = SPU_VOICE_LINEARDecN;
					break;
				case 0xb000:
					v10 = SPU_VOICE_LINEARDecR;
					break;
				case 0xc000:
					v10 = SPU_VOICE_EXPIncN;
					break;
				case 0xd000:
					v10 = SPU_VOICE_EXPIncR;
					break;
				case 0xe000:
				case 0xf000:
					v10 = SPU_VOICE_EXPDec;
					break;
				default:
					break;
			}
			v8 &= ~0xF000;
		}
		v12 = 0;
		if ( (v9 & 0x8000) != 0 )
		{
			switch ( v9 & 0xF000 )
			{
				case 0x8000:
					v12 = SPU_VOICE_LINEARIncN;
					break;
				case 0x9000:
					v12 = SPU_VOICE_LINEARIncR;
					break;
				case 0xa000:
					v12 = SPU_VOICE_LINEARDecN;
					break;
				case 0xb000:
					v12 = SPU_VOICE_LINEARDecR;
					break;
				case 0xc000:
					v12 = SPU_VOICE_EXPIncN;
					break;
				case 0xd000:
					v12 = SPU_VOICE_EXPIncR;
					break;
				case 0xe000:
				case 0xf000:
					v12 = SPU_VOICE_EXPDec;
					break;
				default:
					break;
			}
			v9 &= ~0xF000;
		}
		if ( v8 < 0x4000u )
			arg->volume.left = v8;
		else
			arg->volume.left = v8 + 0x8000;
		if ( v9 < 0x4000u )
			arg->volume.right = v9;
		else
			arg->volume.right = v9 + 0x8000;
		arg->volmode.left = v10;
		arg->volmode.right = v12;
		v16 = &_spu_RXX[512 * _spu_core + v6];
		arg->volumex.left = v16[6];
		arg->volumex.right = v16[7];
		arg->pitch = v16[2];
		v17 = _spu_pitch2note(
			(_spu_voice_centerNote[_spu_core][v2] >> 8) & 0xFF, (u8)_spu_voice_centerNote[_spu_core][v2], arg->pitch);
		if ( v17 < 0 )
			arg->note = 0;
		else
			arg->note = v17;
		arg->sample_note = _spu_voice_centerNote[_spu_core][v2];
		arg->envx = _spu_RXX[512 * _spu_core + v6 + 5];
		arg->addr = _spu_MGFgetRXX2(224);
		arg->loop_addr = _spu_MGFgetRXX2(226);
		v21 = &_spu_RXX[512 * _spu_core + v6];
		v22 = v21[3];
		v23 = v21[4];
		v24 = SPU_VOICE_EXPIncN;
		if ( (v22 & 0x8000) == 0 )
			v24 = SPU_VOICE_LINEARIncN;
		arg->a_mode = v24;
		switch ( v23 & 0xE000 )
		{
			case 0xc000:
				v26 = SPU_VOICE_EXPDec;
				break;
			case 0x8000:
				v26 = SPU_VOICE_EXPIncN;
				break;
			case 0x4000:
				v26 = SPU_VOICE_LINEARDecN;
				break;
			default:
				v26 = SPU_VOICE_LINEARIncN;
				break;
		}
		arg->s_mode = v26;
		v27 = SPU_VOICE_EXPDec;
		if ( (v23 & 0x20) == 0 )
			v27 = SPU_VOICE_LINEARDecN;
		arg->r_mode = v27;
		arg->ar = (v22 >> 8) & 0x3F;
		arg->dr = (u8)(v22 & 0xF0) >> 4;
		arg->sr = (v23 >> 6) & 0x7F;
		arg->rr = v23 & 0x1F;
		arg->sl = v22 & 0xF;
		arg->adsr1 = v22;
		arg->adsr2 = v23;
	}
}

// libspu2/sn_gva.o

void SpuNGetVoiceAttr(int v_num, SpuVoiceAttr *arg)
{
	s16 v3;
	int v4;
	const vu16 *v5;
	u16 v6;
	u16 v7;
	s16 v10;
	const vu16 *v14;
	int v15;
	const vu16 *v19;
	unsigned int v20;
	unsigned int v21;
	int v22;
	int v24;
	int v25;

	v3 = 0;
	v4 = 8 * v_num;
	v5 = &_spu_RXX[512 * _spu_core + 8 * v_num];
	v6 = *v5;
	v7 = v5[1];
	if ( (v6 & 0x8000) != 0 )
	{
		switch ( v6 & 0xF000 )
		{
			case 0x8000:
				v3 = SPU_VOICE_LINEARIncN;
				break;
			case 0x9000:
				v3 = SPU_VOICE_LINEARIncR;
				break;
			case 0xa000:
				v3 = SPU_VOICE_LINEARDecN;
				break;
			case 0xb000:
				v3 = SPU_VOICE_LINEARDecR;
				break;
			case 0xc000:
				v3 = SPU_VOICE_EXPIncN;
				break;
			case 0xd000:
				v3 = SPU_VOICE_EXPIncR;
				break;
			case 0xe000:
			case 0xf000:
				v3 = SPU_VOICE_EXPDec;
				break;
			default:
				break;
		}
		v6 &= ~0xF000;
	}
	v10 = 0;
	if ( (v7 & 0x8000) != 0 )
	{
		switch ( v7 & 0xF000 )
		{
			case 0x8000:
				v10 = SPU_VOICE_LINEARIncN;
				break;
			case 0x9000:
				v10 = SPU_VOICE_LINEARIncR;
				break;
			case 0xa000:
				v10 = SPU_VOICE_LINEARDecN;
				break;
			case 0xb000:
				v10 = SPU_VOICE_LINEARDecR;
				break;
			case 0xc000:
				v10 = SPU_VOICE_EXPIncN;
				break;
			case 0xd000:
				v10 = SPU_VOICE_EXPIncR;
				break;
			case 0xe000:
			case 0xf000:
				v10 = SPU_VOICE_EXPDec;
				break;
			default:
				break;
		}
		v7 &= ~0xF000;
	}
	if ( v6 < 0x4000u )
		arg->volume.left = v6;
	else
		arg->volume.left = v6 + 0x8000;
	if ( v7 < 0x4000u )
		arg->volume.right = v7;
	else
		arg->volume.right = v7 + 0x8000;
	arg->volmode.left = v3;
	arg->volmode.right = v10;
	v14 = &_spu_RXX[512 * _spu_core + v4];
	arg->volumex.left = v14[6];
	arg->volumex.right = v14[7];
	arg->pitch = v14[2];
	v15 = _spu_pitch2note(
		(_spu_voice_centerNote[_spu_core][v_num] >> 8) & 0xFF, (u8)_spu_voice_centerNote[_spu_core][v_num], arg->pitch);
	if ( v15 < 0 )
		arg->note = 0;
	else
		arg->note = v15;
	arg->sample_note = _spu_voice_centerNote[_spu_core][v_num];
	arg->envx = _spu_RXX[512 * _spu_core + v4 + 5];
	arg->addr = _spu_MGFgetRXX2(224);
	arg->loop_addr = _spu_MGFgetRXX2(226);
	v19 = &_spu_RXX[512 * _spu_core + v4];
	v20 = v19[3];
	v21 = v19[4];
	v22 = SPU_VOICE_EXPIncN;
	if ( (v20 & 0x8000) == 0 )
		v22 = SPU_VOICE_LINEARIncN;
	arg->a_mode = v22;
	switch ( v21 & 0xE000 )
	{
		case 0xc000:
			v24 = SPU_VOICE_EXPDec;
			break;
		case 0x8000:
			v24 = SPU_VOICE_EXPIncN;
			break;
		case 0x4000:
			v24 = SPU_VOICE_LINEARDecN;
			break;
		default:
			v24 = SPU_VOICE_LINEARIncN;
			break;
	}
	arg->s_mode = v24;
	v25 = SPU_VOICE_EXPDec;
	if ( (v21 & 0x20) == 0 )
		v25 = SPU_VOICE_LINEARDecN;
	arg->r_mode = v25;
	arg->ar = (v20 >> 8) & 0x3F;
	arg->dr = (u8)(v20 & 0xF0) >> 4;
	arg->sr = (v21 >> 6) & 0x7F;
	arg->rr = v21 & 0x1F;
	arg->sl = v20 & 0xF;
	arg->adsr1 = v20;
	arg->adsr2 = v21;
}

// libspu2/s_sesa.o

void SpuSetESA(int rev_addr)
{
	_spu_FsetRXX(0xBF801DA2, rev_addr >> 3, 0);
}

// libspu2/s_sada.o

void SpuSetAutoDMAAttr(s16 vol_l, s16 vol_r, s16 dry_on, s16 effect_on)
{
	*((vu16 *)0xBF90076C) = vol_l;
	*((vu16 *)0xBF90076E) = vol_r;
	switch ( dry_on )
	{
		case SPU_ON:
			*((vu16 *)0xBF900198) = *((vu16 *)0xBF900198) | 0xC0;
			break;
		case SPU_OFF:
		default:
			*((vu16 *)0xBF900198) = *((vu16 *)0xBF900198) & ~0xc0;
			break;
	}
	switch ( effect_on )
	{
		case SPU_ON:
			*((vu16 *)0xBF900198) |= 0x30u;
			break;
		case SPU_OFF:
		default:
			*((vu16 *)0xBF900198) &= ~0x30;
			break;
	}
}

void SpuSetSerialInAttr(s16 dry_on, s16 effect_on)
{
	switch ( dry_on )
	{
		case SPU_ON:
			*((vu16 *)0xBF900598) = *((vu16 *)0xBF900598) | 0xC;
			break;
		case SPU_OFF:
		default:
			*((vu16 *)0xBF900598) = *((vu16 *)0xBF900598) & ~0xC;
			break;
	}
	switch ( effect_on )
	{
		case SPU_ON:
			*((vu16 *)0xBF900598) |= 3u;
			break;
		case SPU_OFF:
		default:
			*((vu16 *)0xBF900598) &= ~3;
			break;
	}
}

// libsnd2/ccadsr.o

void _SsUtResolveADSR(u16 adsr1, u16 adsr2, u16 *adsr_buf)
{
	adsr_buf[5] = adsr1 & 0x8000;
	adsr_buf[6] = adsr2 & 0x8000;
	adsr_buf[8] = adsr2 & 0x4000;
	adsr_buf[7] = adsr2 & 0x20;
	*adsr_buf = (adsr1 >> 8) & 0x7F;
	adsr_buf[1] = (u8)adsr1 >> 4;
	adsr_buf[2] = adsr1 & 0xF;
	adsr_buf[3] = (adsr2 >> 6) & 0x7F;
	adsr_buf[4] = adsr2 & 0x1F;
}

void _SsUtBuildADSR(const u16 *adsr_buf, u16 *adsr1, u16 *adsr2)
{
	unsigned int v5;
	s16 v6;
	unsigned int v7;
	u16 v8;

	v5 = adsr_buf[6] != 0 ? 0xFFFF8000 : 0;
	v6 = v5;
	v7 = adsr_buf[5] != 0 ? 0xFFFF8000 : 0;
	if ( adsr_buf[8] )
		v6 = v5 | 0x4000;
	if ( adsr_buf[7] )
		v6 |= 0x20u;
	v8 = v6 | ((adsr_buf[3] << 6) & 0x1FC0) | (adsr_buf[4] & 0x1F);
	*adsr1 = v7 | ((*adsr_buf << 8) & 0x7F00) | ((16 * adsr_buf[1]) & 0xF0) | (adsr_buf[2] & 0xF);
	*adsr2 = v8;
}

// libsnd2/cc_0.o

void _SsContBankChange(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;

	(void)control_value;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_vab_id = *score_struct->m_seq_ptr;
	score_struct->m_seq_ptr += 1;
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/cc_6.o

void _SsContDataEntry(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;
	int m_channel_idx;
	ProgAtr prog_attr;
	VagAtr old_vag_attr;

	score_struct = &_ss_score[sep_no][seq_no];
	m_channel_idx = score_struct->m_channel_idx;
	SsUtGetProgAtr((char)score_struct->m_vab_id, (u8)score_struct->m_programs[m_channel_idx], &prog_attr);
	if ( score_struct->m_unk1C == 1 )
	{
		if ( !score_struct->m_unk15 )
		{
			score_struct->m_unk1D = control_value;
			score_struct->m_unk1C = 0;
			score_struct->m_unk15 = 1;
			score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
			return;
		}
	}
	if ( score_struct->m_unk1E == 2 )
	{
		int tone_idx_cur;

		for ( tone_idx_cur = 0; tone_idx_cur < prog_attr.tones; tone_idx_cur += 1 )
		{
			SsUtGetVagAtr(
				(char)score_struct->m_vab_id, (u8)score_struct->m_programs[m_channel_idx], tone_idx_cur, &old_vag_attr);
			if ( (u8)score_struct->m_unk18 == 0 )
			{
				old_vag_attr.pbmax = control_value & 0x7F;
				old_vag_attr.pbmin = control_value & 0x7F;
			}
			SsUtSetVagAtr(
				(char)score_struct->m_vab_id, (u8)score_struct->m_programs[m_channel_idx], tone_idx_cur, &old_vag_attr);
		}
		if ( score_struct->m_unk19 )
		{
			score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
			score_struct->m_unk1E = 0;
			return;
		}
	}
	if ( score_struct->m_unk1F != 2 )
	{
		score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
		return;
	}
	if ( score_struct->m_unk1B == 16 )
		SsFCALL.ccentry[(u8)score_struct->m_fn_idx](
			(char)score_struct->m_vab_id,
			(u8)score_struct->m_programs[m_channel_idx],
			0,
			old_vag_attr,
			score_struct->m_fn_idx,
			control_value);
	else
		SsFCALL.ccentry[(u8)score_struct->m_fn_idx](
			(char)score_struct->m_vab_id,
			(u8)score_struct->m_programs[m_channel_idx],
			score_struct->m_unk1B,
			old_vag_attr,
			score_struct->m_fn_idx,
			control_value);
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
	score_struct->m_unk1F = 0;
}

// libsnd2/cc_7.o

void _SsContMainVol(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;
	int m_channel_idx;

	score_struct = &_ss_score[sep_no][seq_no];
	m_channel_idx = score_struct->m_channel_idx;
	_SsVmSetVol(
		sep_no | (seq_no << 8),
		(char)score_struct->m_vab_id,
		(u8)score_struct->m_programs[m_channel_idx],
		control_value,
		(u8)score_struct->m_panpot[m_channel_idx]);
	score_struct->m_vol[m_channel_idx] = control_value;
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/cc_10.o

void _SsContPanpot(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;
	int m_channel_idx;

	score_struct = &_ss_score[sep_no][seq_no];
	m_channel_idx = score_struct->m_channel_idx;
	_SsVmSetVol(
		sep_no | (seq_no << 8),
		(char)score_struct->m_vab_id,
		(u8)score_struct->m_programs[m_channel_idx],
		score_struct->m_vol[m_channel_idx],
		control_value);
	score_struct->m_panpot[m_channel_idx] = control_value;
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/cc_11.o

void _SsContExpression(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;
	int m_channel_idx;

	score_struct = &_ss_score[sep_no][seq_no];
	m_channel_idx = score_struct->m_channel_idx;
	_SsVmSetProgVol((char)score_struct->m_vab_id, (u8)score_struct->m_programs[m_channel_idx], control_value);
	_SsVmSetVol(
		sep_no | (seq_no << 8),
		(char)score_struct->m_vab_id,
		(u8)score_struct->m_programs[m_channel_idx],
		score_struct->m_vol[m_channel_idx],
		(u8)score_struct->m_panpot[m_channel_idx]);
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/cc_64.o

void _SsContDamper(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	if ( control_value >= 0x40u )
		_SsVmDamperOn();
	else
		_SsVmDamperOff();
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/cc_91.o

void _SsContExternal(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	SsUtSetReverbDepth(control_value, control_value);
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/cc_98.o

void _SsContNrpn1(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;
	int m_unk1B;

	score_struct = &_ss_score[sep_no][seq_no];
	m_unk1B = score_struct->m_unk1B;
	if ( m_unk1B == 40 )
	{
		libsnd2_ss_mark_callback_proc pFunc;

		pFunc = _SsMarkCallback[sep_no].m_entries[seq_no];
		if ( pFunc )
			pFunc(sep_no, seq_no, control_value);
		m_unk1B = score_struct->m_unk1B;
	}
	if ( !(m_unk1B == 30 || m_unk1B == 20) && (m_unk1B != 40) )
	{
		score_struct->m_fn_idx = control_value;
		score_struct->m_unk1C = 0;
		score_struct->m_unk1F += 1;
	}
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/cc_99.o

void _SsContNrpn2(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	if ( control_value == 20 )
	{
		score_struct->m_unk1B = control_value;
		score_struct->m_unk1C = 1;
		score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
		score_struct->m_unk08 = score_struct->m_seq_ptr;
		return;
	}
	if ( control_value != 30 )
	{
		score_struct->m_unk1B = control_value;
		score_struct->m_unk1F += 1;
		score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
		return;
	}
	score_struct->m_unk1B = control_value;
	if ( score_struct->m_unk1D == 0 )
	{
		score_struct->m_unk15 = 0;
		score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
		return;
	}
	if ( score_struct->m_unk1D >= 0x7Fu )
	{
		_SsReadDeltaValue(sep_no, seq_no);
		score_struct->m_delta_value = 0;
		score_struct->m_seq_ptr = score_struct->m_unk08;
	}
	else
	{
		score_struct->m_unk1D -= 1;
		score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
		if ( score_struct->m_unk1D )
			score_struct->m_seq_ptr = score_struct->m_unk08;
		else
			score_struct->m_unk15 = 0;
	}
}

// libsnd2/cc_100.o

void _SsContRpn1(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_unk18 = control_value;
	score_struct->m_unk1E += 1;
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/cc_101.o

void _SsContRpn2(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_unk19 = control_value;
	score_struct->m_unk1E += 1;
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/cc_121.o

void _SsContResetAll(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;

	(void)control_value;

	score_struct = &_ss_score[sep_no][seq_no];
	SsUtReverbOff();
	_SsVmDamperOff();
	score_struct->m_programs[score_struct->m_channel_idx] = score_struct->m_channel_idx;
	score_struct->m_unk18 = 0;
	score_struct->m_unk19 = 0;
	score_struct->m_vol[score_struct->m_channel_idx] = 127;
	score_struct->m_panpot[score_struct->m_channel_idx] = 64;
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/de_0.o

void _SsSetNrpnVabAttr0(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	vag_attr.prior = attribute_value;
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_1.o

void _SsSetNrpnVabAttr1(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	vag_attr.mode = attribute_value;
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
	switch ( attribute_value )
	{
		case 0:
			SsUtReverbOff();
			break;
		case 4:
			SsUtReverbOn();
			break;
		default:
			break;
	}
}

// libsnd2/de_2.o

void _SsSetNrpnVabAttr2(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	vag_attr.min = attribute_value;
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_3.o

void _SsSetNrpnVabAttr3(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	vag_attr.max = attribute_value;
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_4.o

void _SsSetNrpnVabAttr4(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	_SsUtResolveADSR(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
	resolved_adsr[5] = 0;
	resolved_adsr[0] = attribute_value;
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_5.o

void _SsSetNrpnVabAttr5(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	_SsUtResolveADSR(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
	resolved_adsr[5] = 1;
	resolved_adsr[0] = attribute_value;
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_6.o

void _SsSetNrpnVabAttr6(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	_SsUtResolveADSR(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
	resolved_adsr[1] = attribute_value;
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_7.o

void _SsSetNrpnVabAttr7(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	_SsUtResolveADSR(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
	resolved_adsr[2] = attribute_value;
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_8.o

void _SsSetNrpnVabAttr8(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	_SsUtResolveADSR(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
	resolved_adsr[6] = 0;
	resolved_adsr[3] = attribute_value;
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_9.o

void _SsSetNrpnVabAttr9(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	_SsUtResolveADSR(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
	resolved_adsr[6] = 1;
	resolved_adsr[3] = attribute_value;
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_10.o

void _SsSetNrpnVabAttr10(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	_SsUtResolveADSR(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
	resolved_adsr[7] = 0;
	resolved_adsr[4] = attribute_value;
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_11.o

void _SsSetNrpnVabAttr11(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	memset(&resolved_adsr, 0, sizeof(resolved_adsr));
	resolved_adsr[7] = 1;
	resolved_adsr[4] = attribute_value;
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_12.o

void _SsSetNrpnVabAttr12(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	memset(&resolved_adsr, 0, sizeof(resolved_adsr));
	if ( (u8)(attribute_value - 1) >= 0x3Fu )
	{
		if ( (u8)(attribute_value - 64) < 0x40u )
			resolved_adsr[8] = 1;
	}
	else
	{
		resolved_adsr[8] = 0;
	}
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_13.o

void _SsSetNrpnVabAttr13(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	vag_attr.vibT = attribute_value;
	memset(&resolved_adsr, 0, sizeof(resolved_adsr));
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_14.o

void _SsSetNrpnVabAttr14(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	u16 resolved_adsr[12];

	(void)fn_idx;

	SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
	vag_attr.porW = attribute_value;
	memset(&resolved_adsr, 0, sizeof(resolved_adsr));
	_SsUtBuildADSR(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
	SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// libsnd2/de_15.o

void _SsSetNrpnVabAttr15(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	SsUtSetReverbType(attribute_value);
}

// libsnd2/de_16.o

void _SsSetNrpnVabAttr16(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	SsUtSetReverbDepth(attribute_value, attribute_value);
}

// libsnd2/de_17.o

void _SsSetNrpnVabAttr17(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	SsUtSetReverbFeedback(attribute_value);
}

// libsnd2/de_18.o

void _SsSetNrpnVabAttr18(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	SsUtSetReverbDelay(attribute_value);
}

// libsnd2/de_19.o

void _SsSetNrpnVabAttr19(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	SsUtSetReverbDelay(attribute_value);
}

// libsnd2/cres.o

void _SsSndCrescendo(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_unkA0 += 1;
	if ( score_struct->m_unk9C >= score_struct->m_unkA0 )
	{
		int mulfield_tmp;
		int new_field_4a;
		int vol_inc_by;

		mulfield_tmp = score_struct->m_unk48 * score_struct->m_unkA0;
		new_field_4a = mulfield_tmp / score_struct->m_unk9C;
		if ( score_struct->m_unk9C == -1 && (unsigned int)mulfield_tmp == 0x80000000 )
			__builtin_trap();
		vol_inc_by = new_field_4a - score_struct->m_unk4A;
		if ( new_field_4a != score_struct->m_unk4A )
		{
			int voll_clamped;
			int volr_clamped;
			s16 seq_left_vol;
			s16 seq_right_vol;

			score_struct->m_unk4A = new_field_4a;
			_SsVmGetSeqVol(sep_no | (seq_no << 8), &seq_left_vol, &seq_right_vol);
			voll_clamped = (u16)seq_left_vol + vol_inc_by;
			if ( voll_clamped >= 128 )
				voll_clamped = 127;
			if ( voll_clamped < 0 )
				voll_clamped = 0;
			volr_clamped = (u16)seq_right_vol + vol_inc_by;
			if ( volr_clamped >= 128 )
				volr_clamped = 127;
			if ( volr_clamped < 0 )
				volr_clamped = 0;
			_SsVmSetSeqVol(sep_no | (seq_no << 8), voll_clamped, volr_clamped);
			if ( (voll_clamped == 127 && volr_clamped == 127) || (voll_clamped == 0 && volr_clamped == 0) )
			{
				score_struct->m_flags &= ~0x10u;
			}
		}
	}
	else
	{
		score_struct->m_flags &= ~0x10u;
	}
	_SsVmGetSeqVol(sep_no | (seq_no << 8), &score_struct->m_unk5C, &score_struct->m_unk5E);
}

// libsnd2/midibend.o

void _SsSetPitchBend(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;
	u8 midi_byte;

	score_struct = &_ss_score[sep_no][seq_no];
	midi_byte = *score_struct->m_seq_ptr;
	score_struct->m_seq_ptr += 1;
	_SsVmPitchBend(
		sep_no | (seq_no << 8),
		(char)score_struct->m_vab_id,
		(u8)score_struct->m_programs[score_struct->m_channel_idx],
		midi_byte);
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/midicc.o

void _SsSetControlChange(s16 sep_no, s16 seq_no, u8 control_value)
{
	libsnd2_sequence_struct_t *score_struct;
	u8 control_value_tmp;

	score_struct = &_ss_score[sep_no][seq_no];
	control_value_tmp = *score_struct->m_seq_ptr;
	score_struct->m_seq_ptr += 1;
	switch ( control_value )
	{
		case 0:
		{
			score_struct->m_vab_id = control_value_tmp;
			break;
		}
		case 6:
		{
			SsFCALL.control[CC_DATAENTRY](sep_no, seq_no, control_value_tmp);
			return;
		}
		case 7:
		{
			SsFCALL.control[CC_MAINVOL](sep_no, seq_no, control_value_tmp);
			return;
		}
		case 10:
		{
			SsFCALL.control[CC_PANPOT](sep_no, seq_no, control_value_tmp);
			return;
		}
		case 11:
		{
			SsFCALL.control[CC_EXPRESSION](sep_no, seq_no, control_value_tmp);
			return;
		}
		case 64:
		{
			SsFCALL.control[CC_DAMPER](sep_no, seq_no, control_value_tmp);
			return;
		}
		case 91:
		{
			SsFCALL.control[CC_EXTERNAL](sep_no, seq_no, control_value_tmp);
			return;
		}
		case 98:
		{
			SsFCALL.control[CC_NRPN1](sep_no, seq_no, control_value_tmp);
			return;
		}
		case 99:
		{
			SsFCALL.control[CC_NRPN2](sep_no, seq_no, control_value_tmp);
			return;
		}
		case 100:
		{
			SsFCALL.control[CC_RPN1](sep_no, seq_no, control_value_tmp);
			return;
		}
		case 101:
		{
			SsFCALL.control[CC_RPN2](sep_no, seq_no, control_value_tmp);
			return;
		}
		case 121:
		{
			SsFCALL.control[CC_RESETALL](sep_no, seq_no, control_value_tmp);
			return;
		}
		default:
		{
			break;
		}
	}
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/midimeta.o

void _SsGetMetaEvent(s16 sep_no, s16 seq_no, u8 meta_event)
{
	libsnd2_sequence_struct_t *score_struct;
	u8 v4;
	u8 v6;
	int v7;
	unsigned int v8;
	int v9;
	int v10;
	unsigned int v11;

	(void)meta_event;

	score_struct = &_ss_score[sep_no][seq_no];
	v4 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	v6 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	v7 = 60000000 / ((v4 << 16) | (v6 << 8) | *(score_struct->m_seq_ptr));
	score_struct->m_seq_ptr += 1;
	v8 = score_struct->m_resolution_of_quarter_note * v7;
	v9 = VBLANK_MINUS;
	v10 = 16 * VBLANK_MINUS;
	score_struct->m_unk94 = v7;
	v11 = 4 * (v10 - v9);
	if ( 10 * v8 < v11 )
	{
		unsigned int v13;

		if ( !v8 )
			__builtin_trap();
		v13 = 600 * v9 / v8;
		score_struct->m_unk52 = v13;
		score_struct->m_unk54 = v13;
	}
	else
	{
		unsigned int v15;
		unsigned int v16;

		v15 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_unk94 / v11;
		v16 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_unk94 % v11;
		score_struct->m_unk52 = -1;
		score_struct->m_unk54 = v15;
		if ( (unsigned int)(2 * (v10 - v9)) < v16 )
		{
			score_struct->m_unk54 = v15 + 1;
		}
	}
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/midinote.o

void _SsNoteOn(s16 sep_no, s16 seq_no, u8 note, u8 vollr)
{
	libsnd2_sequence_struct_t *score_struct;
	int m_channel_idx;

	score_struct = &_ss_score[sep_no][seq_no];
	m_channel_idx = score_struct->m_channel_idx;
	if ( vollr == 0 )
	{
		_SsVmKeyOff(
			sep_no | (u16)(seq_no << 8), (char)score_struct->m_vab_id, (u8)score_struct->m_programs[m_channel_idx], note);
	}
	else if ( ((score_struct->m_channel_mute >> m_channel_idx) & 1) == 0 )
		_SsVmKeyOn(
			sep_no | (u16)(seq_no << 8),
			(char)score_struct->m_vab_id,
			(u8)score_struct->m_programs[m_channel_idx],
			note,
			vollr,
			(u8)score_struct->m_panpot[m_channel_idx]);
}

// libsnd2/midiprog.o

void _SsSetProgramChange(s16 sep_no, s16 seq_no, u8 prog)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_programs[score_struct->m_channel_idx] = prog;
	score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
}

// libsnd2/midiread.o

void _SsSeqPlay(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;
	int m_unk54;
	int m_delta_value;
	int diff1;

	score_struct = &_ss_score[sep_no][seq_no];
	m_unk54 = score_struct->m_unk54;
	m_delta_value = score_struct->m_delta_value;
	diff1 = m_delta_value - m_unk54;
	if ( diff1 <= 0 )
	{
		int v10;
		int v11;
		int v15;

		v11 = score_struct->m_delta_value;
		if ( m_unk54 < m_delta_value )
			return;
		do
		{
			int v14;

			do
			{
				_SsGetSeqData(sep_no, seq_no);
				v14 = score_struct->m_delta_value;
			} while ( !v14 );
			v15 = score_struct->m_unk54;
			v11 += v14;
			v10 = v11 - v15;
		} while ( v11 < v15 );
		score_struct->m_delta_value = v10;
	}
	else
	{
		if ( score_struct->m_unk52 > 0 )
		{
			score_struct->m_unk52 -= 1;
			return;
		}
		if ( score_struct->m_unk52 )
		{
			score_struct->m_delta_value = diff1;
			return;
		}
		score_struct->m_unk52 = score_struct->m_unk54;
		score_struct->m_delta_value -= 1;
	}
}

void _SsSeqGetEof(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;
	int m_l_count;
	u8 *m_unk04;

	score_struct = &_ss_score[sep_no][seq_no];
	m_l_count = score_struct->m_l_count;
	score_struct->m_unk21 += 1;
	if ( m_l_count != SSPLAY_INFINITY )
	{
		if ( score_struct->m_unk21 >= m_l_count )
		{
			score_struct->m_flags &= ~1u;
			score_struct->m_flags &= ~8u;
			score_struct->m_flags &= ~2u;
			score_struct->m_flags |= 0x200u;
			score_struct->m_flags |= 4u;
			score_struct->m_play_mode = SSPLAY_PAUSE;
			if ( (score_struct->m_flags & 0x400) != 0 )
				score_struct->m_unk08 = score_struct->m_unk0C;
			else
				score_struct->m_unk08 = score_struct->m_unk04;
			if ( score_struct->m_next_sep != -1 )
			{
				score_struct->m_play_mode = SSPLAY_PAUSE;
				_SsSndNextSep(score_struct->m_next_sep, score_struct->m_next_seq);
				_SsVmSeqKeyOff(sep_no | (seq_no << 8));
			}
			_SsVmSeqKeyOff(sep_no | (seq_no << 8));
			score_struct->m_delta_value = score_struct->m_unk54;
		}
		else
		{
			score_struct->m_unk88 = 0;
			score_struct->m_unk1C = 0;
			score_struct->m_delta_value = 0;
			if ( (score_struct->m_flags & 0x400) != 0 )
				m_unk04 = score_struct->m_unk0C;
			else
				m_unk04 = score_struct->m_unk04;
			score_struct->m_seq_ptr = m_unk04;
			score_struct->m_unk08 = m_unk04;
		}
	}
	else
	{
		score_struct->m_unk88 = 0;
		score_struct->m_unk1C = 0;
		score_struct->m_delta_value = 0;
		if ( (score_struct->m_flags & 0x400) != 0 )
			score_struct->m_seq_ptr = score_struct->m_unk0C;
		else
			score_struct->m_seq_ptr = score_struct->m_unk04;
	}
}

int _SsGetSeqData(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;
	u8 midi_byte;
	u8 midi_byte_1;
	u8 midi_byte_2;

	score_struct = &_ss_score[sep_no][seq_no];
	midi_byte = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	if ( (score_struct->m_flags & 0x401) == 0x401 )
	{
		if ( score_struct->m_seq_ptr == score_struct->m_unk10 + 1 )
		{
			_SsSeqGetEof(sep_no, seq_no);
			return -1;
		}
	}
	if ( (midi_byte & 0x80) != 0 )
	{
		score_struct->m_channel_idx = midi_byte & 0xF;
		switch ( midi_byte & 0xF0 )
		{
			case 0x90:
			{
				u8 midi_byte_next_1;

				score_struct->m_running_status = 0x90;
				midi_byte_next_1 = *(score_struct->m_seq_ptr);
				score_struct->m_seq_ptr += 1;
				midi_byte_1 = *(score_struct->m_seq_ptr);
				score_struct->m_seq_ptr += 1;
				score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
				SsFCALL.noteon(sep_no, seq_no, midi_byte_next_1, midi_byte_1);
				break;
			}
			case 0xB0:
				score_struct->m_running_status = 0xB0;
				score_struct->m_seq_ptr += 1;
				SsFCALL.control[CC_NUMBER](sep_no, seq_no, midi_byte);
				break;
			case 0xC0:
				score_struct->m_running_status = 0xC0;
				score_struct->m_seq_ptr += 1;
				SsFCALL.programchange(sep_no, seq_no, midi_byte);
				break;
			case 0xE0:
				score_struct->m_running_status = 0xE0;
				score_struct->m_seq_ptr += 1;
				SsFCALL.pitchbend(sep_no, seq_no);
				break;
			case 0xF0:
				score_struct->m_running_status = -1;
				midi_byte_2 = *(score_struct->m_seq_ptr);
				score_struct->m_seq_ptr += 1;
				if ( midi_byte_2 == 0x2F )
				{
					_SsSeqGetEof(sep_no, seq_no);
					return 1;
				}
				SsFCALL.metaevent(sep_no, seq_no, midi_byte);
				break;
			default:
				break;
		}
	}
	else
	{
		switch ( score_struct->m_running_status )
		{
			case 0x90:
			{
				u8 midi_byte_3;

				midi_byte_3 = *(score_struct->m_seq_ptr);
				score_struct->m_seq_ptr += 1;
				score_struct->m_delta_value = _SsReadDeltaValue(sep_no, seq_no);
				SsFCALL.noteon(sep_no, seq_no, midi_byte, midi_byte_3);
				break;
			}
			case 0xB0:
				SsFCALL.control[CC_NUMBER](sep_no, seq_no, midi_byte);
				break;
			case 0xC0:
				SsFCALL.programchange(sep_no, seq_no, midi_byte);
				break;
			case 0xE0:
				SsFCALL.pitchbend(sep_no, seq_no);
				break;
			case 0xFF:
				if ( midi_byte == 0x2F )
				{
					_SsSeqGetEof(sep_no, seq_no);
					return 1;
				}
				SsFCALL.metaevent(sep_no, seq_no, midi_byte);
				break;
			default:
				break;
		}
	}
	return 0;
}

// libsnd2/miditime.o

s32 _SsReadDeltaValue(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;
	int delta_value;
	s32 result;
	int dv_mul4;

	score_struct = &_ss_score[sep_no][seq_no];
	delta_value = *score_struct->m_seq_ptr;
	score_struct->m_seq_ptr += 1;
	if ( !delta_value )
		return 0;
	if ( (delta_value & 0x80) != 0 )
	{
		char next_byte;

		delta_value &= ~0x80;
		do
		{
			next_byte = *score_struct->m_seq_ptr;
			score_struct->m_seq_ptr += 1;
			delta_value = (delta_value << 7) + (next_byte & 0x7F);
		} while ( (next_byte & 0x80) != 0 );
	}
	dv_mul4 = 4 * delta_value;
	result = 2 * (dv_mul4 + delta_value);
	score_struct->m_unk88 += result;
	return result;
}

// libsnd2/next.o

void _SsSndNextSep(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_l_count = 1;
	score_struct->m_unk21 = 0;
	score_struct->m_flags &= ~0x100u;
	score_struct->m_flags &= ~8u;
	score_struct->m_flags &= ~2u;
	score_struct->m_flags &= ~4u;
	score_struct->m_flags &= ~0x200u;
	score_struct->m_play_mode = SSPLAY_PLAY;
	score_struct->m_seq_ptr = score_struct->m_unk04;
	score_struct->m_flags |= 1u;
}

// libsnd2/npause.o

void _SsSndNextPause(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_play_mode = SSPLAY_PAUSE;
	score_struct->m_flags &= ~0x100u;
}

// libsnd2/pause.o

void _SsSndPause(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	_SsVmSeqKeyOff(sep_no | (seq_no << 8));
	score_struct->m_play_mode = SSPLAY_PAUSE;
	score_struct->m_flags &= ~2u;
}

// libsnd2/play.o

void _SsSndPlay(s16 sep_no, s16 seq_no)
{
	_SsSeqPlay(sep_no, seq_no);
}

// libsnd2/replay.o

void _SsSndReplay(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_play_mode = SSPLAY_PLAY;
	score_struct->m_flags &= ~8u;
}

// libsnd2/sepinit.o

int _SsInitSoundSep(s16 sep_no, int seq_no, u8 vab_id, u8 *addr)
{
	int v5;
	int v6;
	libsnd2_sequence_struct_t *score_struct;
	u8 v13;
	u8 v15;
	u8 v16;
	u8 v17;
	int tempo;
	char v20;
	char v21;
	int v22;
	u8 v23;
	u8 v24;
	u8 v25;
	s32 delta_value;
	int v27;
	unsigned int v28;
	int tmp1;
	unsigned int tmp2;
	int v33;

	v5 = 0;
	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_l_count = 1;
	score_struct->m_unk15 = 0;
	score_struct->m_running_status = 0;
	score_struct->m_channel_idx = 0;
	score_struct->m_unk18 = 0;
	score_struct->m_unk19 = 0;
	score_struct->m_fn_idx = 0;
	score_struct->m_unk1B = 0;
	score_struct->m_unk1C = 0;
	score_struct->m_unk1D = 0;
	score_struct->m_unk1E = 0;
	score_struct->m_unk1F = 0;
	score_struct->m_play_mode = SSPLAY_PAUSE;
	score_struct->m_unk21 = 0;
	score_struct->m_unk52 = 1;
	score_struct->m_resolution_of_quarter_note = 0;
	score_struct->m_vab_id = vab_id;
	score_struct->m_unk56 = 0;
	score_struct->m_unk84 = 0;
	score_struct->m_unk88 = 0;
	score_struct->m_tempo = 0;
	score_struct->m_delta_value = 0;
	score_struct->m_channel_mute = 0;
	score_struct->m_rhythm_n = 0;
	score_struct->m_rhythm_d = 0;
	for ( v6 = 0; v6 < 16; v6 += 1 )
	{
		score_struct->m_panpot[v6] = 64;
		score_struct->m_programs[v6] = v6;
		score_struct->m_vol[v6] = 127;
	}
	score_struct->m_seq_ptr = addr;
	if ( (seq_no & 0xFFFF) != 0 )
	{
		score_struct->m_seq_ptr += 2;
		v5 = 2;
	}
	else
	{
		int v10;

		v10 = *addr;
		if ( v10 == 0x53 || v10 == 0x70 )
		{
			int v11;

			score_struct->m_seq_ptr += 5;
			v11 = *(score_struct->m_seq_ptr);
			score_struct->m_seq_ptr += 1;
			if ( v11 )
			{
				printf("This is not SEP Data.\n");
				return -1;
			}
			score_struct->m_seq_ptr += 2;
			v5 = 8;
		}
	}
	v13 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	v15 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	score_struct->m_resolution_of_quarter_note = v15 | (v13 << 8);
	v16 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	v17 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	tempo = 60000000 / ((v16 << 16) | (v17 << 8) | *(score_struct->m_seq_ptr));
	score_struct->m_seq_ptr += 1;
	score_struct->m_tempo = tempo;
	score_struct->m_unk94 = score_struct->m_tempo;
	v20 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	score_struct->m_rhythm_n = v20;
	v21 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	score_struct->m_rhythm_d = v21;
	v22 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	v23 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	v24 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	v25 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	v27 = (v22 << 24) + (v23 << 16) + (v24 << 8) + v25;
	delta_value = _SsReadDeltaValue(sep_no, seq_no);
	v28 = score_struct->m_resolution_of_quarter_note * score_struct->m_tempo;
	score_struct->m_unk84 = delta_value;
	score_struct->m_delta_value = delta_value;
	score_struct->m_unk10 = 0;
	score_struct->m_unk08 = score_struct->m_seq_ptr;
	score_struct->m_unk04 = score_struct->m_seq_ptr;
	score_struct->m_unk0C = score_struct->m_seq_ptr;
	tmp1 = VBLANK_MINUS;
	tmp2 = 60 * tmp1;
	v33 = v5 + 11;
	if ( 10 * v28 < (unsigned int)(60 * tmp1) )
	{
		unsigned int v34;

		if ( !v28 )
			__builtin_trap();
		v34 = 600 * tmp1 / v28;
		score_struct->m_unk52 = v34;
		score_struct->m_unk54 = v34;
	}
	else
	{
		unsigned int v36;
		unsigned int v37;

		v36 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_tempo / tmp2;
		v37 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_tempo % tmp2;
		score_struct->m_unk52 = -1;
		score_struct->m_unk54 = v36;
		if ( (unsigned int)(30 * tmp1) < v37 )
		{
			score_struct->m_unk54 = v36 + 1;
		}
	}
	score_struct->m_unk56 = score_struct->m_unk54;
	return v33 + v27;
}

// libsnd2/seqinit.o

s16 _SsInitSoundSeq(s16 seq_no, s16 vab_id, u8 *addr)
{
	int v4;
	libsnd2_sequence_struct_t *score_struct;
	int v8;
	u8 v9;
	u8 v11;
	u8 v12;
	u8 v13;
	u8 v14;
	int tempo;
	int delta_value;
	unsigned int v20;
	int tmp1;
	unsigned int tmp2;

	score_struct = &_ss_score[seq_no][0];
	score_struct->m_vab_id = vab_id;
	score_struct->m_resolution_of_quarter_note = 0;
	score_struct->m_unk18 = 0;
	score_struct->m_unk19 = 0;
	score_struct->m_unk1E = 0;
	score_struct->m_fn_idx = 0;
	score_struct->m_unk1B = 0;
	score_struct->m_unk1F = 0;
	score_struct->m_channel_idx = 0;
	score_struct->m_unk84 = 0;
	score_struct->m_unk88 = 0;
	score_struct->m_tempo = 0;
	score_struct->m_unk56 = 0;
	score_struct->m_l_count = 1;
	score_struct->m_unk21 = 0;
	score_struct->m_play_mode = SSPLAY_PAUSE;
	score_struct->m_delta_value = 0;
	score_struct->m_unk1C = 0;
	score_struct->m_unk1D = 0;
	score_struct->m_unk15 = 0;
	score_struct->m_running_status = 0;
	score_struct->m_channel_mute = 0;
	score_struct->m_rhythm_n = 0;
	score_struct->m_rhythm_d = 0;
	for ( v4 = 0; v4 < 16; v4 += 1 )
	{
		score_struct->m_programs[v4] = v4;
		score_struct->m_panpot[v4] = 64;
		score_struct->m_vol[v4] = 127;
	}
	score_struct->m_unk52 = 1;
	score_struct->m_seq_ptr = addr;
	v8 = *addr;
	score_struct->m_seq_ptr += 7;
	if ( v8 != 83 && v8 != 112 )
	{
		printf("This is an old SEQ Data Format.\n");
		return 0;
	}
	v9 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	if ( v9 != 1 )
	{
		printf("This is not SEQ Data.\n");
		return -1;
	}
	v11 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	v12 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	score_struct->m_resolution_of_quarter_note = v12 | (v11 << 8);
	v13 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	v14 = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	tempo = 60000000 / ((v13 << 16) | (v14 << 8) | *(score_struct->m_seq_ptr));
	score_struct->m_seq_ptr += 1;
	score_struct->m_tempo = tempo;
	score_struct->m_unk94 = score_struct->m_tempo;
	score_struct->m_rhythm_n = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	score_struct->m_rhythm_d = *(score_struct->m_seq_ptr);
	score_struct->m_seq_ptr += 1;
	delta_value = _SsReadDeltaValue(seq_no, 0);
	v20 = score_struct->m_resolution_of_quarter_note * score_struct->m_tempo;
	score_struct->m_unk84 = delta_value;
	score_struct->m_delta_value = delta_value;
	score_struct->m_unk10 = 0;
	score_struct->m_unk08 = score_struct->m_seq_ptr;
	score_struct->m_unk04 = score_struct->m_seq_ptr;
	score_struct->m_unk0C = score_struct->m_seq_ptr;
	tmp1 = VBLANK_MINUS;
	tmp2 = 60 * tmp1;
	if ( 10 * v20 < (unsigned int)(60 * tmp1) )
	{
		unsigned int v25;

		if ( !v20 )
			__builtin_trap();
		v25 = 600 * tmp1 / v20;
		score_struct->m_unk52 = v25;
		score_struct->m_unk54 = v25;
	}
	else
	{
		unsigned int v27;
		unsigned int v28;

		v27 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_tempo / tmp2;
		v28 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_tempo % tmp2;
		score_struct->m_unk52 = -1;
		score_struct->m_unk54 = v27;
		if ( (unsigned int)(30 * tmp1) < v28 )
		{
			score_struct->m_unk54 = v27 + 1;
		}
	}
	score_struct->m_unk56 = score_struct->m_unk54;
	return 0;
}

// libsnd2/ssaccele.o

void _SsSndSetAccele(s16 sep_no, s16 seq_no, int tempo, int v_time)
{
	libsnd2_sequence_struct_t *score_struct;
	unsigned int m_flags;

	score_struct = &_ss_score[sep_no][seq_no];
	m_flags = score_struct->m_flags;
	if ( (m_flags & 1) != 0 && (m_flags & 2) == 0 )
	{
		int m_unk94;

		m_unk94 = score_struct->m_unk94;
		if ( tempo != m_unk94 )
		{
			score_struct->m_unkA8 = v_time;
			score_struct->m_unkA4 = v_time;
			score_struct->m_unkAC = tempo;
			if (
				((tempo - m_unk94 >= 0) && (tempo - m_unk94 < v_time))
				|| ((tempo - m_unk94 < 0) && (m_unk94 - tempo < v_time)) )
			{
				int v9;
				int m_unkA8;
				int v11;
				int v13;

				v9 = score_struct->m_unk94;
				m_unkA8 = score_struct->m_unkA8;
				v11 = tempo - v9;
				v13 = v9 - tempo;
				if ( v11 < 0 )
				{
					if ( v13 == -1 && (unsigned int)m_unkA8 == 0x80000000 )
						__builtin_trap();
					score_struct->m_unk4E = m_unkA8 / v13;
				}
				else if ( v11 > 0 )
				{
					score_struct->m_unk4E = m_unkA8 / v11;
				}
				else
				{
					__builtin_trap();
				}
			}
			else
			{
				int v14;
				int v15;
				int v16;

				v14 = score_struct->m_unk94;
				v15 = score_struct->m_unkA8;
				v16 = tempo - v14;
				if ( tempo - v14 < 0 )
					v16 = v14 - tempo;
				if ( v15 == -1 && (unsigned int)v16 == 0x80000000 )
					__builtin_trap();
				score_struct->m_unk4E = ~(u16)(v16 / v15);
			}
			score_struct->m_flags |= 0x40u;
			score_struct->m_flags &= ~0x80u;
		}
	}
}

void SsSeqSetAccelerando(s16 seq_no, int tempo, int v_time)
{
	_SsSndSetAccele(seq_no, 0, tempo, v_time);
}

void SsSepSetAccelerando(s16 seq_no, s16 sep_no, int tempo, int v_time)
{
	_SsSndSetAccele(seq_no, sep_no, tempo, v_time);
}

// libsnd2/sscall.o

void SsSeqCalledTbyT(void)
{
	if ( _snd_ev_flag != 1 )
	{
		int sep_no;

		_snd_ev_flag = 1;

		_SsVmFlush();
		for ( sep_no = 0; sep_no < _snd_seq_s_max; sep_no += 1 )
		{
			if ( (_snd_openflag & (1 << sep_no)) != 0 )
			{
				int seq_no;

				for ( seq_no = 0; seq_no < _snd_seq_t_max; seq_no += 1 )
				{
					libsnd2_sequence_struct_t *score_struct;

					score_struct = &_ss_score[sep_no][seq_no];
					if ( (score_struct->m_flags & 1) != 0 )
					{
						_SsSndPlay(sep_no, seq_no);
						if ( (score_struct->m_flags & 0x10) != 0 )
						{
							_SsSndCrescendo(sep_no, seq_no);
#ifdef LIB_1300
							printf("--- _SsSndCrescendo ---\n");
#endif
						}
						if ( (score_struct->m_flags & 0x20) != 0 )
						{
							_SsSndCrescendo(sep_no, seq_no);
#ifdef LIB_1300
							printf("--- _SsSndCrescendo(DE) ---\n");
#endif
						}
						if ( (score_struct->m_flags & 0x40) != 0 )
						{
							_SsSndTempo(sep_no, seq_no);
#ifdef LIB_1300
							printf("--- _SsSndTempo(ACE) ---\n");
#endif
						}
						if ( (score_struct->m_flags & 0x80) != 0 )
						{
							_SsSndTempo(sep_no, seq_no);
#ifdef LIB_1300
							printf("--- _SsSndTempo(RIT) ---\n");
#endif
						}
					}
					if ( (score_struct->m_flags & 2) != 0 )
					{
						_SsSndPause(sep_no, seq_no);
#ifdef LIB_1300
						printf("--- _SsSndPause ---\n");
#endif
					}
					if ( (score_struct->m_flags & 8) != 0 )
					{
						_SsSndReplay(sep_no, seq_no);
#ifdef LIB_1300
						printf("--- _SsSndReplay ---\n");
#endif
					}
					if ( (score_struct->m_flags & 4) != 0 )
					{
						_SsSndStop(sep_no, seq_no);
						score_struct->m_flags = 0;
#ifdef LIB_1300
						printf("--- _SsSndStop ---\n");
#endif
					}
				}
			}
		}
		_snd_ev_flag = 0;
	}
}

// libsnd2/ssclose.o

static void _SsClose(s16 seq_sep_no)
{
	int sep_no;
	int seq_no;

	_SsVmSetSeqVol(seq_sep_no, 0, 0);
	_SsVmSeqKeyOff(seq_sep_no);
	_snd_openflag &= ~(1 << seq_sep_no);
	sep_no = seq_sep_no;
	for ( seq_no = 0; seq_no < _snd_seq_t_max; seq_no += 1 )
	{
		libsnd2_sequence_struct_t *score_struct;

		score_struct = &_ss_score[sep_no][seq_no];
		score_struct->m_flags = 0;
		score_struct->m_next_sep = 255;
		score_struct->m_next_seq = 0;
		score_struct->m_unk48 = 0;
		score_struct->m_unk4A = 0;
		score_struct->m_unk9C = 0;
		score_struct->m_unkA0 = 0;
		score_struct->m_unk4C = 0;
		score_struct->m_unkAC = 0;
		score_struct->m_unkA8 = 0;
		score_struct->m_unkA4 = 0;
		score_struct->m_unk4E = 0;
		score_struct->m_voll = 127;
		score_struct->m_volr = 127;
	}
}

void SsSeqClose(s16 seq_sep_no)
{
	_SsClose(seq_sep_no);
}

void SsSepClose(s16 seq_sep_no)
{
	_SsClose(seq_sep_no);
}

// libsnd2/sscmute.o

void SsChannelMute(s16 sep_no, s16 seq_no, int channels)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_channel_mute = channels;
}

int SsGetChannelMute(s16 sep_no, s16 seq_no)
{
	const libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	return score_struct->m_channel_mute;
}

// libsnd2/sscres.o

void _SsSndSetCres(s16 sep_no, s16 seq_no, s16 vol, int v_time)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	_SsSndSetVolData(sep_no, seq_no, vol, v_time);
	score_struct->m_flags |= 0x10u;
	score_struct->m_flags &= ~0x20u;
}

void SsSeqSetCrescendo(s16 sep_no, s16 vol, int v_time)
{
	_SsSndSetCres(sep_no, 0, vol, v_time);
}

void SsSepSetCrescendo(s16 sep_no, s16 seq_no, s16 vol, int v_time)
{
	_SsSndSetCres(sep_no, seq_no, vol, v_time);
}

// libsnd2/ssdecres.o

void _SsSndSetDecres(s16 sep_no, s16 seq_no, s16 vol, int v_time)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	_SsSndSetVolData(sep_no, seq_no, -vol, v_time);
	score_struct->m_flags |= 0x20u;
	score_struct->m_flags &= ~0x10u;
}

void SsSeqSetDecrescendo(s16 sep_no, s16 vol, int v_time)
{
	_SsSndSetDecres(sep_no, 0, vol, v_time);
}

void SsSepSetDecrescendo(s16 sep_no, s16 seq_no, s16 vol, int v_time)
{
	_SsSndSetDecres(sep_no, seq_no, vol, v_time);
}

// libsnd2/ssend.o

void SsEnd(void)
{
#ifndef LIB_1300
	if ( !_snd_seq_tick_env.m_manual_tick )
	{
		_snd_seq_tick_env.m_unk11 = 0;
		if ( _snd_seq_tick_env.m_alarm_tick != 127 )
		{
			CpuDisableIntr();
			if ( _snd_seq_tick_env.m_vsync_tick )
			{
				ReleaseVblankHandler(0, _SsTrapIntrProcIOP);
				_snd_seq_tick_env.m_vsync_tick = 0;
			}
			else if ( _snd_seq_tick_env.m_alarm_tick )
			{
				CancelAlarm((unsigned int (*)(void *))_SsTrapIntrProcIOP, &_snd_seq_interval);
			}
			else
			{
				ReleaseVblankHandler(0, _SsTrapIntrProcIOP);
				_snd_seq_tick_env.m_vsync_callback = 0;
			}
			CpuEnableIntr();
			_snd_seq_tick_env.m_alarm_tick = 127;
		}
	}
#endif
}

// libsnd2/ssgm.o

char SsGetMute(void)
{
	return SpuGetMute() != SPU_OFF;
}

// libsnd2/ssgmv.o

void SsGetMVol(SndVolume *m_vol)
{
	SpuCommonAttr spu_attr;

	SpuGetCommonAttr(&spu_attr);
	m_vol->left = spu_attr.mvol.left / 129;
	m_vol->right = spu_attr.mvol.right / 129;
}

// libsnd2/ssgnc.o

s16 SsGetNck(void)
{
	return SpuGetNoiseClock();
}

// libsnd2/ssgrv.o

void SsGetRVol(SndVolume *r_vol)
{
	SpuReverbAttr reverb_attr;

	SpuGetReverbModeParam(&reverb_attr);
	r_vol->left = (s16)(127 * reverb_attr.depth.left) / 0x7FFF;
	r_vol->right = 127 * reverb_attr.depth.right / 0x7FFF;
}

// libsnd2/ssgsattr.o

char SsGetSerialAttr(char s_num, char attr)
{
	SpuCommonAttr spu_attr;

	SpuGetCommonAttr(&spu_attr);
	switch ( s_num )
	{
		case SS_SERIAL_A:
			switch ( attr )
			{
				case SS_MIX:
					return spu_attr.cd.mix;
				case SS_REV:
					return spu_attr.cd.reverb;
				default:
					break;
			}
			break;
		case SS_SERIAL_B:
			switch ( attr )
			{
				case SS_MIX:
					return spu_attr.ext.mix;
				case SS_REV:
					return spu_attr.ext.reverb;
				default:
					break;
			}
			break;
		default:
			break;
	}
	return -1;
}

// libsnd2/ssgsv.o

void SsGetSerialVol(char s_num, SndVolume *s_vol)
{
	SpuCommonAttr spu_attr;

	SpuGetCommonAttr(&spu_attr);
	switch ( s_num )
	{
		case SS_SERIAL_A:
			s_vol->left = spu_attr.cd.volume.left / 258;
			s_vol->right = (u16)spu_attr.cd.volume.right / 258;
			break;
		case SS_SERIAL_B:
			s_vol->left = spu_attr.ext.volume.left / 258;
			s_vol->right = (u16)spu_attr.ext.volume.right / 258;
			break;
		default:
			break;
	}
}

// libsnd2/ssinit.o

void _SsInit(void)
{
	s16 *reg_set_ptr;
	int i;
	int j;

	reg_set_ptr = (s16 *)0xBF900760;
	for ( i = 0; i < 16; i += 1 )
	{
		reg_set_ptr[i] = volume_dat_2[i];
	}
	_SsVmInit(24);
	for ( j = 0; j < 32; j += 1 )
	{
		for ( i = 0; i < 16; i += 1 )
		{
			_SsMarkCallback[j].m_entries[i] = 0;
		}
	}
	VBLANK_MINUS = 60;
	_snd_openflag = 0;
	_snd_ev_flag = 0;
}

// libsnd2/ssinit_c.o

void SsInit(void)
{
	SpuInit();
	_SsInit();
}

void SsPitchCorrect(s16 pitch_correct)
{
	gPitchCorrect = pitch_correct;
}

// libsnd2/ssinit_h.o

void SsInitHot(void)
{
	SpuInitHot();
	_SsInit();
}

// libsnd2/ssloop.o

void SsSetLoop(s16 sep_no, s16 seq_no, s16 l_count)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_l_count = l_count;
	score_struct->m_unk21 = 0;
}

s16 SsIsEos(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	return (u8)score_struct->m_play_mode;
}

// libsnd2/ssmark.o

void SsSetMarkCallback(s16 sep_no, s16 seq_no, SsMarkCallbackProc proc)
{
	_SsMarkCallback[sep_no].m_entries[seq_no] = proc;
}

// libsnd2/ssnext.o

void SsSetNext(s16 sep_no1, s16 seq_no1, s16 sep_no2, s16 seq_no2)
{
	libsnd2_sequence_struct_t *score_struct_1;
	libsnd2_sequence_struct_t *score_struct_2;

	score_struct_1 = &_ss_score[sep_no1][seq_no1];
	score_struct_1->m_next_seq = seq_no2;
	score_struct_1->m_next_sep = sep_no2;
	score_struct_2 = &_ss_score[sep_no2][seq_no2];
	score_struct_2->m_flags |= 0x100u;
	score_struct_2->m_play_mode = SSPLAY_PAUSE;
}

void SsSeqSetNext(s16 sep_no1, s16 sep_no2)
{
	libsnd2_sequence_struct_t *score_struct_1;
	libsnd2_sequence_struct_t *score_struct_2;

	score_struct_1 = &_ss_score[sep_no1][0];
	score_struct_1->m_next_sep = sep_no2;
	score_struct_1->m_next_seq = 0;
	score_struct_2 = &_ss_score[sep_no2][0];
	score_struct_2->m_flags |= 0x100u;
	score_struct_2->m_play_mode = SSPLAY_PAUSE;
}

// libsnd2/ssnoff.o

void SsSetNoiseOff(void)
{
	_SsVmNoiseOff();
}

// libsnd2/ssnon.o

void SsSetNoiseOn(s16 voll, s16 volr)
{
	_SsVmNoiseOn(voll, volr);
}

// libsnd2/ssopenp.o

s16 SsSepOpen(unsigned int *addr, s16 vab_id, s16 seq_cnt)
{
	s16 v4;
	unsigned int v6;
	s16 v8;

	v4 = 0;
	if ( _snd_openflag == (u32)-1 )
	{
		printf("Can't Open Sequence data any more\n\n");
		return -1;
	}
	SsFCALL.noteon = _SsNoteOn;
	SsFCALL.programchange = _SsSetProgramChange;
	SsFCALL.metaevent = _SsGetMetaEvent;
	SsFCALL.pitchbend = _SsSetPitchBend;
	SsFCALL.control[CC_NUMBER] = _SsSetControlChange;
	SsFCALL.control[CC_BANKCHANGE] = _SsContBankChange;
	SsFCALL.control[CC_MAINVOL] = _SsContMainVol;
	SsFCALL.control[CC_PANPOT] = _SsContPanpot;
	SsFCALL.control[CC_EXPRESSION] = _SsContExpression;
	SsFCALL.control[CC_DAMPER] = _SsContDamper;
	SsFCALL.control[CC_NRPN1] = _SsContNrpn1;
	SsFCALL.control[CC_NRPN2] = _SsContNrpn2;
	SsFCALL.control[CC_RPN1] = _SsContRpn1;
	SsFCALL.control[CC_RPN2] = _SsContRpn2;
	SsFCALL.control[CC_EXTERNAL] = _SsContExternal;
	SsFCALL.control[CC_RESETALL] = _SsContResetAll;
	SsFCALL.control[CC_DATAENTRY] = _SsContDataEntry;
	SsFCALL.ccentry[DE_PRIORITY] = _SsSetNrpnVabAttr0;
	SsFCALL.ccentry[DE_MODE] = _SsSetNrpnVabAttr1;
	SsFCALL.ccentry[DE_LIMITL] = _SsSetNrpnVabAttr2;
	SsFCALL.ccentry[DE_LIMITH] = _SsSetNrpnVabAttr3;
	SsFCALL.ccentry[DE_ADSR_AR_L] = _SsSetNrpnVabAttr4;
	SsFCALL.ccentry[DE_ADSR_AR_E] = _SsSetNrpnVabAttr5;
	SsFCALL.ccentry[DE_ADSR_DR] = _SsSetNrpnVabAttr6;
	SsFCALL.ccentry[DE_ADSR_SL] = _SsSetNrpnVabAttr7;
	SsFCALL.ccentry[DE_ADSR_SR_L] = _SsSetNrpnVabAttr8;
	SsFCALL.ccentry[DE_ADSR_SR_E] = _SsSetNrpnVabAttr9;
	SsFCALL.ccentry[DE_ADSR_RR_L] = _SsSetNrpnVabAttr10;
	SsFCALL.ccentry[DE_ADSR_RR_E] = _SsSetNrpnVabAttr11;
	SsFCALL.ccentry[DE_ADSR_SR] = _SsSetNrpnVabAttr12;
	SsFCALL.ccentry[DE_VIB_TIME] = _SsSetNrpnVabAttr13;
	SsFCALL.ccentry[DE_PORTA_DEPTH] = _SsSetNrpnVabAttr14;
	SsFCALL.ccentry[DE_REV_TYPE] = _SsSetNrpnVabAttr15;
	SsFCALL.ccentry[DE_REV_DEPTH] = _SsSetNrpnVabAttr16;
	SsFCALL.ccentry[DE_ECHO_FB] = _SsSetNrpnVabAttr17;
	SsFCALL.ccentry[DE_ECHO_DELAY] = _SsSetNrpnVabAttr18;
	SsFCALL.ccentry[DE_DELAY] = _SsSetNrpnVabAttr19;
	for ( v6 = 0; v6 < 32; v6 += 1 )
	{
		if ( (_snd_openflag & ((u32)1 << v6)) == 0 )
		{
			v4 = v6;
			break;
		}
	}
	_snd_openflag |= 1 << v4;
	for ( v8 = 0; v8 < seq_cnt; v8 += 1 )
	{
		int inited;

		inited = _SsInitSoundSep(v4, v8, vab_id, (u8 *)addr);
		addr = (unsigned int *)((char *)addr + inited);
		if ( inited == -1 )
			return -1;
	}
	return v4;
}

// libsnd2/ssopenq.o

s16 SsSeqOpen(unsigned int *addr, s16 vab_id)
{
	s16 open_counter_2;
	unsigned int open_counter_1;
	int seq_init;

	open_counter_2 = 0;
	if ( _snd_openflag == (u32)-1 )
	{
		printf("Can't Open Sequence data any more\n\n");
		return -1;
	}
	for ( open_counter_1 = 0; open_counter_1 < 32; open_counter_1 += 1 )
	{
		if ( (_snd_openflag & ((u32)1 << open_counter_1)) == 0 )
		{
			open_counter_2 = open_counter_1;
			break;
		}
	}
	_snd_openflag |= 1 << open_counter_2;
	seq_init = _SsInitSoundSeq(open_counter_2, vab_id, (u8 *)addr);
	SsFCALL.noteon = _SsNoteOn;
	SsFCALL.programchange = _SsSetProgramChange;
	SsFCALL.metaevent = _SsGetMetaEvent;
	SsFCALL.pitchbend = _SsSetPitchBend;
	SsFCALL.control[CC_NUMBER] = _SsSetControlChange;
	SsFCALL.control[CC_BANKCHANGE] = _SsContBankChange;
	SsFCALL.control[CC_MAINVOL] = _SsContMainVol;
	SsFCALL.control[CC_PANPOT] = _SsContPanpot;
	SsFCALL.control[CC_EXPRESSION] = _SsContExpression;
	SsFCALL.control[CC_DAMPER] = _SsContDamper;
	SsFCALL.control[CC_NRPN1] = _SsContNrpn1;
	SsFCALL.control[CC_NRPN2] = _SsContNrpn2;
	SsFCALL.control[CC_RPN1] = _SsContRpn1;
	SsFCALL.control[CC_RPN2] = _SsContRpn2;
	SsFCALL.control[CC_EXTERNAL] = _SsContExternal;
	SsFCALL.control[CC_RESETALL] = _SsContResetAll;
	SsFCALL.control[CC_DATAENTRY] = _SsContDataEntry;
	SsFCALL.ccentry[DE_PRIORITY] = _SsSetNrpnVabAttr0;
	SsFCALL.ccentry[DE_MODE] = _SsSetNrpnVabAttr1;
	SsFCALL.ccentry[DE_LIMITL] = _SsSetNrpnVabAttr2;
	SsFCALL.ccentry[DE_LIMITH] = _SsSetNrpnVabAttr3;
	SsFCALL.ccentry[DE_ADSR_AR_L] = _SsSetNrpnVabAttr4;
	SsFCALL.ccentry[DE_ADSR_AR_E] = _SsSetNrpnVabAttr5;
	SsFCALL.ccentry[DE_ADSR_DR] = _SsSetNrpnVabAttr6;
	SsFCALL.ccentry[DE_ADSR_SL] = _SsSetNrpnVabAttr7;
	SsFCALL.ccentry[DE_ADSR_SR_L] = _SsSetNrpnVabAttr8;
	SsFCALL.ccentry[DE_ADSR_SR_E] = _SsSetNrpnVabAttr9;
	SsFCALL.ccentry[DE_ADSR_RR_L] = _SsSetNrpnVabAttr10;
	SsFCALL.ccentry[DE_ADSR_RR_E] = _SsSetNrpnVabAttr11;
	SsFCALL.ccentry[DE_ADSR_SR] = _SsSetNrpnVabAttr12;
	SsFCALL.ccentry[DE_VIB_TIME] = _SsSetNrpnVabAttr13;
	SsFCALL.ccentry[DE_PORTA_DEPTH] = _SsSetNrpnVabAttr14;
	SsFCALL.ccentry[DE_REV_TYPE] = _SsSetNrpnVabAttr15;
	SsFCALL.ccentry[DE_REV_DEPTH] = _SsSetNrpnVabAttr16;
	SsFCALL.ccentry[DE_ECHO_FB] = _SsSetNrpnVabAttr17;
	SsFCALL.ccentry[DE_ECHO_DELAY] = _SsSetNrpnVabAttr18;
	SsFCALL.ccentry[DE_DELAY] = _SsSetNrpnVabAttr19;
	if ( seq_init == -1 )
		return -1;
	return open_counter_2;
}

// libsnd2/ssopenpj.o

s16 SsSepOpenJ(unsigned int *addr, s16 vab_id, s16 seq_cnt)
{
	s16 v4;
	unsigned int v6;
	s16 v8;

	v4 = 0;
	if ( _snd_openflag == (u32)-1 )
	{
		printf("Can't Open Sequence data any more\n\n");
		return -1;
	}
	for ( v6 = 0; v6 < 32; v6 += 1 )
	{
		if ( (_snd_openflag & ((u32)1 << v6)) == 0 )
		{
			v4 = v6;
			break;
		}
	}
	_snd_openflag |= 1 << v4;
	for ( v8 = 0; v8 < seq_cnt; v8 += 1 )
	{
		int inited;

		inited = _SsInitSoundSep(v4, v8, vab_id, (u8 *)addr);
		addr = (unsigned int *)((char *)addr + inited);
		if ( inited == -1 )
			return -1;
	}
	return v4;
}

// libsnd2/ssopenqj.o

s16 SsSeqOpenJ(unsigned int *addr, s16 vab_id)
{
	s16 v2;
	unsigned int v4;

	v2 = 0;
	if ( _snd_openflag == (u32)-1 )
	{
		printf("Can't Open Sequence data any more\n\n");
		return -1;
	}
	for ( v4 = 0; v4 < 32; v4 += 1 )
	{
		if ( (_snd_openflag & ((u32)1 << v4)) == 0 )
		{
			v2 = v4;
			break;
		}
	}
	_snd_openflag |= 1 << v2;
	if ( _SsInitSoundSeq(v2, vab_id, (u8 *)addr) == -1 )
		return -1;
	return v2;
}

// libsnd2/sspause.o

void _SsSndSetPauseMode(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	_SsVmGetSeqVol(sep_no | (seq_no << 8), &score_struct->m_unk5C, &score_struct->m_unk5E);
	score_struct->m_flags &= ~1u;
	score_struct->m_flags &= ~8u;
	score_struct->m_flags |= 2u;
}

void SsSeqPause(s16 sep_no)
{
	_SsSndSetPauseMode(sep_no, 0);
}

void SsSepPause(s16 sep_no, s16 seq_no)
{
	_SsSndSetPauseMode(sep_no, seq_no);
}

// libsnd2/ssplay.o

void SsSeqPlay(s16 sep_no, char play_mode, s16 l_count)
{
	Snd_SetPlayMode(sep_no, 0, play_mode, l_count);
}

void SsSepPlay(s16 sep_no, s16 seq_no, char play_mode, s16 l_count)
{
	Snd_SetPlayMode(sep_no, seq_no, play_mode, l_count);
}

// libsnd2/ssplayb.o

void SsPlayBack(s16 sep_no, s16 seq_no, s16 l_count)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_flags &= ~0x200u;
	score_struct->m_flags &= ~4u;
	score_struct->m_flags |= 1u;
	score_struct->m_l_count = l_count;
	score_struct->m_unk21 = 0;
	score_struct->m_seq_ptr = score_struct->m_unk04;
	_SsVmSetSeqVol((sep_no | (seq_no << 8)), score_struct->m_voll, score_struct->m_volr);
}

// libsnd2/ssquit.o

void SsQuit(void)
{
	SpuQuit();
}

// libsnd2/ssreplay.o

void _SsSndSetReplayMode(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;
	unsigned int m_flags;

	score_struct = &_ss_score[sep_no][seq_no];
	m_flags = score_struct->m_flags;
	if ( (m_flags & 0x204) == 0 && (m_flags & 0x100) == 0 )
	{
		score_struct->m_flags = m_flags & ~2;
		score_struct->m_flags |= 8u;
		score_struct->m_flags |= 1u;
	}
}

void SsSeqReplay(s16 sep_no)
{
	_SsSndSetReplayMode(sep_no, 0);
}

void SsSepReplay(s16 sep_no, s16 seq_no)
{
	_SsSndSetReplayMode(sep_no, seq_no);
}

// libsnd2/playmode.o

void Snd_SetPlayMode(s16 sep_no, s16 seq_no, char play_mode, char l_count)
{
	libsnd2_sequence_struct_t *score_struct;
	u8 *m_unk04;

	score_struct = &_ss_score[sep_no][seq_no];
	m_unk04 = score_struct->m_unk04;
	score_struct->m_seq_ptr = m_unk04;
	score_struct->m_unk08 = m_unk04;
	score_struct->m_unk0C = m_unk04;
	score_struct->m_flags &= ~0x200u;
	score_struct->m_flags &= ~4u;
	score_struct->m_l_count = l_count;
	switch ( play_mode )
	{
		case SSPLAY_PAUSE:
			score_struct->m_flags |= 2u;
			break;
		case SSPLAY_PLAY:
			score_struct->m_flags |= 1u;
			score_struct->m_play_mode = SSPLAY_PLAY;
			score_struct->m_unk21 = 0;
			_SsVmSetSeqVol((sep_no | (seq_no << 8)), score_struct->m_voll, score_struct->m_volr);
			break;
		default:
			break;
	}
}

// libsnd2/ssrit.o

void _SsSndSetRit(s16 sep_no, s16 seq_no, int tempo, int v_time)
{
	libsnd2_sequence_struct_t *score_struct;
	unsigned int m_flags;

	score_struct = &_ss_score[sep_no][seq_no];
	m_flags = score_struct->m_flags;
	if ( (m_flags & 1) != 0 && (m_flags & 2) == 0 )
	{
		int m_unk94;

		m_unk94 = score_struct->m_unk94;
		if ( tempo != m_unk94 )
		{
			score_struct->m_unkA4 = v_time;
			score_struct->m_unkAC = tempo;
			score_struct->m_unkA8 = v_time;
			if (
				((tempo - m_unk94 >= 0) && (tempo - m_unk94 < v_time))
				|| ((tempo - m_unk94 < 0) && (m_unk94 - tempo < v_time)) )
			{
				int v9;
				int m_unkA8;
				int v11;
				int v13;

				v9 = score_struct->m_unk94;
				m_unkA8 = score_struct->m_unkA8;
				v11 = tempo - v9;
				v13 = v9 - tempo;
				if ( v11 < 0 )
				{
					if ( v13 == -1 && (unsigned int)m_unkA8 == 0x80000000 )
						__builtin_trap();
					score_struct->m_unk4E = m_unkA8 / v13;
				}
				else if ( v11 > 0 )
				{
					score_struct->m_unk4E = m_unkA8 / v11;
				}
				else
					__builtin_trap();
			}
			else
			{
				int v14;
				int v15;
				int v16;

				v14 = score_struct->m_unk94;
				v15 = score_struct->m_unkA8;
				v16 = tempo - v14;
				if ( tempo - v14 < 0 )
					v16 = v14 - tempo;
				if ( v15 == -1 && (unsigned int)v16 == 0x80000000 )
					__builtin_trap();
				score_struct->m_unk4E = ~(u16)(v16 / v15);
			}
			score_struct->m_flags |= 0x80u;
			score_struct->m_flags &= ~0x40u;
		}
	}
}

void SsSeqSetRitardando(s16 sep_no, int tempo, int v_time)
{
	_SsSndSetRit(sep_no, 0, tempo, v_time);
}

void SsSepSetRitardando(s16 sep_no, s16 seq_no, int tempo, int v_time)
{
	_SsSndSetRit(sep_no, seq_no, tempo, v_time);
}

// libsnd2/ssp.o

int SsSeqSkip(s16 sep_no, s16 seq_no, char unit, s16 count)
{
	int m_unk54;
	int v5;
	libsnd2_sequence_struct_t *score_struct;
	void (*noteon)(s16, s16, u8, u8);
	u8 *m_unk04;
	int m_unk84;
	u8 *v19;

	m_unk54 = 0;
	v5 = 0;
	score_struct = &_ss_score[sep_no][seq_no];
	if ( count < 0 )
		return -1;
	if ( !count )
		return 0;
	noteon = SsFCALL.noteon;
	m_unk04 = score_struct->m_unk04;
	_snd_ev_flag = 1;
	score_struct->m_seq_ptr = m_unk04;
	SsFCALL.noteon = dmy_nothing1;
	switch ( unit )
	{
		case SSSKIP_TICK:
			m_unk54 = score_struct->m_unk54 * count;
			break;
		case SSSKIP_NOTE4:
			m_unk54 = count * 10 * score_struct->m_resolution_of_quarter_note;
			break;
		case SSSKIP_NOTE8:
			m_unk54 = count * 5 * score_struct->m_resolution_of_quarter_note;
			break;
		case SSSKIP_BAR:
		{
			int m_rhythm_d;

			m_rhythm_d = score_struct->m_rhythm_d;
			if ( m_rhythm_d == 2 )
			{
				m_unk54 = score_struct->m_rhythm_n * count * 10 * score_struct->m_resolution_of_quarter_note;
			}
			else
			{
				int v15;

				v15 = count * 10 * score_struct->m_resolution_of_quarter_note;
				if ( (1 << m_rhythm_d) == 0 )
					__builtin_trap();
				if ( 1 << m_rhythm_d == -1 && (unsigned int)v15 == 0x80000000 )
					__builtin_trap();
				m_unk54 = v15 / (1 << m_rhythm_d) * score_struct->m_rhythm_n;
			}
			break;
		}
		default:
			break;
	}
	do
	{
		do
		{
			if ( _SsGetSeqData(sep_no, seq_no) == 1 )
			{
				m_unk54 = score_struct->m_unk54;
				m_unk84 = score_struct->m_unk84;
				v19 = score_struct->m_unk04;
				v5 = -1;
				score_struct->m_unk10 = 0;
				score_struct->m_delta_value = m_unk84;
				score_struct->m_seq_ptr = v19;
				score_struct->m_unk0C = v19;
				break;
			}
		} while ( !score_struct->m_delta_value );
		m_unk54 -= score_struct->m_delta_value;
	} while ( score_struct->m_unk54 < m_unk54 );
	SsFCALL.noteon = noteon;
	_snd_ev_flag = 0;
	return v5;
}

// libsnd2/sssp.o

int SsSetCurrentPoint(s16 sep_no, s16 seq_no, u8 *point)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	if ( point == NULL )
	{
		return -1;
	}
	score_struct->m_seq_ptr = point;
	return 0;
}

// libsnd2/sspptp.o

void SsSeqPlayPtoP(s16 sep_no, s16 seq_no, u8 *start_point, u8 *end_point, char play_mode, s16 l_count)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	if ( start_point == end_point || end_point < start_point )
	{
		printf("bad address setting!!\n");
		return;
	}
	score_struct->m_seq_ptr = start_point;
	score_struct->m_unk08 = start_point;
	score_struct->m_unk0C = start_point;
	score_struct->m_unk10 = end_point;
	score_struct->m_flags &= ~0x200u;
	score_struct->m_flags &= ~4u;
	score_struct->m_l_count = l_count;
	switch ( play_mode )
	{
		case SSPLAY_PAUSE:
			score_struct->m_flags |= 2u;
			break;
		case SSPLAY_PLAY:
			score_struct->m_flags |= 1u;
			score_struct->m_flags |= 0x400u;
			score_struct->m_play_mode = SSPLAY_PLAY;
			score_struct->m_unk21 = 0;
			_SsVmSetSeqVol((sep_no | (seq_no << 8)), score_struct->m_voll, score_struct->m_volr);
			break;
		default:
			break;
	}
}

// libsnd2/sssattr.o

void SsSetSerialAttr(char s_num, char attr, char mode)
{
	SpuCommonAttr spu_attr;

	switch ( s_num )
	{
		case SS_SERIAL_A:
			switch ( attr )
			{
				case SS_MIX:
					spu_attr.mask = SPU_COMMON_CDMIX;
					spu_attr.cd.mix = mode;
					break;
				case SS_REV:
					spu_attr.mask = SPU_COMMON_CDREV;
					spu_attr.cd.reverb = mode;
					break;
				default:
					break;
			}
			break;
		case SS_SERIAL_B:
			switch ( attr )
			{
				case SS_MIX:
					spu_attr.mask = SPU_COMMON_EXTMIX;
					spu_attr.ext.mix = mode;
					break;
				case SS_REV:
					spu_attr.mask = SPU_COMMON_EXTREV;
					spu_attr.ext.reverb = mode;
					break;
				default:
					break;
			}
			break;
		default:
			break;
	}
	SpuSetCommonAttr(&spu_attr);
}

// libsnd2/sssm.o

void SsSetMute(char mode)
{
	int mute_val;

	switch ( mode )
	{
		case SS_MUTE_OFF:
			mute_val = SPU_OFF;
			break;
		case SS_MUTE_ON:
			mute_val = SPU_ON;
			break;
		default:
			return;
	}
	SpuSetMute(mute_val);
}

// libsnd2/sssmv.o

void SsSetMVol(s16 voll, s16 volr)
{
	SpuCommonAttr spu_attr;

	spu_attr.mask = SPU_COMMON_MVOLL | SPU_COMMON_MVOLR;
	spu_attr.mvol.left = 129 * voll;
	spu_attr.mvol.right = 129 * volr;
	SpuSetCommonAttr(&spu_attr);
}

// libsnd2/sssnc.o

void SsSetNck(s16 n_clock)
{
	SpuSetNoiseClock(n_clock);
}

// libsnd2/sssrv.o

void SsSetRVol(s16 voll, s16 volr)
{
	SpuReverbAttr reverb_attr;

	reverb_attr.mask = SPU_REV_DEPTHL | SPU_REV_DEPTHR;
	reverb_attr.depth.left = (s16)(0x7FFF * voll) / 127;
	reverb_attr.depth.right = (s16)(0x7FFF * volr) / 127;
	SpuSetReverbDepth(&reverb_attr);
}

// libsnd2/ssstart.o

#ifdef LIB_1300
void _SsTrapIntrVSync(void)
{
	if ( _snd_seq_tick_env.m_vsync_callback )
		_snd_seq_tick_env.m_vsync_callback();
	_snd_seq_tick_env.m_tick_callback();
}
#endif

#ifdef LIB_1300
void _SsSeqCalledTbyT_1per2(void)
{
	static int n_4 = 0;

	if ( n_4 )
	{
		n_4 = 0;
		_snd_seq_tick_env.m_tick_callback();
	}
	else
	{
		n_4 = 1;
	}
}
#endif

int _SsTrapIntrProcIOP(void *userdata)
{
	_snd_seq_tick_env.m_tick_callback();
	return *(u32 *)userdata;
}

static void _SsStart(int start_param)
{
	int wait_tmp;
#ifndef LIB_1300
	u32 rcount_target;
	iop_sys_clock_t iop_clock;
#endif

#ifndef LIB_1300
	rcount_target = 0x1046;
#endif
	for ( wait_tmp = 0; wait_tmp < 999; wait_tmp += 1 )
	{
		__asm__ __volatile__("" : "+g"(wait_tmp) : :);
	}
	_snd_seq_tick_env.m_alarm_tick = 6;
	_snd_seq_tick_env.m_vsync_tick = 0;
	_snd_seq_tick_env.m_unk11 = 0;
	_snd_seq_tick_env.m_vsync_callback = 0;
	switch ( _snd_seq_tick_env.m_tick_mode )
	{
		case SS_NOTICK0:
			_snd_seq_tick_env.m_alarm_tick = 127;
			return;
		case SS_TICK240:
			break;
		case SS_TICK120:
#ifndef LIB_1300
			rcount_target = 0x208c;
#endif
			break;
		case SS_TICKVSYNC:
			_snd_seq_tick_env.m_alarm_tick = 0;
			if ( !start_param )
				_snd_seq_tick_env.m_vsync_tick = 1;
#ifndef LIB_1300
			else
				rcount_target = 1;
#endif
			break;
		case SS_TICK60:
		case SS_TICK50:
		default:
			if ( _snd_seq_tick_env.m_manual_tick )
				return;
#ifdef LIB_1300
			if ( _snd_seq_tick_env.m_tick_mode < 70 )
			{
				_snd_seq_tick_env.m_unk11 += 1;
				return;
			}
#endif
#ifndef LIB_1300
			if ( _snd_seq_tick_env.m_tick_mode == 0 )
				__builtin_trap();
			rcount_target = -1000000;
#endif
			break;
	}
#ifndef LIB_1300
	CpuDisableIntr();
	if ( _snd_seq_tick_env.m_vsync_tick )
	{
		RegisterVblankHandler(0, 64, _SsTrapIntrProcIOP, &_snd_seq_interval);
		EnableIntr(0);
	}
	else if ( _snd_seq_tick_env.m_alarm_tick )
	{
		USec2SysClock(rcount_target, &iop_clock);
		_snd_seq_interval = iop_clock.lo;
		SetAlarm(&iop_clock, (unsigned int (*)(void *))_SsTrapIntrProcIOP, &_snd_seq_interval);
	}
	else
	{
		EnableIntr(0);
		RegisterVblankHandler(0, 64, _SsTrapIntrProcIOP, &_snd_seq_interval);
	}
	CpuEnableIntr();
#endif
}

void SsStart(void)
{
	_SsStart(1);
}

void SsStart2(void)
{
	_SsStart(0);
}

// libsnd2/ssstop.o

void _SsSndStop(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;
	int i_tmp;
	u8 *m_unk04;

	score_struct = &_ss_score[sep_no][seq_no];
	score_struct->m_flags &= ~1u;
	score_struct->m_flags &= ~2u;
	score_struct->m_flags &= ~8u;
	score_struct->m_flags &= ~0x400u;
	score_struct->m_flags |= 4u;
	_SsVmSeqKeyOff(sep_no | (seq_no << 8));
	_SsVmDamperOff();
	m_unk04 = score_struct->m_unk04;
	score_struct->m_play_mode = SSPLAY_PAUSE;
	score_struct->m_unk88 = 0;
	score_struct->m_unk1C = 0;
	score_struct->m_unk18 = 0;
	score_struct->m_unk19 = 0;
	score_struct->m_unk1E = 0;
	score_struct->m_fn_idx = 0;
	score_struct->m_unk1B = 0;
	score_struct->m_unk1F = 0;
	score_struct->m_channel_idx = 0;
	score_struct->m_unk21 = 0;
	score_struct->m_unk1C = 0;
	score_struct->m_unk1D = 0;
	score_struct->m_unk15 = 0;
	score_struct->m_running_status = 0;
	score_struct->m_delta_value = score_struct->m_unk84;
	score_struct->m_unk94 = score_struct->m_tempo;
	score_struct->m_unk54 = score_struct->m_unk56;
	score_struct->m_seq_ptr = m_unk04;
	score_struct->m_unk08 = m_unk04;
	for ( i_tmp = 0; i_tmp < 16; i_tmp += 1 )
	{
		score_struct->m_programs[i_tmp] = i_tmp;
		score_struct->m_panpot[i_tmp] = 64;
		score_struct->m_vol[i_tmp] = 127;
	}
	score_struct->m_unk5C = 127;
	score_struct->m_unk5E = 127;
}

void SsSeqStop(s16 sep_no)
{
	_SsSndStop(sep_no, 0);
}

void SsSepStop(s16 sep_no, s16 seq_no)
{
	_SsSndStop(sep_no, seq_no);
}

// libsnd2/sssv.o

void SsSetSerialVol(char s_num, s16 voll, s16 volr)
{
	s16 voll_tmp;
	s16 volr_tmp;
	SpuCommonAttr spu_attr;

	voll_tmp = voll;
	volr_tmp = volr;
	if ( voll_tmp >= 128 )
		voll_tmp = 127;
	if ( volr_tmp >= 128 )
		volr_tmp = 127;
	switch ( s_num )
	{
		case SS_SERIAL_A:
			spu_attr.mask = SPU_COMMON_CDVOLL | SPU_COMMON_CDVOLR;
			spu_attr.cd.volume.left = 258 * voll_tmp;
			spu_attr.cd.volume.right = 258 * volr_tmp;
			break;
		case SS_SERIAL_B:
			spu_attr.mask = SPU_COMMON_EXTVOLL | SPU_COMMON_EXTVOLR;
			spu_attr.ext.volume.left = 258 * voll_tmp;
			spu_attr.ext.volume.right = 258 * volr_tmp;
			break;
	}
	SpuSetCommonAttr(&spu_attr);
}

// libsnd2/sstable.o

void SsSetTableSize(char *table, s16 s_max, s16 t_max)
{
	int typed_table_i;
	unsigned int openflag_i;
	int i;

	_snd_seq_s_max = s_max;
	_snd_seq_t_max = t_max;
	for ( typed_table_i = 0; typed_table_i < s_max; typed_table_i += 1 )
	{
		_ss_score[typed_table_i] =
			(libsnd2_sequence_struct_t *)&table[sizeof(libsnd2_sequence_struct_t) * (t_max * typed_table_i)];
	}
	for ( openflag_i = s_max; openflag_i < 32; openflag_i += 1 )
	{
		_snd_openflag |= (u32)1 << openflag_i;
	}
	for ( i = 0; i < _snd_seq_s_max; i += 1 )
	{
		int j;

		j = 0;
		for ( j = 0; j < _snd_seq_t_max; j += 1 )
		{
			libsnd2_sequence_struct_t *score_struct;

			score_struct = &_ss_score[i][j];
			score_struct->m_flags = 0;
			score_struct->m_next_sep = 255;
			score_struct->m_next_seq = 0;
			score_struct->m_unk48 = 0;
			score_struct->m_unk4A = 0;
			score_struct->m_unk9C = 0;
			score_struct->m_unkA0 = 0;
			score_struct->m_unk4C = 0;
			score_struct->m_unkAC = 0;
			score_struct->m_unkA8 = 0;
			score_struct->m_unkA4 = 0;
			score_struct->m_unk4E = 0;
			score_struct->m_voll = 127;
			score_struct->m_volr = 127;
			score_struct->m_unk5C = 127;
			score_struct->m_unk5E = 127;
		}
	}
}

// libsnd2/sstempo.o

void SsSetTempo(s16 sep_no, s16 seq_no, s16 tempo)
{
	libsnd2_sequence_struct_t *score_struct;
	unsigned int v4;
	int v5;
	int v6;
	unsigned int v7;

	score_struct = &_ss_score[sep_no][seq_no];
	v4 = score_struct->m_resolution_of_quarter_note * tempo;
	v5 = VBLANK_MINUS;
	v6 = 15 * VBLANK_MINUS;
	score_struct->m_unk94 = tempo;
	v7 = 4 * v6;
	if ( 10 * v4 < (unsigned int)(4 * v6) )
	{
		unsigned int v9;

		if ( !v4 )
			__builtin_trap();
		v9 = 600 * v5 / v4;
		score_struct->m_unk52 = v9;
		score_struct->m_unk54 = v9;
	}
	else
	{
		unsigned int v11;
		unsigned int v12;

		v11 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_unk94 / v7;
		v12 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_unk94 % v7;
		score_struct->m_unk52 = -1;
		score_struct->m_unk54 = v11;
		if ( (unsigned int)(2 * v6) < v12 )
		{
			score_struct->m_unk54 = v11 + 1;
		}
	}
	score_struct->m_unk56 = score_struct->m_unk54;
}

// libsnd2/sstick.o

void SsSetTickMode(int tick_mode)
{
	if ( (tick_mode & SS_NOTICK) != 0 )
	{
		_snd_seq_tick_env.m_manual_tick = 1;
		_snd_seq_tick_env.m_tick_mode = tick_mode & 0xFFF;
	}
	else
	{
		_snd_seq_tick_env.m_manual_tick = 0;
		_snd_seq_tick_env.m_tick_mode = tick_mode;
	}
	switch ( _snd_seq_tick_env.m_tick_mode )
	{
		case SS_NOTICK0:
		case SS_TICKVSYNC:
			VBLANK_MINUS = 60;
			break;
		case SS_TICK60:
			VBLANK_MINUS = 60;
			_snd_seq_tick_env.m_tick_mode = 5;
			break;
		case SS_TICK240:
			VBLANK_MINUS = 240;
			break;
		case SS_TICK120:
			VBLANK_MINUS = 120;
			break;
		case SS_TICK50:
			VBLANK_MINUS = 50;
			_snd_seq_tick_env.m_tick_mode = 50;
			break;
		default:
			VBLANK_MINUS = _snd_seq_tick_env.m_tick_mode;
			break;
	}
}

// libsnd2/sstickcb.o

void *SsSetTickCallback(void (*cb)(void))
{
	void *result;

	result = _snd_seq_tick_env.m_tick_callback;
	if ( cb != _snd_seq_tick_env.m_tick_callback )
		_snd_seq_tick_env.m_tick_callback = cb;
	return result;
}

// libsnd2/ssvkoff.o

int SsVoKeyOff(int vab_pro, int pitch)
{
	return _SsVmSeKeyOff(vab_pro >> 8, (u8)vab_pro, (unsigned int)pitch >> 8);
}

// libsnd2/ssvkon.o

int SsVoKeyOn(int vab_pro, int pitch, u16 voll, u16 volr)
{
	return _SsVmSeKeyOn(vab_pro >> 8, (u8)vab_pro, (unsigned int)pitch >> 8, (u8)pitch, voll, volr);
}

// libsnd2/ssvol.o

void _SsSndSetVol(s16 sep_no, s16 seq_no, u16 voll, u16 volr)
{
	libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	if ( score_struct->m_flags == 1 )
	{
		_SsVmSetSeqVol(sep_no | (seq_no << 8), voll, volr);
	}
	else
	{
		score_struct->m_voll = voll;
		score_struct->m_volr = volr;
	}
}

void SsSeqSetVol(s16 sep_no, s16 voll, s16 volr)
{
	_SsSndSetVol(sep_no, 0, voll, volr);
}

void SsSepSetVol(s16 sep_no, s16 seq_no, s16 voll, s16 volr)
{
	_SsSndSetVol(sep_no, seq_no, voll, volr);
}

void SsSeqGetVol(s16 sep_no, s16 seq_no, s16 *voll, s16 *volr)
{
	_SsVmGetSeqVol(sep_no | (seq_no << 8), voll, volr);
}

// libsnd2/tempo.o

void _SsSndTempo(s16 sep_no, s16 seq_no)
{
	libsnd2_sequence_struct_t *score_struct;
	int unk_a8_dec;
	int m_unk4E;
	unsigned int calc;

	score_struct = &_ss_score[sep_no][seq_no];
	unk_a8_dec = score_struct->m_unkA8 - 1;
	score_struct->m_unkA8 = unk_a8_dec;
	if ( unk_a8_dec < 0 )
	{
		score_struct->m_flags &= ~0x40u;
		score_struct->m_flags &= ~0x80u;
		return;
	}
	m_unk4E = score_struct->m_unk4E;
	if ( m_unk4E <= 0 )
	{
		unsigned int m_unk94;
		unsigned int m_unkAC;
		unsigned int v14;

		m_unk94 = score_struct->m_unk94;
		m_unkAC = score_struct->m_unkAC;
		v14 = m_unk94 + m_unk4E;
		if ( m_unkAC >= m_unk94 )
		{
			if ( m_unk94 < m_unkAC )
			{
				unsigned int v16;

				v16 = m_unk94 - m_unk4E;
				m_unkAC = score_struct->m_unkAC;
				score_struct->m_unk94 = v16;
				if ( m_unkAC < v16 )
					score_struct->m_unk94 = m_unkAC;
			}
		}
		else
		{
			score_struct->m_unk94 = v14;
			if ( v14 < m_unkAC )
				score_struct->m_unk94 = m_unkAC;
		}
	}
	else
	{
		unsigned int v9;
		unsigned int v10;

		if ( !score_struct->m_unk4E )
			__builtin_trap();
		if ( unk_a8_dec % m_unk4E )
			return;
		v9 = score_struct->m_unk94;
		v10 = score_struct->m_unkAC;
		if ( v10 < v9 )
			score_struct->m_unk94 = v9 - 1;
		else if ( v9 < v10 )
			score_struct->m_unk94 = v9 + 1;
	}
	calc = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_unk94 / (unsigned int)(60 * VBLANK_MINUS);
	if ( (60 * VBLANK_MINUS) == 0 )
		__builtin_trap();
	score_struct->m_unk54 = calc;
	if ( (int)calc <= 0 )
		score_struct->m_unk54 = 1;
	if ( !score_struct->m_unkA8 || score_struct->m_unk94 == score_struct->m_unkAC )
	{
		score_struct->m_flags &= ~0x40u;
		score_struct->m_flags &= ~0x80u;
	}
}

// libsnd2/vol.o

void _SsSndSetVolData(s16 sep_no, s16 seq_no, s16 vol, int v_time)
{
	libsnd2_sequence_struct_t *score_struct;
	unsigned int m_flags;

	score_struct = &_ss_score[sep_no][seq_no];
	m_flags = score_struct->m_flags;
	if ( (m_flags & 4) == 0 && (m_flags & 0x100) == 0 && vol != 0 )
	{
		score_struct->m_unk48 = vol;
		score_struct->m_unk9C = v_time;
		score_struct->m_unkA0 = 0;
		score_struct->m_unk4A = 0;
	}
}

// libsnd2/dmyprint.o

void dmy_nothing1(s16 seq_no, s16 sep_no, u8 note, u8 vollr)
{
	(void)sep_no;
	(void)seq_no;
	(void)note;
	(void)vollr;
}

void dmy_SsNoteOn(s16 sep_no, s16 seq_no, u8 note, u8 vollr)
{
	(void)sep_no;
	(void)seq_no;
	(void)note;
	(void)vollr;
	if ( !is_first_dmy_SsNoteOn )
	{
		printf("_SsNoteOn\n");
		is_first_dmy_SsNoteOn = 1;
	}
}

void dmy_SsSetProgramChange(s16 sep_no, s16 seq_no, u8 prog)
{
	(void)sep_no;
	(void)seq_no;
	(void)prog;
	if ( !is_first_dmy_SsSetProgramChange )
	{
		printf("_SsSetProgramChange\n");
		is_first_dmy_SsSetProgramChange = 1;
	}
}

void dmy_SsGetMetaEvent(s16 sep_no, s16 seq_no, u8 meta_event)
{
	(void)sep_no;
	(void)seq_no;
	(void)meta_event;
	if ( !is_first_dmy_SsGetMetaEvent )
	{
		printf("_SsGetMetaEvent\n");
		is_first_dmy_SsGetMetaEvent = 1;
	}
}

void dmy_SsSetPitchBend(s16 sep_no, s16 seq_no)
{
	(void)sep_no;
	(void)seq_no;
	if ( !is_first_dmy_SsSetPitchBend )
	{
		printf("_SsSetPitchBend\n");
		is_first_dmy_SsSetPitchBend = 1;
	}
}

void dmy_SsSetControlChange(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsSetControlChange )
	{
		printf("_SsSetControlChange\n");
		is_first_dmy_SsSetControlChange = 1;
	}
}

void dmy_SsContBankChange(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContBankChange )
	{
		printf("_SsContBankChange\n");
		is_first_dmy_SsContBankChange = 1;
	}
}

void dmy_SsContDataEntry(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContDataEntry )
	{
		printf("_SsContDataEntry\n");
		is_first_dmy_SsContDataEntry = 1;
	}
}

void dmy_SsContMainVol(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContMainVol )
	{
		printf("_SsContMainVol\n");
		is_first_dmy_SsContMainVol = 1;
	}
}

void dmy_SsContPanpot(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContPanpot )
	{
		printf("_SsContPanpot\n");
		is_first_dmy_SsContPanpot = 1;
	}
}

void dmy_SsContExpression(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContExpression )
	{
		printf("_SsContExpression\n");
		is_first_dmy_SsContExpression = 1;
	}
}

void dmy_SsContDamper(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContDamper )
	{
		printf("_SsContDamper\n");
		is_first_dmy_SsContDamper = 1;
	}
}

void dmy_SsContExternal(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContExternal )
	{
		printf("_SsContExternal\n");
		is_first_dmy_SsContExternal = 1;
	}
}

void dmy_SsContNrpn1(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContNrpn1 )
	{
		printf("_SsContNrpn1\n");
		is_first_dmy_SsContNrpn1 = 1;
	}
}

void dmy_SsContNrpn2(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContNrpn2 )
	{
		printf("_SsContNrpn2\n");
		is_first_dmy_SsContNrpn2 = 1;
	}
}

void dmy_SsContRpn1(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContRpn1 )
	{
		printf("_SsContRpn1\n");
		is_first_dmy_SsContRpn1 = 1;
	}
}

void dmy_SsContRpn2(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContRpn2 )
	{
		printf("_SsContRpn2\n");
		is_first_dmy_SsContRpn2 = 1;
	}
}

void dmy_SsContResetAll(s16 sep_no, s16 seq_no, u8 control_value)
{
	(void)sep_no;
	(void)seq_no;
	(void)control_value;
	if ( !is_first_dmy_SsContResetAll )
	{
		printf("_SsContResetAll\n");
		is_first_dmy_SsContResetAll = 1;
	}
}

void dmy_SsSetNrpnVabAttr0(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr0 )
	{
		printf("_SsSetNrpnVabAttr0\n");
		is_first_dmy_SsSetNrpnVabAttr0 = 1;
	}
}

void dmy_SsSetNrpnVabAttr1(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr1 )
	{
		printf("_SsSetNrpnVabAttr1\n");
		is_first_dmy_SsSetNrpnVabAttr1 = 1;
	}
}

void dmy_SsSetNrpnVabAttr2(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr2 )
	{
		printf("_SsSetNrpnVabAttr2\n");
		is_first_dmy_SsSetNrpnVabAttr2 = 1;
	}
}

void dmy_SsSetNrpnVabAttr3(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr3 )
	{
		printf("_SsSetNrpnVabAttr3\n");
		is_first_dmy_SsSetNrpnVabAttr3 = 1;
	}
}

void dmy_SsSetNrpnVabAttr4(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr4 )
	{
		printf("_SsSetNrpnVabAttr4\n");
		is_first_dmy_SsSetNrpnVabAttr4 = 1;
	}
}

void dmy_SsSetNrpnVabAttr5(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr5 )
	{
		printf("_SsSetNrpnVabAttr5\n");
		is_first_dmy_SsSetNrpnVabAttr5 = 1;
	}
}

void dmy_SsSetNrpnVabAttr6(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr6 )
	{
		printf("_SsSetNrpnVabAttr6\n");
		is_first_dmy_SsSetNrpnVabAttr6 = 1;
	}
}

void dmy_SsSetNrpnVabAttr7(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr7 )
	{
		printf("_SsSetNrpnVabAttr7\n");
		is_first_dmy_SsSetNrpnVabAttr7 = 1;
	}
}

void dmy_SsSetNrpnVabAttr8(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr8 )
	{
		printf("_SsSetNrpnVabAttr8\n");
		is_first_dmy_SsSetNrpnVabAttr8 = 1;
	}
}

void dmy_SsSetNrpnVabAttr9(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr9 )
	{
		printf("_SsSetNrpnVabAttr9\n");
		is_first_dmy_SsSetNrpnVabAttr9 = 1;
	}
}

void dmy_SsSetNrpnVabAttr10(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr10 )
	{
		printf("_SsSetNrpnVabAttr10\n");
		is_first_dmy_SsSetNrpnVabAttr10 = 1;
	}
}

void dmy_SsSetNrpnVabAttr11(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr11 )
	{
		printf("_SsSetNrpnVabAttr11\n");
		is_first_dmy_SsSetNrpnVabAttr11 = 1;
	}
}

void dmy_SsSetNrpnVabAttr12(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr12 )
	{
		printf("_SsSetNrpnVabAttr12\n");
		is_first_dmy_SsSetNrpnVabAttr12 = 1;
	}
}

void dmy_SsSetNrpnVabAttr13(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr13 )
	{
		printf("_SsSetNrpnVabAttr13\n");
		is_first_dmy_SsSetNrpnVabAttr13 = 1;
	}
}

void dmy_SsSetNrpnVabAttr14(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr14 )
	{
		printf("_SsSetNrpnVabAttr14\n");
		is_first_dmy_SsSetNrpnVabAttr14 = 1;
	}
}

void dmy_SsSetNrpnVabAttr15(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr15 )
	{
		printf("_SsSetNrpnVabAttr15\n");
		is_first_dmy_SsSetNrpnVabAttr15 = 1;
	}
}

void dmy_SsSetNrpnVabAttr16(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr16 )
	{
		printf("_SsSetNrpnVabAttr16\n");
		is_first_dmy_SsSetNrpnVabAttr16 = 1;
	}
}

void dmy_SsSetNrpnVabAttr17(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr17 )
	{
		printf("_SsSetNrpnVabAttr17\n");
		is_first_dmy_SsSetNrpnVabAttr17 = 1;
	}
}

void dmy_SsSetNrpnVabAttr18(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr18 )
	{
		printf("_SsSetNrpnVabAttr18\n");
		is_first_dmy_SsSetNrpnVabAttr18 = 1;
	}
}

void dmy_SsSetNrpnVabAttr19(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
	(void)vab_id;
	(void)prog;
	(void)tone;
	(void)vag_attr;
	(void)fn_idx;
	(void)attribute_value;
	if ( !is_first_dmy_SsSetNrpnVabAttr19 )
	{
		printf("_SsSetNrpnVabAttr19\n");
		is_first_dmy_SsSetNrpnVabAttr19 = 1;
	}
}

// libsnd2/ssgcp.o

u8 *SsGetCurrentPoint(s16 sep_no, s16 seq_no)
{
	const libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[sep_no][seq_no];
	return score_struct->m_seq_ptr;
}

// libsnd2/ssvm.o

void SsSetVoiceMask(unsigned int s_voice)
{
	_snd_vmask = s_voice;
}

unsigned int SsGetVoiceMask(void)
{
	return _snd_vmask;
}

// libsnd2/vm/ut_ako.o

void SsUtAllKeyOff(s16 mode)
{
	int vc_index;
	SpuVoiceAttr voice_attr;

	(void)mode;

	voice_attr.mask =
		SPU_VOICE_VOLL | SPU_VOICE_VOLR | SPU_VOICE_PITCH | SPU_VOICE_WDSA | SPU_VOICE_ADSR_ADSR1 | SPU_VOICE_ADSR_ADSR2;
	voice_attr.pitch = 0x1000;
	voice_attr.addr = 0x5000;
	voice_attr.adsr1 = 0x80FF;
	voice_attr.volume.left = 0;
	voice_attr.volume.right = 0;
	voice_attr.adsr2 = 0x4000;
	for ( vc_index = 0; vc_index < _SsVmMaxVoice; vc_index += 1 )
	{
		if ( (_snd_vmask & (1 << vc_index)) == 0 )
		{
			libsnd2_spu_voice_t *voice_struct;

			voice_struct = &_svm_voice[vc_index];
			voice_struct->m_unk02 = 24;
			voice_struct->m_key_stat = 0;
			voice_struct->m_seq_sep_no = 255;
			voice_struct->m_fake_program = 0;
			voice_struct->m_prog = 0;
			voice_struct->m_tone = 255;
			voice_struct->m_voll2 = 0;
			voice_attr.voice = 1 << vc_index;
			SpuSetVoiceAttr(&voice_attr);
			_svm_cur.m_voice_idx = vc_index;
			_SsVmKeyOffNow();
		}
	}
}

// libsnd2/vm/ut_autop.o

s16 SsUtAutoPan(s16 vc, s16 start_pan, s16 end_pan, s16 delta_time)
{
	_autopan = (libsnd2_auto_vol_pan_callback)SetAutoPan;
	if ( (u16)vc >= 0x18u )
		return -1;
	SeAutoPan(vc, start_pan, end_pan, delta_time);
	return 0;
}

// libsnd2/vm/ut_autov.o

s16 SsUtAutoVol(s16 vc, s16 start_vol, s16 end_vol, s16 delta_time)
{
	_autovol = (libsnd2_auto_vol_pan_callback)SetAutoVol;
	if ( (u16)vc >= 0x18u )
		return -1;
	SeAutoVol(vc, start_vol, end_vol, delta_time);
	return 0;
}

// libsnd2/vm/ut_cadsr.o

s16 SsUtChangeADSR(s16 vc, s16 vab_id, s16 prog, s16 old_note, u16 adsr1, u16 adsr2)
{
	const libsnd2_spu_voice_t *voice_struct;

	if ( (u16)vc >= 24u )
		return -1;
	voice_struct = &_svm_voice[vc];
	if ( voice_struct->m_vab_id != vab_id || voice_struct->m_prog != prog || voice_struct->m_note != old_note )
	{
		return -1;
	}
	_svm_sreg_buf[vc].m_adsr1 = adsr1;
	_svm_sreg_buf[vc].m_adsr2 = adsr2;
	_svm_sreg_dirty[vc] |= 0x30;
	return 0;
}

// libsnd2/vm/ut_cp.o

s16 SsUtChangePitch(s16 vc, s16 vab_id, s16 prog, s16 old_note, s16 old_fine, s16 new_note, s16 new_fine)
{
	int m_vab_id;
	int m_prog;
	const libsnd2_spu_voice_t *voice_struct;

	(void)old_fine;

	if ( (u16)vc >= 0x18u )
		return -1;
	voice_struct = &_svm_voice[vc];
	m_vab_id = voice_struct->m_vab_id;
	if ( m_vab_id != vab_id )
	{
		return -1;
	}
	m_prog = voice_struct->m_prog;
	if ( m_prog != prog )
	{
		return -1;
	}
	if ( voice_struct->m_note != old_note )
	{
		return -1;
	}
	_SsVmVSetUp(m_vab_id, m_prog);
	_svm_cur.m_seq_sep_no = 33;
	_svm_cur.m_voice_idx = vc;
	_svm_cur.m_tone = voice_struct->m_tone;
	_svm_sreg_buf[vc].m_pitch = note2pitch2(new_note, new_fine);
	_svm_sreg_dirty[vc] |= 4u;
	return 0;
}

// libsnd2/vm/ut_f.o

void SsUtFlush(void)
{
	if ( _snd_ev_flag != 1 )
	{
		_snd_ev_flag = 1;
		_SsVmFlush();
		_snd_ev_flag = 0;
	}
}

// libsnd2/vm/ut_gpa.o

s16 SsUtGetProgAtr(s16 vab_id, s16 prog, ProgAtr *prog_attr_ptr)
{
	const ProgAtr *pProg;

	if ( _svm_vab_used[vab_id] != 1 )
		return -1;
	_SsVmVSetUp(vab_id, prog);
	pProg = &_svm_pg[prog];
	prog_attr_ptr->tones = pProg->tones;
	prog_attr_ptr->mvol = pProg->mvol;
	prog_attr_ptr->prior = pProg->prior;
	prog_attr_ptr->mode = pProg->mode;
	prog_attr_ptr->mpan = pProg->mpan;
	prog_attr_ptr->attr = pProg->attr;
	return 0;
}

// libsnd2/vm/ut_gva.o

s16 SsUtGetVagAtr(s16 vab_id, s16 prog, s16 tone, VagAtr *vag_attr_ptr)
{
	const VagAtr *pVag;

	if ( _svm_vab_used[vab_id] != 1 )
		return -1;
	_SsVmVSetUp(vab_id, prog);
	pVag = &_svm_tn[16 * _svm_cur.m_fake_program + tone];
	vag_attr_ptr->prior = pVag->prior;
	vag_attr_ptr->mode = pVag->mode;
	vag_attr_ptr->vol = pVag->vol;
	vag_attr_ptr->pan = pVag->pan;
	vag_attr_ptr->center = pVag->center;
	vag_attr_ptr->shift = pVag->shift;
	vag_attr_ptr->max = pVag->max;
	vag_attr_ptr->min = pVag->min;
	vag_attr_ptr->vibW = pVag->vibW;
	vag_attr_ptr->vibT = pVag->vibT;
	vag_attr_ptr->porW = pVag->porW;
	vag_attr_ptr->porT = pVag->porT;
	vag_attr_ptr->pbmin = pVag->pbmin;
	vag_attr_ptr->pbmax = pVag->pbmax;
	vag_attr_ptr->adsr1 = pVag->adsr1;
	vag_attr_ptr->adsr2 = pVag->adsr2;
	vag_attr_ptr->prog = pVag->prog;
	vag_attr_ptr->vag = pVag->vag;
	return 0;
}

// libsnd2/vm/ut_gvad.o

int SsUtGetVagAddr(s16 vab_id, s16 vag_id)
{
	int m_vag_spu_addr;

	if ( _SsVmVSetUp(vab_id, 0) == -1 )
		return -1;
	if ( (vag_id & 1) != 0 )
	{
		m_vag_spu_addr = _svm_pg[(vag_id - 1) / 2].m_vag_spu_addr_hi;
	}
	else
	{
		m_vag_spu_addr = _svm_pg[(vag_id - 1) / 2].m_vag_spu_addr_lo;
	}
	return (m_vag_spu_addr << 4) | (gVabOffet[_svm_cur.m_vab_id] << 20);
}

// libsnd2/vm/ut_gvaft.o

unsigned int SsUtGetVagAddrFromTone(s16 vab_id, s16 prog, s16 tone)
{
	s16 vag;
	int m_vag_spu_addr;

	if ( _SsVmVSetUp(vab_id, prog) == -1 )
		return -1;
	vag = _svm_tn[16 * _svm_cur.m_fake_program + tone].vag;
	if ( (vag & 1) != 0 )
	{
		m_vag_spu_addr = _svm_pg[(vag - 1) / 2].m_vag_spu_addr_hi;
	}
	else
	{
		m_vag_spu_addr = _svm_pg[(vag - 1) / 2].m_vag_spu_addr_lo;
	}
	return (m_vag_spu_addr << 4) | (gVabOffet[_svm_cur.m_vab_id] << 20);
}

// libsnd2/vm/ut_gvba.o

unsigned int SsUtGetVBaddrInSB(s16 vab_id)
{
	if ( (u16)vab_id >= 0x11u )
		return -1;
	if ( _svm_vab_used[vab_id] != 1 )
		return -1;
	return _svm_vab_start[vab_id];
}

// libsnd2/vm/ut_gvh.o

s16 SsUtGetVabHdr(s16 vab_id, VabHdr *vab_hdr_ptr)
{
	VabHdr *vab_hdr_temp;

	if ( _svm_vab_used[vab_id] != 1 )
		return -1;
	vab_hdr_temp = _svm_vab_vh[vab_id];
	vab_hdr_ptr->form = vab_hdr_temp->form;
	vab_hdr_ptr->id = vab_hdr_temp->id;
	vab_hdr_ptr->ver = vab_hdr_temp->ver;
	vab_hdr_ptr->ps = vab_hdr_temp->ps;
	vab_hdr_ptr->ts = vab_hdr_temp->ts;
	vab_hdr_ptr->vs = vab_hdr_temp->vs;
	vab_hdr_ptr->mvol = vab_hdr_temp->mvol;
	vab_hdr_ptr->pan = vab_hdr_temp->pan;
	vab_hdr_ptr->attr1 = vab_hdr_temp->attr1;
	vab_hdr_ptr->attr2 = vab_hdr_temp->attr2;
	_svm_vh = vab_hdr_temp;
	return 0;
}

// libsnd2/vm/ut_key.o

s16 SsUtKeyOn(s16 vab_id, s16 prog, s16 tone, s16 note, s16 fine, s16 voll, s16 volr)
{
	const ProgAtr *pProg;
	const VagAtr *pVag;
	int voice;
	libsnd2_spu_voice_t *voice_struct;

	if ( _snd_ev_flag == 1 )
		return -1;
	_snd_ev_flag = 1;
	if ( _SsVmVSetUp(vab_id, prog) )
	{
		_snd_ev_flag = 0;
		return -1;
	}
	_svm_cur.m_seq_sep_no = 33;
	_svm_cur.m_note = note;
	_svm_cur.m_fine = fine;
	_svm_cur.m_tone = tone;
	if ( voll == volr )
	{
		_svm_cur.m_unk05 = 64;
		_svm_cur.m_voll = voll;
	}
	else
	{
		int volr_lshift_6;

		volr_lshift_6 = volr << 6;
		if ( volr >= voll )
		{
			int voll_lshift_6;

			voll_lshift_6 = voll << 6;
			if ( !volr )
				__builtin_trap();
			if ( volr == -1 && (unsigned int)voll_lshift_6 == 0x80000000 )
				__builtin_trap();
			_svm_cur.m_voll = volr;
			_svm_cur.m_unk05 = 127 - voll_lshift_6 / volr;
		}
		else
		{
			if ( !voll )
				__builtin_trap();
			if ( voll == -1 && (unsigned int)volr_lshift_6 == 0x80000000 )
				__builtin_trap();
			_svm_cur.m_unk05 = volr_lshift_6 / voll;
			_svm_cur.m_voll = voll;
		}
	}
	pProg = &_svm_pg[prog];
	_svm_cur.m_mvol = pProg->mvol;
	_svm_cur.m_mpan = pProg->mpan;
	_svm_cur.m_sep_sep_no_tonecount = pProg->tones;
	pVag = &_svm_tn[16 * _svm_cur.m_fake_program + _svm_cur.m_tone];
	_svm_cur.m_prior = pVag->prior;
	_svm_cur.m_vag_idx2 = pVag->vag;
	_svm_cur.m_vol = pVag->vol;
	_svm_cur.m_pan = pVag->pan;
	_svm_cur.m_centre = pVag->center;
	_svm_cur.m_shift = pVag->shift;
	_svm_cur.m_mode = pVag->mode;
	if ( !_svm_cur.m_vag_idx2 || (voice = (u8)_SsVmAlloc(), voice == _SsVmMaxVoice) )
	{
		_snd_ev_flag = 0;
		return -1;
	}
	voice = (u8)_SsVmAlloc();
	if ( voice == _SsVmMaxVoice )
	{
		_snd_ev_flag = 0;
		return -1;
	}
	_svm_cur.m_voice_idx = voice;
	voice_struct = &_svm_voice[voice];
	voice_struct->m_seq_sep_no = 33;
	voice_struct->m_vab_id = vab_id;
	voice_struct->m_prog = prog;
	voice_struct->m_fake_program = _svm_cur.m_fake_program;
	voice_struct->m_vag_idx = _svm_cur.m_vag_idx2;
	voice_struct->m_note = note;
	voice_struct->m_tone = _svm_cur.m_tone;
	voice_struct->m_unk1d = 1;
	voice_struct->m_unk02 = 0;
	voice_struct->m_voll2 = _svm_cur.m_voll;
	_SsVmDoAllocate();
	if ( _svm_cur.m_vag_idx2 == 255 )
	{
		vmNoiseOn(voice);
	}
	else
	{
		_SsVmKeyOnNow(1, note2pitch2(note, fine));
	}
	_snd_ev_flag = 0;
	return voice;
}

s16 SsUtKeyOff(s16 vc, s16 vab_id, s16 prog, s16 tone, s16 note)
{
	libsnd2_spu_voice_t *voice_struct;

	if ( _snd_ev_flag == 1 )
		return -1;
	_snd_ev_flag = 1;
	if ( (u16)vc >= 0x18u )
	{
		_snd_ev_flag = 0;
		return -1;
	}
	voice_struct = &_svm_voice[vc];
	if (
		voice_struct->m_vab_id == vab_id && voice_struct->m_prog == prog && voice_struct->m_tone == tone
		&& voice_struct->m_note == note && voice_struct->m_vag_idx == 255 )
	{
		vmNoiseOff(vc);
	}
	else
	{
		_svm_cur.m_voice_idx = vc;
		_SsVmKeyOffNow();
	}
	voice_struct->m_b_auto_pan = 0;
	voice_struct->m_b_auto_vol = 0;
	_snd_ev_flag = 0;
	return 0;
}

// libsnd2/vm/ut_keyv.o

s16 SsUtKeyOnV(s16 vc, s16 vab_id, s16 prog, s16 tone, s16 note, s16 fine, s16 voll, s16 volr)
{
	const ProgAtr *pProg;
	const VagAtr *pVag;
	libsnd2_spu_voice_t *voice_struct;

	if ( _snd_ev_flag == 1 )
		return -1;
	_snd_ev_flag = 1;
	if ( (u16)vc >= 0x18u || _SsVmVSetUp(vab_id, prog) )
	{
		_snd_ev_flag = 0;
		return -1;
	}
	_svm_cur.m_seq_sep_no = 33;
	_svm_cur.m_note = note;
	_svm_cur.m_fine = fine;
	_svm_cur.m_tone = tone;
	if ( voll == volr )
	{
		_svm_cur.m_unk05 = 64;
		_svm_cur.m_voll = voll;
	}
	else
	{
		int volr_lshift_6;

		volr_lshift_6 = volr << 6;
		if ( volr >= voll )
		{
			int voll_lshift_6;

			voll_lshift_6 = voll << 6;
			if ( !volr )
				__builtin_trap();
			if ( volr == -1 && (unsigned int)voll_lshift_6 == 0x80000000 )
				__builtin_trap();
			_svm_cur.m_voll = volr;
			_svm_cur.m_unk05 = 127 - voll_lshift_6 / volr;
		}
		else
		{
			if ( !voll )
				__builtin_trap();
			if ( voll == -1 && (unsigned int)volr_lshift_6 == 0x80000000 )
				__builtin_trap();
			_svm_cur.m_voll = voll;
			_svm_cur.m_unk05 = volr_lshift_6 / voll;
		}
	}
	pProg = &_svm_pg[prog];
	_svm_cur.m_mvol = pProg->mvol;
	_svm_cur.m_mpan = pProg->mpan;
	_svm_cur.m_sep_sep_no_tonecount = pProg->tones;
	pVag = &_svm_tn[16 * _svm_cur.m_fake_program + tone];
	_svm_cur.m_prior = pVag->prior;
	_svm_cur.m_vag_idx2 = pVag->vag;
	_svm_cur.m_vol = pVag->vol;
	_svm_cur.m_pan = pVag->pan;
	_svm_cur.m_centre = pVag->center;
	_svm_cur.m_shift = pVag->shift;
	_svm_cur.m_mode = pVag->mode;
	if ( _svm_cur.m_vag_idx2 == 0 )
	{
		_snd_ev_flag = 0;
		return -1;
	}
	_svm_cur.m_voice_idx = vc;
	voice_struct = &_svm_voice[vc];
	voice_struct->m_seq_sep_no = 33;
	voice_struct->m_vab_id = vab_id;
	voice_struct->m_prog = prog;
	voice_struct->m_fake_program = _svm_cur.m_fake_program;
	voice_struct->m_vag_idx = _svm_cur.m_vag_idx2;
	voice_struct->m_note = note;
	voice_struct->m_unk1d = 1;
	voice_struct->m_unk02 = 0;
	voice_struct->m_tone = _svm_cur.m_tone;
	voice_struct->m_voll2 = _svm_cur.m_voll;
	_SsVmDoAllocate();
	if ( _svm_cur.m_vag_idx2 == 255 )
	{
		vmNoiseOn(vc);
	}
	else
	{
		_SsVmKeyOnNow(1, note2pitch2(note, fine));
	}
	_snd_ev_flag = 0;
	return vc;
}

s16 SsUtKeyOffV(s16 vc)
{
	if ( _snd_ev_flag == 1 )
		return -1;
	_snd_ev_flag = 1;
	if ( (u16)vc >= 0x18u )
	{
		_snd_ev_flag = 0;
		return -1;
	}
	_svm_cur.m_voice_idx = vc;
	_SsVmKeyOffNow();
	return 0;
}

// libsnd2/vm/ut_pb.o

s16 SsUtPitchBend(s16 vc, s16 vab_id, s16 prog, s16 note, s16 pbend)
{
	(void)note;

	_SsVmVSetUp(vab_id, prog);
	_svm_cur.m_seq_sep_no = 33;
	if ( _SsVmPBVoice(vc, 33, vab_id, prog, pbend) == 0 )
		return -1;
	return 0;
}

// libsnd2/vm/ut_rdel.o

void SsUtSetReverbDelay(s16 delay)
{
	_svm_rattr.delay = delay;
	_svm_rattr.mask = SPU_REV_DELAYTIME;
	SpuSetReverbModeParam(&_svm_rattr);
}

// libsnd2/vm/ut_rdep.o

void SsUtSetReverbDepth(s16 ldepth, s16 rdepth)
{
	_svm_rattr.mask = SPU_REV_DEPTHL | SPU_REV_DEPTHR;
	_svm_rattr.depth.left = (s16)(0x7FFF * ldepth) / 127;
	_svm_rattr.depth.right = (s16)(0x7FFF * rdepth) / 127;
	SpuSetReverbModeParam(&_svm_rattr);
}

// libsnd2/vm/ut_rev.o

s16 SsUtSetReverbType(s16 type)
{
	int flag_tmp;
	int type_tmp1;
	int type_mode_flag_tmp;
	s16 type_tmp2;

	flag_tmp = 0;
	type_tmp1 = type;
	if ( (type & 0x8000) != 0 )
	{
		flag_tmp = 1;
		type_tmp1 = -type;
	}
	if ( (u16)type_tmp1 >= SS_REV_TYPE_MAX )
		return -1;
	_svm_rattr.mask = SPU_REV_MODE;
	if ( flag_tmp )
		type_mode_flag_tmp = (type_tmp1 | SPU_REV_MODE_CLEAR_WA);
	else
		type_mode_flag_tmp = type_tmp1;
	_svm_rattr.mode = type_mode_flag_tmp;
	type_tmp2 = type_tmp1;
	if ( !(u16)type_tmp1 )
		SpuSetReverb(SPU_OFF);
	SpuSetReverbModeParam(&_svm_rattr);
	return type_tmp2;
}

s16 SsUtGetReverbType(void)
{
	return _svm_rattr.mode;
}

// libsnd2/vm/ut_rfb.o

void SsUtSetReverbFeedback(s16 feedback)
{
	_svm_rattr.feedback = feedback;
	_svm_rattr.mask = SPU_REV_FEEDBACK;
	SpuSetReverbModeParam(&_svm_rattr);
}

// libsnd2/vm/ut_roff.o

void SsUtReverbOff(void)
{
	SpuSetReverb(SPU_OFF);
}

// libsnd2/vm/ut_ron.o

void SsUtReverbOn(void)
{
	SpuSetReverb(SPU_ON);
}

// libsnd2/vm/ut_spa.o

s16 SsUtSetProgAtr(s16 vab_id, s16 prog, const ProgAtr *prog_attr_ptr)
{
	ProgAtr *pProg;

	if ( _svm_vab_used[vab_id] != 1 )
		return -1;
	_SsVmVSetUp(vab_id, prog);
	pProg = &_svm_pg[prog];
	pProg->mvol = prog_attr_ptr->mvol;
	pProg->prior = prog_attr_ptr->prior;
	pProg->mode = prog_attr_ptr->mode;
	pProg->mpan = prog_attr_ptr->mpan;
	pProg->attr = prog_attr_ptr->attr;
	return 0;
}

// libsnd2/vm/ut_sva.o

s16 SsUtSetVagAtr(s16 vab_id, s16 prog, s16 tone, const VagAtr *vag_attr_ptr)
{
	VagAtr *pVag;

	if ( _svm_vab_used[vab_id] != 1 )
		return -1;
	_SsVmVSetUp(vab_id, prog);
	pVag = &_svm_tn[16 * _svm_cur.m_fake_program + tone];
	pVag->prior = vag_attr_ptr->prior;
	pVag->mode = vag_attr_ptr->mode;
	pVag->vol = vag_attr_ptr->vol;
	pVag->pan = vag_attr_ptr->pan;
	pVag->center = vag_attr_ptr->center;
	pVag->shift = vag_attr_ptr->shift;
	pVag->max = vag_attr_ptr->max;
	pVag->min = vag_attr_ptr->min;
	pVag->vibW = vag_attr_ptr->vibW;
	pVag->vibT = vag_attr_ptr->vibT;
	pVag->porW = vag_attr_ptr->porW;
	pVag->porT = vag_attr_ptr->porT;
	pVag->pbmin = vag_attr_ptr->pbmin;
	pVag->pbmax = vag_attr_ptr->pbmax;
	pVag->adsr1 = vag_attr_ptr->adsr1;
	pVag->adsr2 = vag_attr_ptr->adsr2;
	pVag->prog = vag_attr_ptr->prog;
	pVag->vag = vag_attr_ptr->vag;
	return 0;
}

// libsnd2/vm/ut_svh.o

s16 SsUtSetVabHdr(s16 vab_id, const VabHdr *vab_hdr_ptr)
{
	if ( _svm_vab_used[vab_id] != 1 )
		return -1;
	_svm_vh = _svm_vab_vh[vab_id];
	_svm_vh->mvol = vab_hdr_ptr->mvol;
	_svm_vh->pan = vab_hdr_ptr->pan;
	_svm_vh->attr1 = vab_hdr_ptr->attr2;
	_svm_vh->attr2 = vab_hdr_ptr->attr2;
	return 0;
}

// libsnd2/vm/ut_vvol.o

s16 SsUtGetDetVVol(s16 vc, s16 *detvoll, s16 *detvolr)
{
	if ( (u16)vc >= 0x18u )
		return -1;
	SpuGetVoiceVolume(vc, detvoll, detvolr);
	return 0;
}

s16 SsUtSetDetVVol(s16 vc, s16 detvoll, s16 detvolr)
{
	if ( (u16)vc >= 0x18u )
		return -1;
	_svm_sreg_buf[vc].m_vol_left = detvoll;
	_svm_sreg_buf[vc].m_vol_right = detvolr;
	_svm_sreg_dirty[vc] |= 3;
	return 0;
}

s16 SsUtGetVVol(s16 vc, s16 *voll, s16 *volr)
{
	s16 voll_tmp;
	s16 volr_tmp;

	if ( (u16)vc >= 0x18u )
		return -1;
	SpuGetVoiceVolume(vc, &voll_tmp, &volr_tmp);
	*voll = voll_tmp / 129;
	*volr = volr_tmp / 129;
	return 0;
}

s16 SsUtSetVVol(s16 vc, s16 voll, s16 volr)
{
	if ( (u16)vc >= 0x18u )
		return -1;
	_svm_sreg_buf[vc].m_vol_left = 129 * voll;
	_svm_sreg_buf[vc].m_vol_right = 129 * volr;
	_svm_sreg_dirty[vc] |= 3;
	return 0;
}

// libsnd2/vm/vm_aloc1.o

s16 _SsVmAlloc(void)
{
	u8 voice_to_alloc_idx;
	u16 lowest_key_stat;
	char match_counter;
	int lowest_unk02;
	char lowest_match;
	u8 i_cur_1;
	u16 lowest_prior;
	int m_priority;
	unsigned int m_key_stat;
	int m_unk02;

	voice_to_alloc_idx = 99;
	lowest_key_stat = -1;
	match_counter = 0;
	lowest_unk02 = 0;
	lowest_match = 99;
	lowest_prior = _svm_cur.m_prior;
	for ( i_cur_1 = 0; i_cur_1 < _SsVmMaxVoice; i_cur_1 += 1 )
	{
		libsnd2_spu_voice_t *voice_struct;

		voice_struct = &_svm_voice[i_cur_1];
		if ( (_snd_vmask & (1 << i_cur_1)) == 0 )
		{
			if ( !voice_struct->m_unk1d )
			{
				if ( !voice_struct->m_key_stat )
				{
					voice_to_alloc_idx = i_cur_1;
					break;
				}
			}
			m_priority = voice_struct->m_priority;
			if ( m_priority >= lowest_prior )
			{
				if ( m_priority == lowest_prior )
				{
					m_key_stat = (u16)voice_struct->m_key_stat;
					match_counter += 1;
					if ( m_key_stat >= lowest_key_stat )
					{
						if ( m_key_stat == lowest_key_stat )
						{
							m_unk02 = voice_struct->m_unk02;
							if ( lowest_unk02 < m_unk02 )
							{
								lowest_unk02 = (u16)voice_struct->m_unk02;
								lowest_match = i_cur_1;
							}
						}
					}
					else
					{
						lowest_unk02 = (u16)voice_struct->m_unk02;
						lowest_key_stat = voice_struct->m_key_stat;
						lowest_match = i_cur_1;
					}
				}
			}
			else
			{
				lowest_prior = voice_struct->m_priority;
				lowest_match = i_cur_1;
				lowest_key_stat = voice_struct->m_key_stat;
				lowest_unk02 = (u16)voice_struct->m_unk02;
				match_counter = 1;
			}
		}
	}
	if ( voice_to_alloc_idx == 99 )
	{
		voice_to_alloc_idx = lowest_match;
		if ( !match_counter )
			voice_to_alloc_idx = _SsVmMaxVoice;
	}
	if ( voice_to_alloc_idx < _SsVmMaxVoice )
	{
		int v16;
		libsnd2_spu_voice_t *voice_struct;

		for ( v16 = 0; (u8)v16 < _SsVmMaxVoice; v16 += 1 )
		{
			libsnd2_spu_voice_t *voice_struct_1;

			voice_struct_1 = &_svm_voice[(u8)v16];
			if ( (_snd_vmask & (1 << (u8)v16)) == 0 )
				voice_struct_1->m_unk02 += 1;
		}
		voice_struct = &_svm_voice[voice_to_alloc_idx];
		voice_struct->m_unk02 = 0;
		voice_struct->m_b_auto_pan = 0;
		voice_struct->m_b_auto_vol = 0;
		voice_struct->m_priority = _svm_cur.m_prior;
	}
	return voice_to_alloc_idx;
}

// libsnd2/vm/vm_aloc2.o

void _SsVmDoAllocate(void)
{
	int v0;
	u16 vag_spu_addr;
	const VagAtr *v6;
	s16 damper;
	libsnd2_spu_voice_t *voice_struct;

	voice_struct = &_svm_voice[_svm_cur.m_voice_idx];
	voice_struct->m_key_stat = 0x7FFF;
	for ( v0 = 0; v0 < 16; v0 += 1 )
	{
		_svm_envx_hist[v0] &= ~(1 << (_svm_cur.m_voice_idx & 0xFF));
	}
	if ( (_svm_cur.m_vag_idx2 & 1) != 0 )
	{
		vag_spu_addr = _svm_pg[(_svm_cur.m_vag_idx2 - 1) / 2].m_vag_spu_addr_hi;
	}
	else
	{
		vag_spu_addr = _svm_pg[(_svm_cur.m_vag_idx2 - 1) / 2].m_vag_spu_addr_lo;
	}
	_svm_sreg_buf2[_svm_cur.m_voice_idx].m_vag_spu_addr = vag_spu_addr;
	_svm_sreg_dirty[_svm_cur.m_voice_idx] |= 8u;
	_svm_sreg_buf2[_svm_cur.m_voice_idx].m_vab_spu_offset = gVabOffet[_svm_cur.m_vab_id];
	v6 = &_svm_tn[16 * _svm_cur.m_fake_program + _svm_cur.m_tone];
	_svm_sreg_buf[_svm_cur.m_voice_idx].m_adsr1 = v6->adsr1;
	damper = _svm_damper + (v6->adsr2 & 0x1F);
	if ( damper >= 32 )
		damper = 31;
	_svm_sreg_buf[_svm_cur.m_voice_idx].m_adsr2 = damper | (v6->adsr2 & ~0x1F);
	_svm_sreg_dirty[_svm_cur.m_voice_idx] |= 0x30u;
}

// libsnd2/vm/vm_autop.o

void SeAutoPan(s16 vc, s16 start_pan, s16 end_pan, s16 delta_time)
{
	libsnd2_spu_voice_t *voice_struct;

	voice_struct = &_svm_voice[vc];
	if ( start_pan == end_pan )
		return;
	voice_struct->m_b_auto_pan = 1;
	voice_struct->m_auto_pan_start = start_pan;
	voice_struct->m_auto_pan_end = end_pan;
	if (
		((start_pan - end_pan >= 0) && (start_pan - end_pan < delta_time))
		|| ((start_pan - end_pan < 0) && (end_pan - start_pan < delta_time)) )
	{
		int v8;

		if ( end_pan >= start_pan )
		{
			int v12;
			int v13;

			v12 = delta_time;
			v13 = start_pan - end_pan;
			if ( v13 == -1 && (unsigned int)v12 == 0x80000000 )
				__builtin_trap();
			voice_struct->m_auto_pan_amount = 1;
			v8 = -(v12 / v13);
		}
		else
		{
			int v9;

			v8 = delta_time;
			v9 = start_pan - end_pan;
			if ( v9 == -1 && (unsigned int)v8 == 0x80000000 )
				__builtin_trap();
			v8 = v8 / v9;
			voice_struct->m_auto_pan_amount = -1;
		}
		voice_struct->m_auto_pan_dt1 = v8;
		voice_struct->m_auto_pan_dt2 = v8;
	}
	else
	{
		int v14;

		v14 = start_pan - end_pan;
		if ( !delta_time )
			__builtin_trap();
		if ( delta_time == -1 && (unsigned int)v14 == 0x80000000 )
			__builtin_trap();
		voice_struct->m_auto_pan_dt1 = 0;
		voice_struct->m_auto_pan_dt2 = 0;
		voice_struct->m_auto_pan_amount = -(s16)(v14 / delta_time);
	}
}

void SetAutoPan(int vc)
{
	int m_auto_pan_dt2;
	int v5;
	int m_auto_pan_amount;
	char m_auto_pan_start;
	const VagAtr *pVag;
	int pan;
	unsigned int v15;
	unsigned int v16;
	unsigned int v18;
	unsigned int v19;
	int mpan;
	libsnd2_spu_voice_t *voice_struct;

	voice_struct = &_svm_voice[(s16)vc];
	m_auto_pan_dt2 = (u16)voice_struct->m_auto_pan_dt2;
	voice_struct->m_auto_pan_dt2 = m_auto_pan_dt2 - 1;
	if ( m_auto_pan_dt2 > 0 )
		return;
	v5 = (u16)voice_struct->m_auto_pan_start + (u16)voice_struct->m_auto_pan_amount;
	voice_struct->m_auto_pan_start = v5;
	m_auto_pan_amount = voice_struct->m_auto_pan_amount;
	if ( m_auto_pan_amount <= 0 )
	{
		if ( m_auto_pan_amount < 0 && (s16)v5 <= voice_struct->m_auto_pan_end )
		{
			voice_struct->m_auto_pan_start = voice_struct->m_auto_pan_end;
			voice_struct->m_b_auto_pan = 0;
		}
	}
	else if ( (s16)v5 >= voice_struct->m_auto_pan_end )
	{
		voice_struct->m_auto_pan_start = voice_struct->m_auto_pan_end;
		voice_struct->m_b_auto_pan = 0;
	}
	m_auto_pan_start = voice_struct->m_auto_pan_start;
	if ( _svm_cur.m_voice_idx == (s16)vc )
		_svm_cur.m_unk05 = voice_struct->m_auto_pan_start;
	pVag = &_svm_tn[(u16)voice_struct->m_tone + (voice_struct->m_fake_program * 16)];
	pan = (char)pVag->pan;
	v15 = voice_struct->m_voll2 * 0x3FFF * _svm_vh->mvol / 0x3F01 * _svm_pg[voice_struct->m_prog].mvol * pVag->vol;
	v16 = v15 / 0x3F01;
	if ( pan >= 64 )
	{
		v19 = v15 / 0x3F01;
		v18 = (v16 * (127 - pan)) >> 6;
	}
	else
	{
		unsigned int v17;

		v17 = v16 * pan;
		v18 = v15 / 0x3F01;
		v19 = v17 >> 6;
	}
	mpan = (char)_svm_pg[voice_struct->m_prog].mpan;
	if ( mpan >= 64 )
	{
		int v22;

		v22 = (u16)v18 * (127 - mpan);
		v18 = (unsigned int)v22 >> 6;
		if ( v22 < 0 )
			v18 = (unsigned int)(v22 + 63) >> 6;
	}
	else
	{
		int v21;

		v21 = (u16)v19 * mpan;
		v19 = (unsigned int)v21 >> 6;
		if ( v21 < 0 )
			v19 = (unsigned int)(v21 + 63) >> 6;
	}
	if ( m_auto_pan_start >= 64 )
	{
		int v24;

		v24 = (u16)v18 * (127 - m_auto_pan_start);
		v18 = (unsigned int)v24 >> 6;
		if ( v24 < 0 )
			v18 = (unsigned int)(v24 + 63) >> 6;
	}
	else
	{
		int v23;

		v23 = (u16)v19 * m_auto_pan_start;
		v19 = (unsigned int)v23 >> 6;
		if ( v23 < 0 )
			v19 = (unsigned int)(v23 + 63) >> 6;
	}
	if ( _svm_stereo_mono == 1 )
	{
		if ( (u16)v18 >= (unsigned int)(u16)v19 )
			v19 = v18;
		else
			v18 = v19;
	}
	voice_struct->m_auto_pan_dt2 = voice_struct->m_auto_pan_dt1;
	_svm_sreg_buf[vc].m_vol_left = v18;
	_svm_sreg_buf[vc].m_vol_right = v19;
	_svm_sreg_dirty[(s16)vc] |= 3;
}

// libsnd2/vm/vm_autov.o

void SeAutoVol(s16 vc, s16 start_vol, s16 end_vol, s16 delta_time)
{
	libsnd2_spu_voice_t *voice_struct;

	voice_struct = &_svm_voice[vc];
	if ( start_vol == end_vol )
		return;
	voice_struct->m_b_auto_vol = 1;
	voice_struct->m_auto_vol_start = start_vol;
	voice_struct->m_auto_vol_end = end_vol;
	if (
		((start_vol - end_vol >= 0) && (start_vol - end_vol < delta_time))
		|| ((start_vol - end_vol < 0) && (end_vol - start_vol < delta_time)) )
	{
		int v8;

		if ( end_vol >= start_vol )
		{
			int v12;
			int v13;

			v12 = delta_time;
			v13 = start_vol - end_vol;
			if ( v13 == -1 && (unsigned int)v12 == 0x80000000 )
				__builtin_trap();
			voice_struct->m_auto_vol_amount = 1;
			v8 = -(v12 / v13);
		}
		else
		{
			int v9;

			v8 = delta_time;
			v9 = start_vol - end_vol;
			if ( v9 == -1 && (unsigned int)v8 == 0x80000000 )
				__builtin_trap();
			voice_struct->m_auto_vol_amount = -1;
			v8 = v8 / v9;
		}
		voice_struct->m_auto_vol_dt1 = v8;
		voice_struct->m_auto_vol_dt2 = v8;
	}
	else
	{
		int v14;

		v14 = start_vol - end_vol;
		if ( !delta_time )
			__builtin_trap();
		if ( delta_time == -1 && (unsigned int)v14 == 0x80000000 )
			__builtin_trap();
		voice_struct->m_auto_vol_dt1 = 0;
		voice_struct->m_auto_vol_dt2 = 0;
		voice_struct->m_auto_vol_amount = -(s16)(v14 / delta_time);
	}
}

void SetAutoVol(int vc)
{
	int m_auto_vol_dt2;
	s16 v5;
	int m_auto_vol_amount;
	s16 m_auto_vol_start;
	unsigned int v9;
	unsigned int v10;
	unsigned int v11;
	libsnd2_spu_voice_t *voice_struct;

	voice_struct = &_svm_voice[(s16)vc];
	m_auto_vol_dt2 = (u16)voice_struct->m_auto_vol_dt2;
	voice_struct->m_auto_vol_dt2 = m_auto_vol_dt2 - 1;
	if ( m_auto_vol_dt2 > 0 )
		return;
	v5 = voice_struct->m_auto_vol_start + voice_struct->m_auto_vol_amount;
	voice_struct->m_auto_vol_start = v5;
	m_auto_vol_amount = voice_struct->m_auto_vol_amount;
	if ( m_auto_vol_amount > 0 )
	{
		if ( voice_struct->m_auto_vol_end <= v5 )
		{
			voice_struct->m_auto_vol_start = voice_struct->m_auto_vol_end;
			voice_struct->m_b_auto_vol = 0;
		}
	}
	if ( m_auto_vol_amount < 0 )
	{
		if ( voice_struct->m_auto_vol_end >= v5 )
		{
			voice_struct->m_auto_vol_start = voice_struct->m_auto_vol_end;
			voice_struct->m_b_auto_vol = 0;
		}
	}
	m_auto_vol_start = voice_struct->m_auto_vol_start;
	_svm_cur.m_voll = m_auto_vol_start;
	v9 = m_auto_vol_start * 0x3FFF * _svm_vh->mvol / 0x3F01 * _svm_cur.m_mvol * _svm_cur.m_vol / 0x3F01u;
	if ( (u8)_svm_cur.m_pan >= 0x40u )
	{
		v11 = v9;
		v10 = (v9 * (127 - (u8)_svm_cur.m_pan)) >> 6;
	}
	else
	{
		v10 = v9;
		v11 = (v9 * (u8)_svm_cur.m_pan) >> 6;
	}
	if ( (u8)_svm_cur.m_mpan >= 0x40u )
	{
		int v13;

		v13 = (u16)v10 * (127 - (u8)_svm_cur.m_mpan);
		v10 = (unsigned int)v13 >> 6;
		if ( v13 < 0 )
			v10 = (unsigned int)(v13 + 63) >> 6;
	}
	else
	{
		int v12;

		v12 = (u16)v11 * (u8)_svm_cur.m_mpan;
		v11 = (unsigned int)v12 >> 6;
		if ( v12 < 0 )
			v11 = (unsigned int)(v12 + 63) >> 6;
	}
	if ( (u8)_svm_cur.m_unk05 >= 0x40u )
	{
		int v15;

		v15 = (u16)v10 * (127 - (u8)_svm_cur.m_unk05);
		v10 = (unsigned int)v15 >> 6;
		if ( v15 < 0 )
			v10 = (unsigned int)(v15 + 63) >> 6;
	}
	else
	{
		int v14;

		v14 = (u16)v11 * (u8)_svm_cur.m_unk05;
		v11 = (unsigned int)v14 >> 6;
		if ( v14 < 0 )
			v11 = (unsigned int)(v14 + 63) >> 6;
	}
	if ( _svm_stereo_mono == 1 )
	{
		if ( (u16)v10 >= (unsigned int)(u16)v11 )
			v11 = v10;
		else
			v10 = v11;
	}
	voice_struct->m_auto_vol_dt2 = voice_struct->m_auto_vol_dt1;
	_svm_sreg_buf[vc].m_vol_left = v10;
	_svm_sreg_buf[vc].m_vol_right = v11;
	_svm_sreg_dirty[(s16)vc] |= 3;
}

// libsnd2/vm/vm_doff.o

void _SsVmDamperOff(void)
{
	_svm_damper = 0;
}

// libsnd2/vm/vm_don.o

void _SsVmDamperOn(void)
{
	_svm_damper = 2;
}

// libsnd2/vm/vm_f.o

void __attribute__((optimize("no-unroll-loops"))) wait1fsa(void)
{
	int i;
	int curdum;

	curdum = 13;
	for ( i = 0; i < 1000; i += 1 )
	{
		curdum *= 3;
		__asm__ __volatile__("" : "+g"(curdum) : :);
	}
}

void DumpSpu(void)
{
	int cur_i_1;
	int cur_i_2;

	for ( cur_i_1 = 0; (u16)cur_i_1 < 0x1A2u; cur_i_1 += 1 )
	{
		int curdata_1;

		curdata_1 = *(u16 *)(2 * (u16)cur_i_1 + (SpuGetCore() << 10) + 0xbf900000);
		printf("  0x%3x  0x%4x \n", (u16)cur_i_1, curdata_1);
	}
	for ( cur_i_2 = 944; (u16)cur_i_2 < 0x3C4u; cur_i_2 += 1 )
	{
		int curdata_2;

		curdata_2 = *(u16 *)(2 * (u16)cur_i_2 + 40 * SpuGetCore() + 0xbf900000);
		printf("  0x%3x  0x%4x \n", (u16)cur_i_2, curdata_2);
	}
	printf(" ------------------------------------\n");
}

void DumpVoice(void)
{
	u16 i;
	u16 cur_i_1;
	u16 cur_j_1;

	for ( i = 0; i < 0x10u; i += 1 )
	{
		if ( (((int)*((vu16 *)0xBF9001A0) >> i) & 1) != 0 )
		{
			printf("voice = %d\n", i);
			for ( cur_i_1 = 0; cur_i_1 < 8u; cur_i_1 += 1 )
			{
				printf("  0x%3x  0x%4x \n", cur_i_1, *(u16 *)(2 * cur_i_1 + 16 * i + 0xbf900000));
			}
			for ( cur_j_1 = 224; cur_j_1 < 0xE6u; cur_j_1 += 1 )
			{
				printf("  0x%3x  0x%4x \n", cur_j_1, *(u16 *)(2 * cur_j_1 + 12 * i + 0xbf900000));
			}
			printf(" ------------------------------------\n");
		}
	}
}

void DumpVoice2(void)
{
	u16 i;
	u16 cur_i_1;
	u16 cur_j_1;

	for ( i = 0; i < 0x10u; i += 1 )
	{
		if ( (((int)_svm_okon1 >> i) & 1) != 0 )
		{
			if ( i >= 5u )
			{
				*(u16 *)(16 * i + 0xbf900000) = 0;
				*(u16 *)(16 * i + 0xbf900002) = 0;
			}
			printf("voice = %d\n", i);
			for ( cur_i_1 = 0; cur_i_1 < 8u; cur_i_1 += 1 )
			{
				printf("  0x%3x  0x%4x \n", cur_i_1, *(u16 *)(2 * cur_i_1 + 16 * i + 0xbf900000));
			}
			for ( cur_j_1 = 224; cur_j_1 < 0xE6u; cur_j_1 += 1 )
			{
				printf("  0x%3x  0x%4x \n", cur_j_1, *(u16 *)(2 * cur_j_1 + 12 * i + 0xbf900000));
			}
			printf(" ------------------------------------\n");
		}
	}
}

void _SsVmFlush(void)
{
	int v1;
	signed int v4;
	int v12;
	int mask;
	SpuVoiceAttr voice_attr;

	_svm_envx_ptr = ((u8)_svm_envx_ptr + 1) & 0xF;
	_svm_envx_hist[_svm_envx_ptr] = 0;
	for ( v1 = 0; v1 < _SsVmMaxVoice; v1 += 1 )
	{
		libsnd2_spu_voice_t *voice_struct;

		voice_struct = &_svm_voice[v1];
		SpuGetVoiceEnvelope(v1, &(voice_struct->m_key_stat));
		if ( !voice_struct->m_key_stat )
			_svm_envx_hist[_svm_envx_ptr] |= 1 << v1;
	}
	if ( !_svm_auto_kof_mode )
	{
		int voiceBits;
		int v7;

		voiceBits = -1;
		for ( v4 = 0; v4 < 15; v4 += 1 )
		{
			voiceBits &= _svm_envx_hist[v4];
		}
		for ( v7 = 0; v7 < _SsVmMaxVoice; v7 += 1 )
		{
			libsnd2_spu_voice_t *voice_struct;

			voice_struct = &_svm_voice[v7];
			if ( (voiceBits & (1 << v7)) != 0 )
			{
				if ( voice_struct->m_unk1d == 2 )
				{
					int mask_1;
					int mask2;

					mask_1 = 1 << v7;
					mask2 = 0;
					if ( v7 >= 16 )
					{
						mask_1 = 0;
						mask2 = 1 << (v7 - 16);
					}
					SpuSetNoiseVoice(SPU_OFF, ((u8)mask2 << 16) | (s16)mask_1);
				}
				voice_struct->m_unk1d = 0;
			}
		}
	}
	_svm_okon1 &= ~_svm_okof1;
	_svm_okon2 &= ~_svm_okof2;
	for ( v4 = 0; v4 < 24; v4 += 1 )
	{
		const libsnd2_spu_voice_t *voice_struct;

		voice_struct = &_svm_voice[v4];
		if ( voice_struct->m_b_auto_vol )
			_autovol(v4);
		if ( voice_struct->m_b_auto_pan )
			_autopan(v4);
	}
	for ( v12 = 0; v12 < 24; v12 += 1 )
	{
		voice_attr.mask = 0;
		voice_attr.voice = 1 << v12;
		if ( (_svm_sreg_dirty[v12] & 1) != 0 )
		{
			voice_attr.mask |= SPU_VOICE_VOLL | SPU_VOICE_VOLR;
			voice_attr.volume.left = _svm_sreg_buf[v12].m_vol_left;
			voice_attr.volume.right = _svm_sreg_buf[v12].m_vol_right;
			if ( voice_attr.volume.left == 614 )
				voice_attr.volume.left = 615;
			if ( voice_attr.volume.right == 614 )
				voice_attr.volume.right = 615;
		}
		if ( (_svm_sreg_dirty[v12] & 4) != 0 )
		{
			voice_attr.mask |= SPU_VOICE_PITCH;
			voice_attr.pitch = _svm_sreg_buf[v12].m_pitch;
		}
		if ( (_svm_sreg_dirty[v12] & 8) != 0 )
		{
			voice_attr.mask |= SPU_VOICE_WDSA;
			voice_attr.addr = (_svm_sreg_buf2[v12].m_vag_spu_addr << 4) + (_svm_sreg_buf2[v12].m_vab_spu_offset << 20);
		}
		if ( (_svm_sreg_dirty[v12] & 0x10) != 0 )
		{
			voice_attr.mask |= SPU_VOICE_ADSR_ADSR1 | SPU_VOICE_ADSR_ADSR2;
			voice_attr.adsr1 = _svm_sreg_buf[v12].m_adsr1;
			voice_attr.adsr2 = _svm_sreg_buf[v12].m_adsr2;
		}
		if ( voice_attr.mask )
			SpuSetVoiceAttr(&voice_attr);
		_svm_sreg_dirty[v12] = 0;
	}
	SpuSetKey(SPU_OFF, ((u8)_svm_okof2 << 16) | _svm_okof1);
	SpuSetKey(SPU_ON, ((u8)_svm_okon2 << 16) | _svm_okon1);
	mask = 0xFFFFFF >> (24 - _SsVmMaxVoice);
	// cppcheck-suppress badBitmaskCheck
	SpuSetReverbVoice(SPU_BIT, ((((u32)_svm_orev2 << 16) | _svm_orev1) & mask) | (SpuGetReverbVoice() & ~mask));
	SpuSetNoiseVoice(SPU_BIT, ((((u32)_svm_onos2 << 16) | _svm_onos1) & mask) | (SpuGetNoiseVoice() & ~mask));
	_svm_okof1 = 0;
	_svm_okof2 = 0;
	_svm_okon1 = 0;
	_svm_okon2 = 0;
	_svm_onos1 = 0;
	_svm_onos2 = 0;
}

// libsnd2/vm/vm_init.o

void _SsVmInit(int voice_count)
{
	u16 v8;
	SpuVoiceAttr voice_attr;

	_spu_setInTransfer(0);
	_svm_damper = 0;
	SpuInitMalloc(32, (char *)_ss_spu_vm_rec);
	memset(&_svm_sreg_buf, 0, sizeof(_svm_sreg_buf));
	memset(&_svm_sreg_buf2, 0, sizeof(_svm_sreg_buf2));
	memset(&_svm_sreg_dirty, 0, sizeof(_svm_sreg_dirty));
	_svm_vab_count = 0;
	memset(&_svm_vab_used, 0, sizeof(_svm_vab_used));
	if ( ((char)voice_count & 0xFFFFu) < 0x18 )
		_SsVmMaxVoice = (char)voice_count;
	else
		_SsVmMaxVoice = 24;
	voice_attr.mask =
		SPU_VOICE_VOLL | SPU_VOICE_VOLR | SPU_VOICE_PITCH | SPU_VOICE_WDSA | SPU_VOICE_ADSR_ADSR1 | SPU_VOICE_ADSR_ADSR2;
	voice_attr.pitch = 0x1000;
	voice_attr.addr = 0x5000;
	voice_attr.adsr1 = 0x80FF;
	voice_attr.volume.left = 0;
	voice_attr.volume.right = 0;
	voice_attr.adsr2 = 0x4000;
	for ( v8 = 0; v8 < _SsVmMaxVoice; v8 += 1 )
	{
		libsnd2_spu_voice_t *voice_struct;

		voice_struct = &_svm_voice[v8];
		voice_struct->m_unk02 = 24;
		voice_struct->m_vag_idx = 255;
		voice_struct->m_unk1d = 0;
		voice_struct->m_pitch = 0;
		voice_struct->m_key_stat = 0;
		voice_struct->m_seq_sep_no = -1;
		voice_struct->m_fake_program = 0;
		voice_struct->m_prog = 0;
		voice_struct->m_tone = 255;
		voice_struct->m_voll1 = 0;
		voice_struct->m_channel_idx = 0;
		voice_struct->m_pan = 64;
		voice_struct->m_voll2 = 0;
		voice_struct->m_b_auto_vol = 0;
		voice_struct->m_auto_vol_amount = 0;
		voice_struct->m_auto_vol_dt1 = 0;
		voice_struct->m_auto_vol_dt2 = 0;
		voice_struct->m_b_auto_pan = 0;
		voice_struct->m_auto_pan_amount = 0;
		voice_struct->m_auto_pan_dt1 = 0;
		voice_struct->m_auto_pan_dt2 = 0;
		voice_struct->m_auto_pan_start = 0;
		voice_struct->m_auto_vol_start = 0;
		voice_attr.voice = 1 << v8;
		SpuSetVoiceAttr(&voice_attr);
		_svm_cur.m_voice_idx = v8;
		_SsVmKeyOffNow();
	}
	_svm_rattr.mask = 0;
	_svm_rattr.depth.left = 0x3FFF;
	_svm_rattr.depth.right = 0x3FFF;
	_svm_rattr.mode = 0;
	_svm_okon1 = 0;
	_svm_okon2 = 0;
	_svm_okof1 = 0;
	_svm_orev1 = 0;
	_svm_orev2 = 0;
	_svm_onos1 = 0;
	_svm_onos2 = 0;
	_svm_auto_kof_mode = 0;
	_svm_stereo_mono = 0;
	_svm_vab_not_send_size = 0;
	kMaxPrograms = 128;
	_SsVmFlush();
}

// libsnd2/vm/vm_key.o

int _SsVmKeyOn(int seq_sep_no, s16 vab_id, s16 prog, s16 note, s16 voll, s16 unknown27)
{
	int on_keys_mask_1;
	libsnd2_sequence_struct_t *score_struct;
	int on_keys_mask_2;
	const ProgAtr *prog_attr_Ptr;
	u8 selected_vag_count;
	const VagAtr *vag_attr_ptr;
	int v16;
	u8 vag_nums[128];
	u8 vag_index_nums[128];

	score_struct = NULL;
	if ( seq_sep_no != 33 )
	{
		score_struct = &_ss_score[(u8)seq_sep_no][(seq_sep_no & 0xFF00) >> 8];
	}
	on_keys_mask_1 = 0;
	on_keys_mask_2 = -1;
	if ( _SsVmVSetUp(vab_id, prog) != 0 )
	{
		return on_keys_mask_2;
	}
	_svm_cur.m_seq_sep_no = seq_sep_no;
	_svm_cur.m_note = note;
	_svm_cur.m_fine = 0;
	if ( score_struct != NULL )
		_svm_cur.m_voll = (u16)voll * score_struct->m_vol[score_struct->m_channel_idx] / 127;
	else
		_svm_cur.m_voll = voll;
	_svm_cur.m_unk05 = unknown27;
	prog_attr_Ptr = &_svm_pg[prog];
	_svm_cur.m_mvol = prog_attr_Ptr->mvol;
	_svm_cur.m_mpan = prog_attr_Ptr->mpan;
	_svm_cur.m_sep_sep_no_tonecount = prog_attr_Ptr->tones;
	if ( _svm_cur.m_fake_program >= (int)_svm_vh->ps )
	{
		return -1;
	}
	if ( !voll )
		return _SsVmKeyOff(seq_sep_no, vab_id, prog, note);
	selected_vag_count = _SsVmSelectToneAndVag(vag_index_nums, vag_nums);
	for ( v16 = 0; (u8)v16 < (unsigned int)selected_vag_count; v16 += 1 )
	{
		_svm_cur.m_vag_idx2 = (u8)vag_nums[(u8)v16];
		_svm_cur.m_tone = vag_index_nums[(u8)v16];
		vag_attr_ptr = &_svm_tn[(u16)(_svm_cur.m_tone + 16 * _svm_cur.m_fake_program)];
		_svm_cur.m_prior = vag_attr_ptr->prior;
		_svm_cur.m_vol = vag_attr_ptr->vol;
		_svm_cur.m_pan = vag_attr_ptr->pan;
		_svm_cur.m_centre = vag_attr_ptr->center;
		_svm_cur.m_shift = vag_attr_ptr->shift;
		_svm_cur.m_mode = vag_attr_ptr->mode;
		_svm_cur.m_voice_idx = (u8)_SsVmAlloc();
		if ( _svm_cur.m_voice_idx >= _SsVmMaxVoice )
		{
			on_keys_mask_1 = -1;
		}
		else
		{
			libsnd2_spu_voice_t *voice_struct;

			voice_struct = &_svm_voice[_svm_cur.m_voice_idx];
			voice_struct->m_unk1d = 1;
			voice_struct->m_unk02 = 0;
			voice_struct->m_seq_sep_no = seq_sep_no;
			voice_struct->m_vab_id = _svm_cur.m_vab_id;
			voice_struct->m_fake_program = _svm_cur.m_fake_program;
			voice_struct->m_prog = prog;
			if ( score_struct != NULL )
			{
				voice_struct->m_voll1 = voll;
				voice_struct->m_channel_idx = score_struct->m_channel_idx;
			}
			voice_struct->m_pan = unknown27;
			voice_struct->m_voll2 = _svm_cur.m_voll;
			voice_struct->m_tone = _svm_cur.m_tone;
			voice_struct->m_note = note;
			voice_struct->m_priority = _svm_cur.m_prior;
			voice_struct->m_vag_idx = _svm_cur.m_vag_idx2;
			_SsVmDoAllocate();
			if ( _svm_cur.m_vag_idx2 == 255 )
			{
				vmNoiseOn(_svm_cur.m_voice_idx);
			}
			else
			{
				_SsVmKeyOnNow(selected_vag_count, note2pitch());
			}
			on_keys_mask_1 |= 1 << (_svm_cur.m_voice_idx & 0xFF);
		}
	}
	return on_keys_mask_1;
}

int _SsVmKeyOff(int seq_sep_no, s16 vab_id, s16 prog, s16 note)
{
	int v4;
	int v5;

	v5 = 0;
	for ( v4 = 0; (u8)v4 < _SsVmMaxVoice; v4 += 1 )
	{
		const libsnd2_spu_voice_t *voice_struct;

		voice_struct = &_svm_voice[v4];
		if ( !((_snd_vmask & (1 << v4)) != 0 || voice_struct->m_note != note || voice_struct->m_prog != prog
					 || voice_struct->m_seq_sep_no != (s16)seq_sep_no || voice_struct->m_vab_id != vab_id) )
		{
			v5 += 1;
			if ( voice_struct->m_vag_idx == 255 )
			{
				vmNoiseOff(v4);
			}
			else
			{
				_svm_cur.m_voice_idx = (u8)v4;
				_SsVmKeyOffNow();
			}
		}
	}
	return v5;
}

int _SsVmSeKeyOn(s16 vab_id, s16 prog, u16 note, int pitch, u16 voll, u16 volr)
{
	s16 unknown27;
	u16 voll_;

	(void)pitch;

	if ( voll == volr )
	{
		unknown27 = 64;
		voll_ = voll;
	}
	else if ( volr >= (unsigned int)voll )
	{
		voll_ = volr;
		unknown27 = 127 - (voll << 6) / volr;
	}
	else
	{
		voll_ = voll;
		unknown27 = (volr << 6) / voll;
	}
	return _SsVmKeyOn(33, vab_id, prog, note, voll_, unknown27);
}

int _SsVmSeKeyOff(s16 vab_id, s16 prog, s16 note)
{
	return _SsVmKeyOff(33, vab_id, prog, note);
}

void KeyOnCheck(void)
{
	;
}

// libsnd2/vm/vm_n2p.o

s16 note2pitch(void)
{
	u8 m_shift;

	m_shift = _svm_cur.m_shift;
	if ( (m_shift & 0x80u) != 0 )
		m_shift = 127;
	return SsPitchFromNote(_svm_cur.m_note, 0, _svm_cur.m_centre, m_shift);
}

s16 note2pitch2(s16 note, s16 fine)
{
	VagAtr *pVag;

	pVag = &_svm_tn[_svm_cur.m_tone + (_svm_cur.m_fake_program * 16)];
	return SsPitchFromNote(note, fine, pVag->center, pVag->shift);
}

u16 SsPitchFromNote(s16 note, s16 fine, u8 center, u8 shift)
{
	int shift_plus_fine;
	int shift_plus_fine_div_minus;
	unsigned int shift_plus_fine_div_minus_tmp;
	int shift_plus_fine_mod;
	int shift_plus_fine_mod_tmp;
	int shift_plus_fine_mul_minus;
	s16 v10;
	int v11;

	shift_plus_fine = (s16)(shift + fine);
	shift_plus_fine_div_minus = note + shift_plus_fine / 128 - center;
	shift_plus_fine_div_minus_tmp = shift_plus_fine_div_minus;
	shift_plus_fine_mod = shift_plus_fine % 128;
	shift_plus_fine_mod_tmp = shift_plus_fine_mod;
	if ( (shift_plus_fine_mod & 0x8000) != 0 )
	{
		shift_plus_fine_mod_tmp = shift_plus_fine_mod + 128;
		shift_plus_fine_div_minus_tmp = shift_plus_fine_div_minus - 1 + (s16)(shift_plus_fine_mod + 128) / 128;
	}
	shift_plus_fine_mul_minus = ((int)((u64)(0x2AAAAAABLL * (s16)shift_plus_fine_div_minus_tmp) >> 32) >> 1)
														- ((int)(shift_plus_fine_div_minus_tmp << 16 >> 31));
	v10 = (s16)shift_plus_fine_div_minus_tmp / 12 - 2;
	v11 = (s16)shift_plus_fine_div_minus_tmp - 12 * shift_plus_fine_mul_minus;
	if ( (v11 & 0x8000) != 0 )
	{
		v11 += 12;
		v10 = shift_plus_fine_mul_minus - 3;
	}
	if ( v10 >= 0 )
		return 0x3FFF;
	return (unsigned int)(((_svm_ntable[v11] * _svm_ftable[shift_plus_fine_mod_tmp]) >> 16) + (1 << (-v10 - 1))) >> -v10;
}

// libsnd2/vm/vm_no1.o

void vmNoiseOn(u8 vc)
{
	unsigned int right_vol_calc;
	libsnd2_sequence_struct_t *score_struct;
	unsigned int left_vol_calc;
	unsigned int left_vol_final;
	unsigned int right_vol_final;
	int v8;
	int v9;
	int v11;
	libsnd2_spu_voice_t *voice_struct;

	right_vol_calc = _svm_cur.m_voll * 0x3FFF * _svm_vh->mvol / 0x3F01 * _svm_cur.m_mvol * _svm_cur.m_vol / 0x3F01u;
	left_vol_calc = right_vol_calc;
	score_struct = NULL;
	if ( _svm_cur.m_seq_sep_no != 33 )
	{
		score_struct = &_ss_score[(_svm_cur.m_seq_sep_no & 0xFF)][(_svm_cur.m_seq_sep_no & 0xFF00) >> 8];
	}
	if ( score_struct != NULL )
	{
		left_vol_calc = right_vol_calc * (u16)score_struct->m_voll / 0x7F;
		right_vol_calc = right_vol_calc * (u16)score_struct->m_volr / 0x7F;
	}
	if ( (unsigned int)_svm_cur.m_pan >= 0x40 )
	{
		right_vol_final = right_vol_calc;
		left_vol_final = left_vol_calc * (127 - _svm_cur.m_pan) / 0x3F;
	}
	else
	{
		left_vol_final = left_vol_calc;
		right_vol_final = right_vol_calc * _svm_cur.m_pan / 0x3F;
	}
	if ( (unsigned int)_svm_cur.m_mpan >= 0x40 )
		left_vol_final = left_vol_final * (127 - _svm_cur.m_mpan) / 0x3F;
	else
		right_vol_final = right_vol_final * _svm_cur.m_mpan / 0x3F;
	if ( (unsigned int)_svm_cur.m_unk05 >= 0x40 )
		left_vol_final = left_vol_final * (127 - _svm_cur.m_unk05) / 0x3F;
	else
		right_vol_final = _svm_cur.m_unk05 * right_vol_final / 0x3F;
	if ( _svm_stereo_mono == 1 )
	{
		if ( left_vol_final >= right_vol_final )
			right_vol_final = left_vol_final;
		else
			left_vol_final = right_vol_final;
	}
	if ( score_struct != NULL )
	{
		left_vol_final = left_vol_final * left_vol_final / 0x3FFF;
		right_vol_final = right_vol_final * right_vol_final / 0x3FFF;
	}
	SpuSetNoiseClock((_svm_cur.m_note - _svm_cur.m_centre) & 0x3F);
	_svm_sreg_buf[vc].m_vol_left = left_vol_final;
	_svm_sreg_buf[vc].m_vol_right = right_vol_final;
	_svm_sreg_dirty[vc] |= 3;
	if ( vc >= 0x10u )
	{
		v8 = 0;
		v9 = 1 << (vc - 16);
	}
	else
	{
		v8 = 1 << vc;
		v9 = 0;
	}
	voice_struct = &_svm_voice[vc];
	voice_struct->m_pitch = 10;
	for ( v11 = 0; (s16)v11 < _SsVmMaxVoice; v11 += 1 )
	{
		if ( (_snd_vmask & (1 << v11)) == 0 )
		{
			libsnd2_spu_voice_t *voice_struct_1;

			voice_struct_1 = &_svm_voice[v11];
			voice_struct_1->m_unk1d &= 1u;
		}
	}
	voice_struct->m_unk1d = 2;
	_svm_okon1 |= v8;
	_svm_okon2 |= v9;
	_svm_okof1 &= ~_svm_okon1;
	_svm_okof2 &= ~_svm_okon2;
	if ( (_svm_cur.m_mode & 4) != 0 )
	{
		_svm_orev1 |= v8;
		_svm_orev2 |= v9;
	}
	else
	{
		_svm_orev1 &= ~(u16)v8;
		_svm_orev2 &= ~(u16)v9;
	}
	_svm_onos1 = v8;
	_svm_onos2 = v9;
}

// libsnd2/vm/vm_no2.o

void vmNoiseOn2(u8 vc, u16 voll, u16 volr, u16 arg3, u16 arg4)
{
	int vc_mask_tmp1;
	int vc_mask_tmp2;
	u16 okon1_tmp;
	u16 okon2_tmp;
	libsnd2_spu_voice_t *voice_struct;

	(void)arg3;
	(void)arg4;

	voice_struct = &_svm_voice[vc];
	_svm_sreg_buf[vc].m_vol_left = voll;
	_svm_sreg_buf[vc].m_vol_right = volr;
	_svm_sreg_dirty[vc] |= 3;
	if ( vc >= 0x10u )
	{
		vc_mask_tmp1 = 0;
		vc_mask_tmp2 = 1 << (vc - 16);
	}
	else
	{
		vc_mask_tmp1 = 1 << vc;
		vc_mask_tmp2 = 0;
	}
	voice_struct->m_pitch = 10;
	voice_struct->m_unk1d = 2;
	okon1_tmp = _svm_okon1;
	okon2_tmp = _svm_okon2;
	voice_struct->m_unk02 = 0;
	_svm_okon1 = okon1_tmp | vc_mask_tmp1;
	_svm_okon2 = okon2_tmp | vc_mask_tmp2;
	_svm_okof1 &= ~(okon1_tmp | vc_mask_tmp1);
	_svm_okof2 &= ~(okon2_tmp | vc_mask_tmp2);
	SpuSetNoiseVoice(SPU_ON, ((u8)vc_mask_tmp2 << 16) | (u16)vc_mask_tmp1);
}

// libsnd2/vm/vm_noff.o

void vmNoiseOff(u8 vc)
{
	libsnd2_spu_voice_t *voice_struct;

	voice_struct = &_svm_voice[vc];
	voice_struct->m_unk1d = 0;
	voice_struct->m_vag_idx = 0;
	voice_struct->m_pitch = 0;
}

// libsnd2/vm/vm_noise.o

void _SsVmNoiseOnWithAdsr(s32 voll, s32 volr, s32 arg2, s32 arg3)
{
	int voice_idx_tmp;

	_svm_cur.m_prior = 127;
	voice_idx_tmp = (u8)_SsVmAlloc();
	_svm_cur.m_voice_idx = voice_idx_tmp;
	if ( voice_idx_tmp < _SsVmMaxVoice )
		vmNoiseOn2(_svm_cur.m_voice_idx, voll, volr, arg2, arg3);
}

void _SsVmNoiseOff(void)
{
	int v0;

	for ( v0 = 0; (s16)v0 < _SsVmMaxVoice; v0 += 1 )
	{
		if ( (_snd_vmask & (1 << v0)) == 0 )
		{
			const libsnd2_spu_voice_t *voice_struct;

			voice_struct = &_svm_voice[v0];
			if ( voice_struct->m_unk1d == 2 )
			{
				vmNoiseOff(v0);
			}
		}
	}
}

void _SsVmNoiseOn(u16 voll, u16 volr)
{
	_SsVmNoiseOnWithAdsr(voll, volr, 0x80ff, 0x5fc8);
}

// libsnd2/vm/vm_nowof.o

void _SsVmKeyOffNow(void)
{
	int bits_upper;
	int bits_lower;
	int m_voice_idx;
	u16 okof1_tmp;
	u16 okof2_tmp;
	libsnd2_spu_voice_t *voice_struct;

	m_voice_idx = (u16)_svm_cur.m_voice_idx;
	if ( (u16)m_voice_idx >= 0x10u )
	{
		bits_upper = 0;
		bits_lower = 1 << ((m_voice_idx & 0xFF) - 16);
	}
	else
	{
		bits_upper = 1 << (m_voice_idx & 0xFF);
		bits_lower = 0;
	}
	voice_struct = &_svm_voice[m_voice_idx];
	voice_struct->m_unk1d = 0;
	okof1_tmp = _svm_okof1;
	okof2_tmp = _svm_okof2;
	voice_struct->m_pitch = 0;
	voice_struct->m_vag_idx = 0;
	_svm_okof1 = okof1_tmp | bits_upper;
	_svm_okon1 &= ~(okof1_tmp | bits_upper);
	_svm_okof2 = okof2_tmp | bits_lower;
	_svm_okon2 &= ~(okof2_tmp | bits_lower);
}

// libsnd2/vm/vm_nowon.o

void _SsVmKeyOnNow(s16 vag_count, s16 pitch)
{
	u16 m_voice_idx;
	unsigned int left;
	libsnd2_sequence_struct_t *score_struct;
	unsigned int left_tmp2;
	unsigned int right_tmp;
	unsigned int left_tmp;
	int bits_lower;
	int bits_upper;
	libsnd2_spu_voice_t *voice_struct;

	(void)vag_count;

	m_voice_idx = _svm_cur.m_voice_idx;
	left = _svm_cur.m_voll * 0x3FFF * _svm_vh->mvol / 0x3F01 * _svm_cur.m_mvol * _svm_cur.m_vol / 0x3F01u;
	left_tmp2 = left;
	score_struct = NULL;
	if ( _svm_cur.m_seq_sep_no != 33 )
	{
		score_struct = &_ss_score[(_svm_cur.m_seq_sep_no & 0xFF)][(_svm_cur.m_seq_sep_no & 0xFF00) >> 8];
	}
	if ( score_struct != NULL )
	{
		left_tmp2 = left * (u16)score_struct->m_voll / 0x7F;
		left = left * (u16)score_struct->m_volr / 0x7F;
	}
	if ( (u8)_svm_cur.m_pan >= 0x40u )
	{
		left_tmp = left;
		right_tmp = left_tmp2 * (127 - (u8)_svm_cur.m_pan) / 0x3F;
	}
	else
	{
		right_tmp = left_tmp2;
		left_tmp = left * (u8)_svm_cur.m_pan / 0x3F;
	}
	if ( (u8)_svm_cur.m_mpan >= 0x40u )
		right_tmp = right_tmp * (127 - (u8)_svm_cur.m_mpan) / 0x3F;
	else
		left_tmp = left_tmp * (u8)_svm_cur.m_mpan / 0x3F;
	if ( (u8)_svm_cur.m_unk05 >= 0x40u )
		right_tmp = right_tmp * (127 - (u8)_svm_cur.m_unk05) / 0x3F;
	else
		left_tmp = left_tmp * (u8)_svm_cur.m_unk05 / 0x3F;
	if ( _svm_stereo_mono == 1 )
	{
		if ( right_tmp >= left_tmp )
			left_tmp = right_tmp;
		else
			right_tmp = left_tmp;
	}
	if ( score_struct != NULL )
	{
		right_tmp = right_tmp * right_tmp / 0x3FFF;
		left_tmp = left_tmp * left_tmp / 0x3FFF;
	}
	_svm_sreg_buf[m_voice_idx].m_pitch = pitch;
	_svm_sreg_buf[m_voice_idx].m_vol_left = right_tmp;
	_svm_sreg_buf[m_voice_idx].m_vol_right = left_tmp;
	_svm_sreg_dirty[_svm_cur.m_voice_idx] |= 7u;
	voice_struct = &_svm_voice[_svm_cur.m_voice_idx];
	voice_struct->m_pitch = pitch;
	if ( _svm_cur.m_voice_idx >= 16 )
	{
		bits_lower = 0;
		bits_upper = 1 << ((_svm_cur.m_voice_idx & 0xFF) - 16);
	}
	else
	{
		bits_lower = 1 << (_svm_cur.m_voice_idx & 0xFF);
		bits_upper = 0;
	}
	if ( (_svm_cur.m_mode & 4) != 0 )
	{
		_svm_orev1 |= bits_lower;
		_svm_orev2 |= bits_upper;
	}
	else
	{
		_svm_orev1 &= ~(u16)bits_lower;
		_svm_orev2 &= ~(u16)bits_upper;
	}
	_svm_onos1 &= ~(u16)bits_lower;
	_svm_okon2 |= bits_upper;
	_svm_onos2 &= ~(u16)bits_upper;
	_svm_okon1 |= bits_lower;
	_svm_okof1 &= ~_svm_okon1;
	_svm_okof2 &= ~_svm_okon2;
}

// libsnd2/vm/vm_pb.o

int _SsVmPBVoice(s16 vc, s16 seq_sep_num, s16 vab_id, s16 prog, s16 pitch)
{
	s16 pitch_converted;
	int bend_min;
	int bend_max;
	libsnd2_spu_voice_t *voice_struct;

	voice_struct = &_svm_voice[vc];
	if ( voice_struct->m_seq_sep_no != seq_sep_num || voice_struct->m_vab_id != vab_id || voice_struct->m_prog != prog )
	{
		return 0;
	}
	pitch_converted = pitch - 64;
	bend_min = (u16)voice_struct->m_note;
	if ( pitch_converted <= 0 )
	{
		if ( pitch_converted >= 0 )
		{
			bend_max = 0;
		}
		else
		{
			int pbmin_tmp;

			pbmin_tmp = pitch_converted * _svm_tn[(u16)(voice_struct->m_tone + 16 * _svm_cur.m_fake_program)].pbmin;
			bend_min = bend_min + pbmin_tmp / 64 - 1;
			bend_max = 2 * (pbmin_tmp % 64) + 127;
		}
	}
	else
	{
		int pbmax_tmp;

		pbmax_tmp = pitch_converted * _svm_tn[(u16)(voice_struct->m_tone + 16 * _svm_cur.m_fake_program)].pbmax;
		bend_min += pbmax_tmp / 63;
		bend_max = 2 * (pbmax_tmp % 63);
	}
	_svm_cur.m_voice_idx = vc;
	_svm_cur.m_tone = voice_struct->m_tone;
	_svm_sreg_buf[vc].m_pitch = note2pitch2(bend_min, bend_max);
	_svm_sreg_dirty[vc] |= 4;
	return 1;
}

int _SsVmPitchBend(s16 seq_sep_no, int vab_id, int prog, s16 pitch)
{
	int voice_i_tmp;
	int voice_offs_tmp;

	_SsVmVSetUp(vab_id, prog);
	_svm_cur.m_seq_sep_no = seq_sep_no;
	voice_offs_tmp = 0;
	for ( voice_i_tmp = 0; (s16)voice_i_tmp < _SsVmMaxVoice; voice_i_tmp += 1 )
	{
		voice_offs_tmp += (s16)_SsVmPBVoice(voice_i_tmp, seq_sep_no, vab_id, prog, pitch);
	}
	return voice_offs_tmp;
}

// libsnd2/vm/vm_prog.o

void _SsVmSetProgVol(s16 vab_id, s16 prog, u8 vol)
{
	if ( !_SsVmVSetUp(vab_id, prog) )
		_svm_pg[prog].mvol = vol;
}

int _SsVmGetProgVol(s16 vab_id, s16 prog)
{
	if ( _SsVmVSetUp(vab_id, prog) != 0 )
		return -1;
	return _svm_pg[prog].mvol;
}

int _SsVmSetProgPan(s16 vab_id, s16 prog, char mpan)
{
	if ( _SsVmVSetUp(vab_id, prog) != 0 )
	{
		return -1;
	}
	_svm_pg[prog].mpan = mpan;
	return _svm_pg[prog].mpan;
}

int _SsVmGetProgPan(s16 vab_id, s16 prog)
{
	if ( _SsVmVSetUp(vab_id, prog) != 0 )
		return -1;
	return _svm_pg[prog].mpan;
}

// libsnd2/vm/vm_seq.o

void _SsVmSetSeqVol(s16 seq_sep_num, s16 voll, s16 volr)
{
	libsnd2_sequence_struct_t *score_struct;
	int v5;
	int m_vab_id;
	const VagAtr *vag_attr_ptr;
	unsigned int vol_factor;
	unsigned int voll_val;
	unsigned int pan;
	unsigned int volr_val;
	unsigned int mpan;
	unsigned int m_pan;

	score_struct = &_ss_score[(u8)seq_sep_num][(seq_sep_num & 0xFF00) >> 8];
	score_struct->m_voll = voll;
	score_struct->m_volr = volr;
	if ( (u16)voll >= 0x7Fu )
		score_struct->m_voll = 127;
	if ( (u16)score_struct->m_volr >= 0x7Fu )
		score_struct->m_volr = 127;
	for ( v5 = 0; (s16)v5 < _SsVmMaxVoice; v5 += 1 )
	{
		if ( (_snd_vmask & (1 << v5)) == 0 )
		{
			libsnd2_spu_voice_t *voice_struct;

			voice_struct = &_svm_voice[(s16)v5];
			if ( voice_struct->m_seq_sep_no == seq_sep_num )
			{
				m_vab_id = voice_struct->m_vab_id;
				if ( m_vab_id == (char)score_struct->m_vab_id )
				{
					_SsVmVSetUp(m_vab_id, voice_struct->m_fake_program);
					vag_attr_ptr = &_svm_tn[16 * voice_struct->m_fake_program + voice_struct->m_tone];
					vol_factor = _svm_vh->mvol * 0x3FFF
										 * (voice_struct->m_voll1 * score_struct->m_vol[voice_struct->m_channel_idx] / 127) / 0x3F01
										 * _svm_pg[voice_struct->m_prog].mvol * vag_attr_ptr->vol;
					voll_val = vol_factor / 0x3F01 * (u16)score_struct->m_voll / 0x7F;
					pan = vag_attr_ptr->pan;
					volr_val = vol_factor / 0x3F01 * (u16)score_struct->m_volr / 0x7F;
					if ( pan >= 0x40 )
						voll_val = voll_val * (127 - pan) / 0x3F;
					else
						volr_val = volr_val * pan / 0x3F;
					mpan = _svm_pg[voice_struct->m_prog].mpan;
					if ( mpan >= 0x40 )
						voll_val = (int)((u16)voll_val * (127 - mpan)) / 63;
					else
						volr_val = (unsigned int)((u64)(2181570691LL * (int)((u16)volr_val * mpan)) >> 32) >> 5;
					m_pan = (u8)voice_struct->m_pan;
					if ( m_pan >= 0x40 )
						voll_val = (int)((u16)voll_val * (127 - m_pan)) / 63;
					else
						volr_val = (unsigned int)((u64)(2181570691LL * (int)((u16)volr_val * m_pan)) >> 32) >> 5;
					if ( _svm_stereo_mono == 1 )
					{
						if ( (u16)voll_val >= (unsigned int)(u16)volr_val )
							volr_val = voll_val & 0xFFFF;
						else
							voll_val = volr_val & 0xFFFF;
					}
					_svm_sreg_dirty[(s16)v5] |= 3u;
					_svm_sreg_buf[(s16)v5].m_vol_left = (u16)voll_val * (u16)voll_val / 0x3FFF;
					_svm_sreg_buf[(s16)v5].m_vol_right = (s16)(volr_val * volr_val) / 0x3FFF;
				}
			}
		}
	}
}

void _SsVmGetSeqVol(s16 seq_sep_no, s16 *voll_ptr, s16 *volr_ptr)
{
	const libsnd2_sequence_struct_t *score_struct;

	_svm_cur.m_seq_sep_no = seq_sep_no;
	score_struct = &_ss_score[(u8)seq_sep_no][(seq_sep_no & 0xFF00) >> 8];
	*voll_ptr = score_struct->m_voll;
	*volr_ptr = score_struct->m_volr;
}

int _SsVmGetSeqLVol(s16 seq_sep_no)
{
	const libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[(u8)seq_sep_no][(seq_sep_no & 0xFF00) >> 8];
	_svm_cur.m_seq_sep_no = seq_sep_no;
	return score_struct->m_voll;
}

int _SsVmGetSeqRVol(s16 seq_sep_no)
{
	const libsnd2_sequence_struct_t *score_struct;

	score_struct = &_ss_score[(u8)seq_sep_no][(seq_sep_no & 0xFF00) >> 8];
	_svm_cur.m_seq_sep_no = seq_sep_no;
	return score_struct->m_volr;
}

void _SsVmSeqKeyOff(s16 seq_sep_no)
{
	u8 cur_voice_tmp;

	for ( cur_voice_tmp = 0; cur_voice_tmp < _SsVmMaxVoice; cur_voice_tmp += 1 )
	{
		const libsnd2_spu_voice_t *voice_struct;

		voice_struct = &_svm_voice[cur_voice_tmp];
		if ( (_snd_vmask & (1 << cur_voice_tmp)) == 0 && voice_struct->m_seq_sep_no == seq_sep_no )
		{
			_svm_cur.m_voice_idx = cur_voice_tmp;
			_SsVmKeyOffNow();
		}
	}
}

// libsnd2/vm/vm_spb.o

void SePitchBend(u8 vc, s16 arg1)
{
	char v8;
	int tone;
	int note;
	int pbend;
	const libsnd2_spu_voice_t *voice_struct;

	if ( vc >= 0x18 )
	{
		return;
	}
	voice_struct = &_svm_voice[vc];
	_svm_cur.m_fake_program = voice_struct->m_fake_program;
	v8 = voice_struct->m_tone;
	_svm_cur.m_voice_idx = vc;
	_svm_cur.m_tone = v8;
	tone = v8 + ((u8)_svm_cur.m_fake_program * 16);
	if ( arg1 < 0 )
	{
		int v13;

		v13 = arg1 * _svm_tn[tone].pbmin;
		pbend = v13 / 127 + 127;
		note = voice_struct->m_note + v13 / 127 - 1;
	}
	else
	{
		int v10;

		v10 = arg1 * _svm_tn[tone].pbmax;
		note = voice_struct->m_note + v10 / 127;
		pbend = v10 % 127;
	}
	_svm_sreg_buf[vc].m_pitch = note2pitch2(note, pbend);
	_svm_sreg_dirty[vc] |= 4;
}

// libsnd2/vm/vm_stav.o

s16 _SsVmSelectToneAndVag(u8 *vag_attr_idx_ptr, u8 *vag_nums_ptr)
{
	u8 idx;
	int v4;
	const VagAtr *v6;

	idx = 0;
	for ( v4 = 0; (char)v4 < _svm_cur.m_sep_sep_no_tonecount; v4 += 1 )
	{
		v6 = &_svm_tn[16 * _svm_cur.m_fake_program + v4];
		if ( _svm_cur.m_note >= (int)v6->min )
		{
			if ( v6->max >= _svm_cur.m_note )
			{
				vag_nums_ptr[idx] = v6->vag;
				vag_attr_idx_ptr[(u8)idx] = v4;
				idx += 1;
			}
		}
	}
	return idx;
}

// libsnd2/vm/vm_vib.o

void SeVibOn(void)
{
	;
}

static void SeVibOff(void)
{
	;
}

void SetVib(void)
{
	;
}

void SsUtVibrateOn(void)
{
	;
}

void SsUtVibrateOff(void)
{
	SeVibOff();
}

// libsnd2/vm/vm_vol.o

int _SsVmSetVol(s16 seq_sep_no, s16 vab_id, s16 prog, s16 voll, s16 volr)
{
	int v7;
	u8 volr_tmp;
	libsnd2_sequence_struct_t *score_struct;
	int v13;
	int v20;
	const VagAtr *vag_attr_ptr;
	unsigned int volcalc;
	unsigned int left_vol;
	unsigned int pan;
	unsigned int right_vol;
	unsigned int mpan;
	unsigned int vol_selfmul;

	v7 = 0;
	volr_tmp = volr;
	score_struct = &_ss_score[(u8)seq_sep_no][(seq_sep_no & 0xFF00) >> 8];
	_SsVmVSetUp(vab_id, prog);
	_svm_cur.m_seq_sep_no = seq_sep_no;
	if ( !volr )
		volr_tmp = 1;
	if ( !voll )
		voll = 1;
	for ( v13 = 0; (s16)v13 < _SsVmMaxVoice; v13 += 1 )
	{
		if ( (_snd_vmask & (1 << v13)) == 0 )
		{
			const libsnd2_spu_voice_t *voice_struct;

			voice_struct = &_svm_voice[(s16)v13];
			if (
				voice_struct->m_seq_sep_no == seq_sep_no && voice_struct->m_prog == prog && voice_struct->m_vab_id == vab_id )
			{
				v20 = score_struct->m_vol[score_struct->m_channel_idx];
				if ( (v20 != 0) || (v20 != (u16)voll) )
				{
					vag_attr_ptr = &_svm_tn[16 * voice_struct->m_fake_program + voice_struct->m_tone];
					volcalc = voice_struct->m_voll1 * (u16)voll / 127 * 0x3FFF * _svm_vh->mvol / 0x3F01 * _svm_pg[prog].mvol
									* vag_attr_ptr->vol;
					left_vol = volcalc / 0x3F01 * (u16)score_struct->m_voll / 0x7F;
					pan = vag_attr_ptr->pan;
					right_vol = volcalc / 0x3F01 * (u16)score_struct->m_volr / 0x7F;
					if ( pan >= 0x40 )
						left_vol = left_vol * (127 - pan) / 0x3F;
					else
						right_vol = right_vol * pan / 0x3F;
					mpan = _svm_pg[voice_struct->m_prog].mpan;
					if ( mpan >= 0x40 )
						left_vol = left_vol * (127 - mpan) / 0x3F;
					else
						right_vol = right_vol * _svm_pg[voice_struct->m_prog].mpan / 0x3F;
					if ( volr_tmp >= 0x40u )
						left_vol = left_vol * (127 - volr_tmp) / 0x3F;
					else
						right_vol = right_vol * volr_tmp / 0x3F;
					vol_selfmul = left_vol * left_vol;
					if ( _svm_stereo_mono == 1 )
					{
						if ( left_vol >= right_vol )
							right_vol = left_vol;
						else
							left_vol = right_vol;
						vol_selfmul = left_vol * left_vol;
					}
					v7 += 1;
					_svm_sreg_dirty[(s16)v13] |= 3u;
					_svm_sreg_buf[(s16)v13].m_vol_left = vol_selfmul / 0x3FFF;
					_svm_sreg_buf[(s16)v13].m_vol_right = right_vol * right_vol / 0x3FFF;
				}
				if ( v20 != 0 )
				{
					score_struct->m_vol[score_struct->m_channel_idx] = 1;
				}
			}
		}
	}
	return v7;
}

// libsnd2/vm/vm_vsu.o

int _SsVmVSetUp(s16 vab_id, s16 prog)
{
	if ( (u16)vab_id >= 0x10u )
		return -1;
	if ( _svm_vab_used[vab_id] != 1 )
		return -1;
	if ( prog >= kMaxPrograms )
		return -1;
	_svm_cur.m_vab_id = vab_id;
	_svm_cur.m_program = prog;
	_svm_tn = _svm_vab_tn[vab_id];
	_svm_vh = _svm_vab_vh[vab_id];
	_svm_pg = _svm_vab_pg[vab_id];
	_svm_cur.m_fake_program = _svm_pg[prog].m_fake_prog_idx;
	return 0;
}

// libsnd2/vm/vs_auto.o

void SsSetAutoKeyOffMode(s16 mode)
{
	_svm_auto_kof_mode = mode;
}

// libsnd2/vm/vs_mono.o

void SsSetMono(void)
{
	_svm_stereo_mono = 1;
}

void SsSetStereo(void)
{
	_svm_stereo_mono = 0;
}

// libsnd2/vm/vs_srv.o

char SsSetReservedVoice(char voices)
{
	if ( (u8)(voices - 1) >= 0x18u )
		return -1;
	_SsVmMaxVoice = voices;
	return voices;
}

// libsnd2/vm/vs_vab.o

void SsVabClose(s16 vab_id)
{
	if ( (u16)vab_id >= 0x10u )
	{
		return;
	}
	if ( (u8)_svm_vab_used[vab_id] >= 3u )
	{
		return;
	}
	if ( _svm_vab_used[vab_id] == 0 )
	{
		return;
	}
	SpuFree(_svm_vab_start[vab_id]);
	_svm_vab_used[vab_id] = 0;
	_svm_vab_count -= 1;
	if ( _spu_getInTransfer() == 1 )
		_spu_setInTransfer(0);
}

// libsnd2/vm/vs_vfb.o

s16 SsVabFakeBody(s16 vab_id)
{
	if ( (u16)vab_id >= 0x11u )
		return -1;
	if ( _svm_vab_used[vab_id] != 2 )
		return -1;
	_spu_setInTransfer(0);
	_svm_vab_used[vab_id] = 1;
	return vab_id;
}

// libsnd2/vm/vs_vh.o

static int VsGetAddr(unsigned int size_in_bytes, int mode, s16 vab_id);

s16 SsVabOpenHeadSticky(u8 *addr, s16 vab_id, unsigned int sbaddr)
{
	return _SsVabOpenHeadWithMode(addr, vab_id, VsGetAddr, sbaddr);
}

s16 SsVabFakeHead(u8 *addr, s16 vab_id, unsigned int sbaddr)
{
	return _SsVabOpenHeadWithMode(addr, vab_id, VsGetAddr, sbaddr);
}

static int VsGetAddr(unsigned int size_in_bytes, int mode, s16 vab_id)
{
	(void)size_in_bytes;
	(void)vab_id;

	return mode;
}

int _SsVabOpenHeadWithMode(u8 *addr, int vab_id, libsnd2_vab_allocate_callback alloc_fn, int mode)
{
	int vab_id_tmp;
	const VabHdr *vab_hdr_ptr;
	unsigned int form_chk;
	ProgAtr *prog_atr_ptr;
	s16 maxPrograms;
	VagAtr *vag_attr_ptr1;
	int v21;
	ProgAtr *v24;
	int v27;
	VagAtr *vag_attr_ptr2;
	int v31;
	int v32;
	int vag_idx;
	int vag_lens[256];

	vab_id_tmp = 16;
	if ( _spu_getInTransfer() == 1 )
		return -1;
	_spu_setInTransfer(1);
	if ( (s16)vab_id < 16 )
	{
		if ( (s16)vab_id == -1 )
		{
			int v11;

			for ( v11 = 0; v11 < 16; v11 += 1 )
			{
				if ( _svm_vab_used[v11] == 0 )
				{
					_svm_vab_used[v11] = 1;
					vab_id_tmp = v11;
					_svm_vab_count += 1;
					break;
				}
			}
		}
		else
		{
			if ( _svm_vab_used[(s16)vab_id] == 0 )
			{
				_svm_vab_used[(s16)vab_id] = 1;
				vab_id_tmp = vab_id;
				_svm_vab_count += 1;
			}
		}
	}
	if ( vab_id_tmp >= 16 )
	{
		_spu_setInTransfer(0);
		return -1;
	}
	_svm_vab_count += 1;
	_svm_vab_vh[vab_id_tmp] = (VabHdr *)addr;
	vab_hdr_ptr = (VabHdr *)addr;
	form_chk = *(u32 *)addr;
	_svm_vab_not_send_size = 0;
	prog_atr_ptr = (ProgAtr *)(addr + 32);
	maxPrograms = 64;
	for ( ;; )
	{
		int fake_prog_idx;
		int total_vags_size;
		unsigned int rounded_size;
		unsigned int spu_alloc_mem;
		int total_vag_size_1;

		if ( form_chk >> 8 != 0x564142 )
		{
			break;
		}
		if ( (u8)form_chk == 112 )
		{
			if ( *((int *)addr + 1) >= 5 )
				maxPrograms = 128;
		}
		kMaxPrograms = maxPrograms;
		if ( maxPrograms < (int)*((u16 *)addr + 9) )
		{
			break;
		}
		_svm_vab_pg[vab_id_tmp] = prog_atr_ptr;
		vag_attr_ptr1 = (VagAtr *)&prog_atr_ptr[maxPrograms];
		fake_prog_idx = 0;
		for ( v21 = 0; v21 < maxPrograms; v21 += 1 )
		{
			v24 = &prog_atr_ptr[v21];
			v24->m_fake_prog_idx = fake_prog_idx;
			if ( v24->tones )
				fake_prog_idx += 1;
		}
		total_vags_size = 0;
		_svm_vab_tn[vab_id_tmp] = vag_attr_ptr1;
		vag_attr_ptr2 = &vag_attr_ptr1[16 * vab_hdr_ptr->ps];
		for ( v27 = 0; v27 < 256; v27 += 1 )
		{
			if ( vab_hdr_ptr->vs >= v27 )
			{
				v31 = *(u16 *)&vag_attr_ptr2->prior;
				v32 = 4 * v31;
				if ( vab_hdr_ptr->ver >= 5 )
					v32 = 8 * v31;
				vag_lens[v27] = v32;
				total_vags_size += vag_lens[v27];
			}
			vag_attr_ptr2 = (VagAtr *)((char *)vag_attr_ptr2 + 2);
		}
		rounded_size = (total_vags_size + 63) & ~63;
		spu_alloc_mem = alloc_fn(rounded_size, mode, (s16)vab_id_tmp);
		if ( spu_alloc_mem == 0xFFFFFFFF )
		{
			return -1;
		}
		gVabOffet[(s16)vab_id_tmp] = spu_alloc_mem > 0xFFFFF;
		if ( spu_alloc_mem + rounded_size > 0x1FAFF0 )
		{
			break;
		}
		_svm_vab_start[(s16)vab_id_tmp] = spu_alloc_mem;
		total_vag_size_1 = 0;
		for ( vag_idx = 0; vag_idx <= vab_hdr_ptr->vs; vag_idx += 1 )
		{
			total_vag_size_1 += vag_lens[vag_idx];
			if ( (vag_idx & 1) != 0 )
				prog_atr_ptr[vag_idx / 2].m_vag_spu_addr_lo = (spu_alloc_mem + total_vag_size_1) >> 4;
			else
				prog_atr_ptr[vag_idx / 2].m_vag_spu_addr_hi = (spu_alloc_mem + total_vag_size_1) >> 4;
		}
		_svm_vab_total[(s16)vab_id_tmp] = total_vag_size_1;
		_svm_vab_used[(s16)vab_id_tmp] = 2;
		return (s16)vab_id_tmp;
	}
	_svm_vab_used[vab_id_tmp] = 0;
	_spu_setInTransfer(0);
	_svm_vab_count -= 1;
	return -1;
}

// libsnd2/vm/vs_vh2.o

static int VsGetAddrSpuMalloc(unsigned int size_in_bytes, int mode, s16 vab_id);

s16 SsVabOpenHead(u8 *addr, s16 vab_id)
{
	return _SsVabOpenHeadWithMode(addr, vab_id, VsGetAddrSpuMalloc, 0);
}

static int VsGetAddrSpuMalloc(unsigned int size_in_bytes, int mode, s16 vab_id)
{
	int result;

	(void)mode;

	result = SpuMalloc(size_in_bytes);
	if ( result == -1 )
	{
		_svm_vab_used[vab_id] = 0;
		_spu_setInTransfer(0);
		_svm_vab_count -= 1;
	}
	return result;
}

// libsnd2/vm/vs_vt.o

s16 SsVabTransfer(u8 *vh_addr, u8 *vb_addr, s16 vab_id, s16 i_flag)
{
	s16 v6;
	int v8;

	v6 = SsVabOpenHead(vh_addr, vab_id);
	if ( v6 < 0 )
		return -1;
	v8 = SsVabTransBody(vb_addr, v6);
	if ( v8 < 0 )
	{
		return -2;
	}
	if ( i_flag != SS_IMMEDIATE )
	{
		SsVabTransCompleted(SS_WAIT_COMPLETED);
	}
	return v8;
}

// libsnd2/vm/vs_vtb.o

s16 SsVabTransBody(u8 *addr, s16 vab_id)
{
	if ( (u16)vab_id >= 0x11u || _svm_vab_used[vab_id] != 2 )
	{
		_spu_setInTransfer(0);
		return -1;
	}
	SpuSetTransferMode(SPU_TRANSFER_BY_DMA);
	if ( !SpuSetTransferStartAddr(_svm_vab_start[vab_id]) )
	{
		_spu_setInTransfer(0);
		return -1;
	}
	SpuWrite(addr, _svm_vab_total[vab_id]);
	_svm_vab_used[vab_id] = 1;
	return vab_id;
}

// libsnd2/vm/vs_vtbp.o

s16 SsVabTransBodyPartly(u8 *addr, unsigned int bufsize, s16 vab_id)
{
	unsigned int bufsize_tmp;
	int new_vabid;

	if ( (u16)vab_id >= 0x11u || _svm_vab_used[vab_id] != 2 )
	{
		_spu_setInTransfer(0);
		return -1;
	}
	if ( !_svm_vab_not_send_size )
	{
		vabid_old_2 = vab_id;
		_svm_vab_not_send_size = _svm_vab_total[vab_id];
		SpuSetTransferMode(SPU_TRANSFER_BY_DMA);
		if ( !SpuSetTransferStartAddr(_svm_vab_start[vab_id]) )
		{
			_svm_vab_not_send_size = 0;
			vabid_old_2 = -1;
			_spu_setInTransfer(0);
			return -1;
		}
	}
	new_vabid = vabid_old_2;
	if ( vabid_old_2 != vab_id )
	{
		_spu_setInTransfer(0);
		return -1;
	}
	bufsize_tmp = bufsize;
	if ( (unsigned int)_svm_vab_not_send_size < bufsize )
		bufsize_tmp = _svm_vab_not_send_size;
	_spu_setInTransfer(1);
	SpuWritePartly(addr, bufsize_tmp);
	_svm_vab_not_send_size -= bufsize_tmp;
	if ( _svm_vab_not_send_size != 0 )
	{
		return -2;
	}
	vabid_old_2 = -1;
	_svm_vab_not_send_size = 0;
	_svm_vab_used[new_vabid] = 1;
	return new_vabid;
}

// libsnd2/vm/vs_vtc.o

s16 SsVabTransCompleted(s16 immediate_flag)
{
	return SpuIsTransferCompleted(immediate_flag);
}

// libsnd2/vm/vm_aloc3.o

char SsBlockVoiceAllocation(void)
{
	if ( _snd_ev_flag == 1 )
		return -1;
	_snd_ev_flag = 1;
	return 1;
}

char SsUnBlockVoiceAllocation(void)
{
	if ( !_snd_ev_flag )
		return -1;
	_snd_ev_flag = 0;
	return 1;
}

int SsAllocateVoices(u8 voices, u8 priority)
{
	int v2;
	int v3;
	u16 v4;
	u16 v5;
	char v9;
	int m_priority;
	unsigned int m_key_stat;
	int v16;
	int v17;

	v3 = 0;
	for ( v2 = 0; (u8)v2 < (unsigned int)voices; v2 += 1 )
	{
		int m_unk02;
		char v7;
		char v8;

		v4 = -1;
		v5 = priority;
		m_unk02 = 0;
		v7 = 99;
		v8 = 99;
		for ( v9 = 0; (u8)v9 < _SsVmMaxVoice; v9 += 1 )
		{
			if ( ((1 << (u8)v9) & v3) == 0 )
			{
				libsnd2_spu_voice_t *voice_struct;

				voice_struct = &_svm_voice[(u8)v9];
				if ( !voice_struct->m_unk1d && !voice_struct->m_key_stat )
				{
					v8 = v9;
					break;
				}
				m_priority = voice_struct->m_priority;
				if ( m_priority >= v5 )
				{
					if ( m_priority == v5 )
					{
						m_key_stat = (u16)voice_struct->m_key_stat;
						if ( m_key_stat >= v4 )
						{
							if ( m_key_stat != v4 || m_unk02 >= voice_struct->m_unk02 )
								continue;
							m_unk02 = (u16)voice_struct->m_unk02;
						}
						else
						{
							m_unk02 = (u16)voice_struct->m_unk02;
							v4 = voice_struct->m_key_stat;
						}
						v7 = v9;
					}
				}
				else
				{
					v5 = voice_struct->m_priority;
					v4 = voice_struct->m_key_stat;
					m_unk02 = (u16)voice_struct->m_unk02;
					v7 = v9;
				}
			}
		}
		if ( v7 != 99 )
		{
			v3 |= 1 << v7;
		}
		else if ( v8 != 99 )
		{
			v3 |= 1 << v8;
		}
		else
		{
			return -1;
		}
	}
	v16 = voices;
	for ( v17 = 0; (u8)v17 < _SsVmMaxVoice; v17 += 1 )
	{
		libsnd2_spu_voice_t *voice_struct;

		voice_struct = &_svm_voice[(u8)v17];
		if ( ((1 << v17) & v3) != 0 )
		{
			v16 -= 1;
			voice_struct->m_unk02 = (u8)v16;
			voice_struct->m_priority = priority;
			voice_struct->m_b_auto_vol = 0;
			voice_struct->m_b_auto_pan = 0;
			if ( voice_struct->m_unk1d == 2 )
				SpuSetNoiseVoice(SPU_OFF, 1 << v17);
			voice_struct->m_unk1d = 1;
		}
		else
		{
			voice_struct->m_unk02 += voices;
		}
	}
	return v3;
}

// libsnd2/vm/q_keyon.o

void SsQueueKeyOn(int voices)
{
	int v1;

	for ( v1 = 0; (char)v1 < _SsVmMaxVoice; v1 += 1 )
	{
		int v4;

		v4 = 1 << v1;
		if ( (v4 & voices) != 0 )
		{
			if ( v1 >= 16 )
			{
				int v7;

				v7 = 1 << (v1 - 16);
				_svm_okon2 |= v7;
				_svm_okof2 &= ~(u16)v7;
			}
			else
			{
				_svm_okon1 |= v4;
				_svm_okof1 &= ~(u16)v4;
			}
		}
	}
}

void SsQueueReverb(int voices, int reverb)
{
	int v2;
	int v8;
	char v9;
	int v10;

	for ( v2 = 0; (char)v2 < 24; v2 += 1 )
	{
		int v5;

		v5 = 1 << v2;
		if ( (v5 & voices) != 0 )
		{
			v8 = v5 & reverb;
			if ( v2 >= 16 )
			{
				v9 = v2 - 16;
				if ( v8 == 0 )
					v10 = _svm_orev2 & ~(1 << v9);
				else
					v10 = _svm_orev2 | (1 << v9);
				_svm_orev2 = v10;
			}
			else
			{
				if ( v8 )
					_svm_orev1 |= v5;
				else
					_svm_orev1 &= ~(u16)v5;
			}
		}
	}
}

void SsQueueRegisters(int vc, SndRegisterAttr *sra)
{
	u32 mask;

	mask = sra->mask;
	printf("SsQueueRegisters \n");
	if ( mask == 0 )
		mask = 0xFFFFFFFF;
	if ( (mask & SND_VOLL) != 0 )
	{
		_svm_sreg_buf[vc].m_vol_left = sra->volume.left & ~0x8000;
		_svm_sreg_dirty[vc] |= 1;
	}
	if ( (mask & SND_VOLR) != 0 )
	{
		_svm_sreg_buf[vc].m_vol_right = sra->volume.right & ~0x8000;
		_svm_sreg_dirty[vc] |= 2;
	}
	if ( (mask & SND_ADSR1) != 0 )
	{
		_svm_sreg_buf[vc].m_adsr1 = sra->adsr1;
		_svm_sreg_dirty[vc] |= 0x10;
	}
	if ( (mask & SND_ADSR2) != 0 )
	{
		_svm_sreg_buf[vc].m_adsr2 = sra->adsr2;
		_svm_sreg_dirty[vc] |= 0x20;
	}
	if ( (mask & SND_PITCH) != 0 )
	{
		_svm_sreg_buf[vc].m_pitch = sra->pitch;
		_svm_sreg_dirty[vc] |= 4;
	}
	if ( (mask & SND_ADDR) != 0 )
	{
		_svm_sreg_buf2[vc].m_vag_spu_addr = sra->addr;
		_svm_sreg_dirty[vc] |= 8u;
	}
}

s16 SsGetActualProgFromProg(s16 vab_id, s16 prog)
{
	if ( !((u16)vab_id < 0x11u && prog >= 0 && kMaxPrograms >= prog) )
		return -1;
	return _svm_vab_pg[vab_id][prog].m_fake_prog_idx;
}

void SsSetVoiceSettings(int vc, const SndVoiceStats *snd_v_attr)
{
	libsnd2_spu_voice_t *voice_struct;

	voice_struct = &_svm_voice[vc];
	voice_struct->m_vag_idx = snd_v_attr->vagId;
	voice_struct->m_pitch = snd_v_attr->pitch;
	voice_struct->m_voll1 = snd_v_attr->vol;
	voice_struct->m_pan = snd_v_attr->pan;
	voice_struct->m_seq_sep_no = 33;
	voice_struct->m_note = snd_v_attr->note;
	voice_struct->m_fake_program = snd_v_attr->prog_actual;
	voice_struct->m_prog = snd_v_attr->prog_num;
	voice_struct->m_tone = snd_v_attr->tone;
	voice_struct->m_vab_id = snd_v_attr->vabId;
	voice_struct->m_voll2 = snd_v_attr->vol;
}

s16 SsVoiceCheck(int vc, int vab_id, s16 note)
{
	const libsnd2_spu_voice_t *voice_struct;

	if ( (unsigned int)vc >= 0x18 )
		return -1;
	voice_struct = &_svm_voice[vc];
	if ( voice_struct->m_vab_id != vab_id >> 8 )
		return -1;
	if ( voice_struct->m_prog != (u8)vab_id )
		return -1;
	if ( voice_struct->m_note != note )
		return -1;
	return 0;
}
