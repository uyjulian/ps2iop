/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include "defz.h"

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall start();
void __fastcall create_th(void *userdata);
void __fastcall sce_spu2_loop(void *userdata);
void *__fastcall spuFunc(unsigned int command, void *data, int size);
void __fastcall sceSifCmdLoop2();
void __fastcall DMA0CallBackProc(void);
void __fastcall DMA1CallBackProc(void);
void __fastcall IRQCallBackProc(void);
void __fastcall spustCB_preparation_finished(unsigned int voice_bit, int p_status);
void __fastcall spustCB_transfer_finished(unsigned int voice_bit, int t_status);
void __fastcall spustCB_stream_finished(unsigned int voice_bit, int s_status);
void __fastcall sce_spust_loop(void *userdata);
void spu2_config_iop_(void);
static void __fastcall spu2_config_SPDIF_(int flag);
void spu2_config_initialize_(void);
void spu2_config_initialize_typically_(void);
void spu2_config_initialize_hot_(void);
void spu2_config_before_compatible_(void);
int __fastcall spu_init_(int flag);
static void __fastcall spu_FwriteByIO_(void *addr, u32 size);
int __fastcall spu_FiDMA_(void *userdata);
int __fastcall spu_FiAutoDMA_(void *userdata);
void __fastcall spu_Fr__(void *data, int addr, u32 size);
int spu_t_(int count, ...);
int __fastcall spu_Fw_(void *addr, u32 size);
int spu_StopAutoDMA_(void);
int spu_AutoDMAGetStatus_(void);
unsigned int __fastcall spu_FwAutoDMA_(u8 *addr, unsigned int size, int mode);
unsigned int __fastcall spu_FwAutoDMAfrom_(u8 *addr, unsigned int size, int mode, u8 *unk_a4);
void __fastcall spu_Fr_(void *addr, u32 size);
void __fastcall spu_MGFsetRXX2_(int offset, int value);
void __fastcall spu_FsetRXX_(int l, u32 addr, int flag);
int __fastcall spu_FsetRXXa_(int l, u32 flag);
int __fastcall spu_MGFgetRXX2_(int offset);
void __fastcall spu_FsetPCR_(int flag);
static void __fastcall spu_FsetDelayW_(int flag);
static void __fastcall spu_FsetDelayR_(int flag);
void spu_Fw1ts_(void);
void __fastcall SpuCallback_(SpuIRQCallbackProc cb);
void __fastcall SpuDataCallback_(int (__fastcall *callback)(void *userdata));
void __fastcall SpuAutoDMACallback_(int (__fastcall *callback)(void *userdata));
// t:interface
void __fastcall SpuSetDigitalOut(int mode);
void __fastcall SpuInit_(int mode);
int __fastcall SpuDefaultCallback_(void *userdata);
// t:interface
void SpuStart(void);
void SpuStopFreeRun(void);
// t:interface
void SpuInit(void);
// t:interface
unsigned int __fastcall SpuSetCore(unsigned int which_core);
// t:interface
unsigned int SpuGetCore(void);
// t:interface
void __fastcall SpuSetReverbEndAddr(unsigned int eea);
// t:interface
unsigned int SpuGetReverbEndAddr(void);
// t:interface
void SpuInitHot(void);
// t:interface
void SpuQuit(void);
// t:interface
int __fastcall SpuSetMute(int on_off);
// t:interface
int SpuGetMute(void);
void spu_gcSPU_(void);
// t:interface
int __fastcall SpuInitMalloc(int num, char *top);
int __fastcall SpuIsInAllocateArea_(u32 addr);
int __fastcall SpuIsInAllocateArea__(u32 addr);
// t:interface
int __fastcall SpuMalloc(int size);
// t:interface
int __fastcall SpuMallocWithStartAddr(unsigned int addr, int size);
static int __fastcall getNeedBlock(int unk_a1, int unk_a2, int addr_area, int unk_a4);
// t:interface
void __fastcall SpuFree(unsigned int addr);
void spu_print_(void);
// t:interface
void __fastcall SpuSetEnv(const SpuEnv *env);
// t:interface
unsigned int __fastcall SpuFlush(unsigned int ev);
unsigned int __fastcall SpuSetAnyVoice_(int on_off_flags, unsigned int voice_bits, int word_idx1, int word_idx2);
unsigned int __fastcall SpuGetAnyVoice_(int word_idx1, int word_idx2);
// t:interface
unsigned int __fastcall SpuSetNoiseVoice(int on_off, unsigned int voice_bit);
// t:interface
unsigned int SpuGetNoiseVoice(void);
// t:interface
int __fastcall SpuSetNoiseClock(int n_clock);
// t:interface
int SpuGetNoiseClock(void);
// t:interface
int __fastcall SpuSetReverb(int on_off);
// t:interface
int SpuGetReverb(void);
// t:interface
int __fastcall SpuSetReverbModeParam(SpuReverbAttr *attr);
// t:interface
void __fastcall SpuGetReverbModeParam(SpuReverbAttr *attr);
void __fastcall spu_setReverbAttr_(const libspu2_reverb_param_entry_t *p_rev_param_entry);
// t:interface
int __fastcall SpuReserveReverbWorkArea(int on_off);
// t:interface
int __fastcall SpuIsReverbWorkAreaReserved(int on_off);
// t:interface
int __fastcall SpuSetReverbDepth(SpuReverbAttr *attr);
// t:interface
unsigned int __fastcall SpuSetReverbVoice(int on_off, unsigned int voice_bit);
// t:interface
unsigned int SpuGetReverbVoice(void);
// t:interface
int __fastcall SpuClearReverbWorkArea(int mode);
// t:interface
int __fastcall SpuReadDecodedData(SpuDecodedData *d_data, int flag);
// t:interface
int __fastcall SpuSetIRQ(int on_off);
// t:interface
int SpuGetIRQ(void);
// t:interface
unsigned int __fastcall SpuSetIRQAddr(unsigned int addr);
// t:interface
unsigned int SpuGetIRQAddr(void);
// t:interface
unsigned int __fastcall SpuGetNextAddr(int v_num);
// t:interface
SpuIRQCallbackProc __fastcall SpuSetIRQCallback(SpuIRQCallbackProc func);
// t:interface
void __fastcall SpuSetKey(int on_off, unsigned int voice_bit);
// t:interface
int __fastcall SpuGetKeyStatus(unsigned int voice_bit);
// t:interface
void __fastcall SpuSetKeyOnWithAttr(SpuVoiceAttr *attr);
// t:interface
void __fastcall SpuGetVoiceEnvelopeAttr(int v_num, int *key_stat, s16 *envx);
// t:interface
unsigned int __fastcall SpuRead(u8 *addr, unsigned int size);
// t:interface
unsigned int __fastcall SpuWrite(u8 *addr, unsigned int size);
// t:interface
unsigned int SpuAutoDMAWrite(u8 *addr, unsigned int size, unsigned int mode, ...);
// t:interface
int SpuAutoDMAStop(void);
// t:interface
int SpuAutoDMAGetStatus(void);
// t:interface
unsigned int __fastcall SpuWrite0(unsigned int size);
// t:interface
unsigned int __fastcall SpuSetTransferStartAddr(unsigned int addr);
// t:interface
unsigned int SpuGetTransferStartAddr(void);
// t:interface
int __fastcall SpuSetTransferMode(int mode);
// t:interface
int SpuGetTransferMode(void);
// t:interface
unsigned int __fastcall SpuWritePartly(u8 *addr, unsigned int size);
// t:interface
int __fastcall SpuIsTransferCompleted(int flag);
// t:interface
SpuTransferCallbackProc __fastcall SpuSetTransferCallback(SpuTransferCallbackProc func);
// t:interface
SpuTransferCallbackProc __fastcall SpuAutoDMASetCallback(SpuTransferCallbackProc func);
void __fastcall spu_setInTransfer_(int mode);
int spu_getInTransfer_(void);
// t:interface
unsigned int __fastcall SpuSetPitchLFOVoice(int on_off, unsigned int voice_bit);
// t:interface
unsigned int SpuGetPitchLFOVoice(void);
// t:interface
void __fastcall SpuSetCommonAttr(SpuCommonAttr *attr);
// t:interface
void __fastcall SpuGetCommonAttr(SpuCommonAttr *attr);
u16 __fastcall spu_note2pitch_(u16 cen_note_high, u16 cen_note_low, u16 note_high, u16 note_low);
int __fastcall spu_pitch2note_(s16 note_high, s16 note_low, u16 pitch);
// t:interface
int __fastcall SpuRGetAllKeysStatus(int min_, int max_, char *status);
// t:interface
void __fastcall SpuGetAllKeysStatus(char *status);
static void __fastcall SpuStSetMarkSTART_(int voice);
static void __fastcall SpuStSetMarkEND_(int voice);
static void __fastcall SpuStSetMarkFINAL_(int voice);
static void __fastcall SpuStSetMarkFINALrecover_(int voice);
static SpuStVoiceAttr *__fastcall SpuStSetPrepareEnv_(int voice);
void __fastcall SpuStCBPrepare_();
static int __fastcall SpuStStartPrepare_(int voice_bit);
int IntFunc(void);
static SpuStVoiceAttr *__fastcall SpuStSetTransferEnv_(int voice);
void SpuStCB_IRQfinal_(void);
static void SpuStCB_IRQ_(void);
static void SpuStCB_Transfer_(void);
static int __fastcall SpuStStart_(unsigned int voice_bit);
// t:interface
int __fastcall SpuStTransfer(int flag, unsigned int voice_bit);
static void SpuStReset_(void);
// t:interface
SpuStEnv *__fastcall SpuStInit(int mode);
// t:interface
int SpuStQuit(void);
// t:interface
int SpuStGetStatus(void);
// t:interface
unsigned int SpuStGetVoiceStatus(void);
// t:interface
SpuStCallbackProc __fastcall SpuStSetPreparationFinishedCallback(SpuStCallbackProc func);
// t:interface
SpuStCallbackProc __fastcall SpuStSetTransferFinishedCallback(SpuStCallbackProc func);
// t:interface
SpuStCallbackProc __fastcall SpuStSetStreamFinishedCallback(SpuStCallbackProc func);
// t:interface
unsigned int __fastcall SpuStSetCore(unsigned int core);
static void spu_wait_(void);
// t:interface
void __fastcall SpuSetVoiceVolume(int v_num, s16 voll, s16 volr);
static void spu_wait__00(void);
// t:interface
void __fastcall SpuSetVoiceVolumeAttr(int v_num, s16 voll, s16 volr, s16 voll_mode, s16 volr_mode);
static void spu_wait__01(void);
// t:interface
void __fastcall SpuSetVoicePitch(int v_num, u16 pitch);
static void spu_wait__02(void);
// t:interface
void __fastcall SpuSetVoiceNote(int v_num, u16 note);
static void spu_wait__03(void);
// t:interface
void __fastcall SpuSetVoiceSampleNote(int v_num, u16 sample_note);
static void spu_wait__04(void);
// t:interface
void __fastcall SpuSetVoiceStartAddr(int v_num, unsigned int start_addr);
static void spu_wait__05(void);
// t:interface
void __fastcall SpuSetVoiceLoopStartAddr(int v_num, unsigned int lsa);
static void spu_wait__06(void);
// t:interface
void __fastcall SpuSetVoiceAR(int v_num, u16 ar);
static void spu_wait__07(void);
// t:interface
void __fastcall SpuSetVoiceDR(int v_num, u16 dr);
static void spu_wait__08(void);
// t:interface
void __fastcall SpuSetVoiceSR(int v_num, u16 sr);
static void spu_wait__09(void);
// t:interface
void __fastcall SpuSetVoiceRR(int v_num, u16 rr);
static void spu_wait__10(void);
// t:interface
void __fastcall SpuSetVoiceSL(int v_num, u16 sl);
static void spu_wait__11(void);
// t:interface
void __fastcall SpuSetVoiceARAttr(int v_num, u16 ar, int ar_mode);
static void spu_wait__12(void);
// t:interface
void __fastcall SpuSetVoiceSRAttr(int v_num, u16 sr, int sr_mode);
static void spu_wait__13(void);
// t:interface
void __fastcall SpuSetVoiceRRAttr(int v_num, u16 rr, int rr_mode);
static void spu_wait__14(void);
// t:interface
void __fastcall SpuSetVoiceADSR(int v_num, u16 ar, u16 dr, u16 sr, u16 rr, u16 sl);
static void spu_wait__15(void);
// t:interface
void __fastcall SpuSetVoiceADSRAttr(int v_num, u16 ar, u16 dr, u16 sr, u16 rr, u16 sl, int ar_mode, int sr_mode, int rr_mode);
static void spu_wait__16(void);
// t:interface
void __fastcall SpuSetVoiceAttr(SpuVoiceAttr *arg);
static void spu_wait__17(void);
// t:interface
int __fastcall SpuRSetVoiceAttr(int min_, int max_, SpuVoiceAttr *arg);
static void spu_wait__18(void);
// t:interface
void __fastcall SpuNSetVoiceAttr(int v_num, SpuVoiceAttr *arg);
static void spu_wait__19(void);
// t:interface
void __fastcall SpuLSetVoiceAttr(int num, SpuLVoiceAttr *arg_list);
// t:interface
void __fastcall SpuGetVoiceVolume(int v_num, s16 *voll, s16 *volr);
// t:interface
void __fastcall SpuGetVoiceVolumeAttr(int v_num, s16 *voll, s16 *volr, s16 *voll_mode, s16 *volr_mode);
// t:interface
void __fastcall SpuGetVoiceVolumeX(int v_num, s16 *voll_x, s16 *volr_x);
// t:interface
void __fastcall SpuGetVoicePitch(int v_num, u16 *pitch);
// t:interface
void __fastcall SpuGetVoiceNote(int v_num, u16 *note);
// t:interface
void __fastcall SpuGetVoiceSampleNote(int v_num, u16 *sample_note);
// t:interface
void __fastcall SpuGetVoiceEnvelope(int v_num, s16 *envx);
// t:interface
void __fastcall SpuGetVoiceStartAddr(int v_num, unsigned int *start_addr);
// t:interface
void __fastcall SpuGetVoiceLoopStartAddr(int v_num, unsigned int *loop_start_addr);
// t:interface
void __fastcall SpuGetVoiceAR(int v_num, u16 *ar);
// t:interface
void __fastcall SpuGetVoiceDR(int v_num, u16 *dr);
// t:interface
void __fastcall SpuGetVoiceSR(int v_num, u16 *sr);
// t:interface
void __fastcall SpuGetVoiceRR(int v_num, u16 *rr);
// t:interface
void __fastcall SpuGetVoiceSL(int v_num, u16 *sl);
// t:interface
void __fastcall SpuGetVoiceARAttr(int v_num, u16 *ar, int *ar_mode);
// t:interface
void __fastcall SpuGetVoiceSRAttr(int v_num, u16 *sr, int *sr_mode);
// t:interface
void __fastcall SpuGetVoiceRRAttr(int v_num, u16 *rr, int *rr_mode);
// t:interface
void __fastcall SpuGetVoiceADSR(int v_num, u16 *ar, u16 *dr, u16 *sr, u16 *rr, u16 *sl);
// t:interface
void __fastcall SpuGetVoiceADSRAttr(int v_num, u16 *ar, u16 *dr, u16 *sr, u16 *rr, u16 *sl, int *ar_mode, int *sr_mode, int *rr_mode);
// t:interface
void __fastcall SpuSetCommonMasterVolume(s16 mvol_left, s16 mvol_right);
// t:interface
void __fastcall SpuSetCommonMasterVolumeAttr(s16 mvol_left, s16 mvol_right, s16 mvolmode_left, s16 mvolmode_right);
// t:interface
void __fastcall SpuSetCommonCDVolume(s16 cd_left, s16 cd_right);
// t:interface
void __fastcall SpuSetCommonCDReverb(int cd_reverb);
// t:interface
void __fastcall SpuSetCommonCDMix(int cd_mix);
// t:interface
void __fastcall SpuGetCommonMasterVolume(s16 *mvol_left, s16 *mvol_right);
// t:interface
void __fastcall SpuGetCommonMasterVolumeX(s16 *mvolx_left, s16 *mvolx_right);
// t:interface
void __fastcall SpuGetCommonMasterVolumeAttr(s16 *mvol_left, s16 *mvol_right, s16 *mvolmode_left, s16 *mvolmode_right);
// t:interface
void __fastcall SpuGetCommonCDVolume(s16 *cd_left, s16 *cd_right);
// t:interface
void __fastcall SpuGetCommonCDReverb(int *cd_reverb);
// t:interface
void __fastcall SpuGetCommonCDMix(int *cd_mix);
// t:interface
int __fastcall SpuSetReverbModeType(int mode);
// t:interface
void __fastcall SpuSetReverbModeDepth(s16 depth_left, s16 depth_right);
// t:interface
void __fastcall SpuSetReverbModeDelayTime(int delay);
// t:interface
void __fastcall SpuSetReverbModeFeedback(int feedback);
// t:interface
void __fastcall SpuGetReverbModeType(int *mode);
// t:interface
void __fastcall SpuGetReverbModeDepth(s16 *depth_left, s16 *depth_right);
// t:interface
void __fastcall SpuGetReverbModeDelayTime(int *delay);
// t:interface
void __fastcall SpuGetReverbModeFeedback(int *feedback);
// t:interface
void __fastcall SpuGetVoiceAttr(SpuVoiceAttr *arg);
// t:interface
void __fastcall SpuNGetVoiceAttr(int v_num, SpuVoiceAttr *arg);
// t:interface
void __fastcall SpuSetESA(int rev_addr);
// t:interface
void __fastcall SpuSetAutoDMAAttr(s16 vol_l, s16 vol_r, s16 dry_on, s16 effect_on);
// t:interface
void __fastcall SpuSetSerialInAttr(s16 dry_on, s16 effect_on);
void __fastcall SsUtResolveADSR_(u16 adsr1, u16 adsr2, u16 *adsr_buf);
void __fastcall SsUtBuildADSR_(const u16 *adsr_buf, u16 *adsr1, u16 *adsr2);
// t:interface
void __fastcall SsContBankChange_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContDataEntry_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContMainVol_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContPanpot_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContExpression_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContDamper_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContExternal_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContNrpn1_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContNrpn2_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContRpn1_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContRpn2_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsContResetAll_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsSetNrpnVabAttr0_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr1_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr2_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr3_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr4_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr5_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr6_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr7_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr8_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr9_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr10_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr11_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr12_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr13_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr14_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr15_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr16_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr17_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr18_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall SsSetNrpnVabAttr19_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
void __fastcall SsSndCrescendo_(s16 sep_no, s16 seq_no);
// t:interface
void __fastcall SsSetPitchBend_(s16 sep_no, s16 seq_no);
// t:interface
void __fastcall SsSetControlChange_(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall SsGetMetaEvent_(s16 sep_no, s16 seq_no, u8 meta_event);
// t:interface
void __fastcall SsNoteOn_(s16 sep_no, s16 seq_no, u8 note, u8 vollr);
// t:interface
void __fastcall SsSetProgramChange_(s16 sep_no, s16 seq_no, u8 prog);
void __fastcall SsSeqPlay_(s16 sep_no, s16 seq_no);
void __fastcall SsSeqGetEof_(s16 sep_no, s16 seq_no);
int __fastcall SsGetSeqData_(s16 sep_no, s16 seq_no);
s32 __fastcall SsReadDeltaValue_(s16 sep_no, s16 seq_no);
void __fastcall SsSndNextSep_(s16 sep_no, s16 seq_no);
void __fastcall SsSndNextPause_(s16 sep_no, s16 seq_no);
void __fastcall SsSndPause_(s16 sep_no, s16 seq_no);
void __fastcall SsSndPlay_(s16 sep_no, s16 seq_no);
void __fastcall SsSndReplay_(s16 sep_no, s16 seq_no);
int __fastcall SsInitSoundSep_(s16 sep_no, int seq_no, u8 vab_id, u8 *addr);
s16 __fastcall SsInitSoundSeq_(s16 seq_no, s16 vab_id, u8 *addr);
void __fastcall SsSndSetAccele_(s16 sep_no, s16 seq_no, int tempo, int v_time);
// t:interface
void __fastcall SsSeqSetAccelerando(s16 seq_no, int tempo, int v_time);
// t:interface
void __fastcall SsSepSetAccelerando(s16 seq_no, s16 sep_no, int tempo, int v_time);
// t:interface
void SsSeqCalledTbyT(void);
static void __fastcall SsClose_(s16 seq_sep_no);
// t:interface
void __fastcall SsSeqClose(s16 seq_sep_no);
// t:interface
void __fastcall SsSepClose(s16 seq_sep_no);
// t:interface
void __fastcall SsChannelMute(s16 sep_no, s16 seq_no, int channels);
// t:interface
int __fastcall SsGetChannelMute(s16 sep_no, s16 seq_no);
void __fastcall SsSndSetCres_(s16 sep_no, s16 seq_no, s16 vol, int v_time);
// t:interface
void __fastcall SsSeqSetCrescendo(s16 sep_no, s16 vol, int v_time);
// t:interface
void __fastcall SsSepSetCrescendo(s16 sep_no, s16 seq_no, s16 vol, int v_time);
void __fastcall SsSndSetDecres_(s16 sep_no, s16 seq_no, s16 vol, int v_time);
// t:interface
void __fastcall SsSeqSetDecrescendo(s16 sep_no, s16 vol, int v_time);
// t:interface
void __fastcall SsSepSetDecrescendo(s16 sep_no, s16 seq_no, s16 vol, int v_time);
// t:interface
void SsEnd(void);
// t:interface
char SsGetMute(void);
// t:interface
void __fastcall SsGetMVol(SndVolume *m_vol);
// t:interface
s16 SsGetNck(void);
// t:interface
void __fastcall SsGetRVol(SndVolume *r_vol);
// t:interface
char __fastcall SsGetSerialAttr(char s_num, char attr);
// t:interface
void __fastcall SsGetSerialVol(char s_num, SndVolume *s_vol);
void SsInit_(void);
// t:interface
void SsInit(void);
// t:interface
void __fastcall SsPitchCorrect(s16 pitch_correct);
// t:interface
void SsInitHot(void);
// t:interface
void __fastcall SsSetLoop(s16 sep_no, s16 seq_no, s16 l_count);
// t:interface
s16 __fastcall SsIsEos(s16 sep_no, s16 seq_no);
// t:interface
void __fastcall SsSetMarkCallback(s16 sep_no, s16 seq_no, SsMarkCallbackProc proc);
// t:interface
void __fastcall SsSetNext(s16 sep_no1, s16 seq_no1, s16 sep_no2, s16 seq_no2);
// t:interface
void __fastcall SsSeqSetNext(s16 sep_no1, s16 sep_no2);
// t:interface
void SsSetNoiseOff(void);
// t:interface
void __fastcall SsSetNoiseOn(s16 voll, s16 volr);
// t:interface
s16 __fastcall SsSepOpen(unsigned int *addr, s16 vab_id, s16 seq_cnt);
// t:interface
s16 __fastcall SsSeqOpen(unsigned int *addr, s16 vab_id);
// t:interface
s16 __fastcall SsSepOpenJ(unsigned int *addr, s16 vab_id, s16 seq_cnt);
// t:interface
s16 __fastcall SsSeqOpenJ(unsigned int *addr, s16 vab_id);
void __fastcall SsSndSetPauseMode_(s16 sep_no, s16 seq_no);
// t:interface
void __fastcall SsSeqPause(s16 sep_no);
// t:interface
void __fastcall SsSepPause(s16 sep_no, s16 seq_no);
// t:interface
void __fastcall SsSeqPlay(s16 sep_no, char play_mode, s16 l_count);
// t:interface
void __fastcall SsSepPlay(s16 sep_no, s16 seq_no, char play_mode, s16 l_count);
// t:interface
void __fastcall SsPlayBack(s16 sep_no, s16 seq_no, s16 l_count);
// t:interface
void SsQuit(void);
void __fastcall SsSndSetReplayMode_(s16 sep_no, s16 seq_no);
// t:interface
void __fastcall SsSeqReplay(s16 sep_no);
// t:interface
void __fastcall SsSepReplay(s16 sep_no, s16 seq_no);
void __fastcall Snd_SetPlayMode(s16 sep_no, s16 seq_no, char play_mode, char l_count);
void __fastcall SsSndSetRit_(s16 sep_no, s16 seq_no, int tempo, int v_time);
// t:interface
void __fastcall SsSeqSetRitardando(s16 sep_no, int tempo, int v_time);
// t:interface
void __fastcall SsSepSetRitardando(s16 sep_no, s16 seq_no, int tempo, int v_time);
// t:interface
int __fastcall SsSeqSkip(s16 sep_no, s16 seq_no, char unit, s16 count);
// t:interface
int __fastcall SsSetCurrentPoint(s16 sep_no, s16 seq_no, u8 *point);
// t:interface
void __fastcall SsSeqPlayPtoP(s16 sep_no, s16 seq_no, u8 *start_point, u8 *end_point, char play_mode, s16 l_count);
// t:interface
void __fastcall SsSetSerialAttr(char s_num, char attr, char mode);
// t:interface
void __fastcall SsSetMute(char mode);
// t:interface
void __fastcall SsSetMVol(s16 voll, s16 volr);
// t:interface
void __fastcall SsSetNck(s16 n_clock);
// t:interface
void __fastcall SsSetRVol(s16 voll, s16 volr);
int __fastcall SsTrapIntrProcIOP_(void *userdata);
static void __fastcall SsStart_(int start_param);
// t:interface
void SsStart(void);
// t:interface
void SsStart2(void);
void __fastcall SsSndStop_(s16 sep_no, s16 seq_no);
// t:interface
void __fastcall SsSeqStop(s16 sep_no);
// t:interface
void __fastcall SsSepStop(s16 sep_no, s16 seq_no);
// t:interface
void __fastcall SsSetSerialVol(char s_num, s16 voll, s16 volr);
// t:interface
void __fastcall SsSetTableSize(char *table, s16 s_max, s16 t_max);
// t:interface
void __fastcall SsSetTempo(s16 sep_no, s16 seq_no, s16 tempo);
// t:interface
void __fastcall SsSetTickMode(int tick_mode);
// t:interface
void *__fastcall SsSetTickCallback(void (*cb)(void));
// t:interface
int __fastcall SsVoKeyOff(int vab_pro, int pitch);
// t:interface
int __fastcall SsVoKeyOn(int vab_pro, int pitch, u16 voll, u16 volr);
void __fastcall SsSndSetVol_(s16 sep_no, s16 seq_no, u16 voll, u16 volr);
// t:interface
void __fastcall SsSeqSetVol(s16 sep_no, s16 voll, s16 volr);
// t:interface
void __fastcall SsSepSetVol(s16 sep_no, s16 seq_no, s16 voll, s16 volr);
// t:interface
void __fastcall SsSeqGetVol(s16 sep_no, s16 seq_no, s16 *voll, s16 *volr);
void __fastcall SsSndTempo_(s16 sep_no, s16 seq_no);
void __fastcall SsSndSetVolData_(s16 sep_no, s16 seq_no, int vol, int v_time);
// t:interface
void __fastcall dmy_nothing1(s16 seq_no, s16 sep_no, u8 note, u8 vollr);
// t:interface
void __fastcall dmy_SsNoteOn(s16 sep_no, s16 seq_no, u8 note, u8 vollr);
// t:interface
void __fastcall dmy_SsSetProgramChange(s16 sep_no, s16 seq_no, u8 prog);
// t:interface
void __fastcall dmy_SsGetMetaEvent(s16 sep_no, s16 seq_no, u8 meta_event);
// t:interface
void __fastcall dmy_SsSetPitchBend(s16 sep_no, s16 seq_no);
// t:interface
void __fastcall dmy_SsSetControlChange(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContBankChange(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContDataEntry(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContMainVol(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContPanpot(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContExpression(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContDamper(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContExternal(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContNrpn1(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContNrpn2(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContRpn1(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContRpn2(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsContResetAll(s16 sep_no, s16 seq_no, u8 control_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr0(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr1(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr2(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr3(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr4(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr5(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr6(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr7(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr8(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr9(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr10(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr11(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr12(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr13(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr14(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr15(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr16(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr17(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr18(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
void __fastcall dmy_SsSetNrpnVabAttr19(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value);
// t:interface
u8 *__fastcall SsGetCurrentPoint(s16 sep_no, s16 seq_no);
// t:interface
void __fastcall SsSetVoiceMask(unsigned int s_voice);
// t:interface
unsigned int SsGetVoiceMask(void);
// t:interface
void __fastcall SsUtAllKeyOff(s16 mode);
// t:interface
s16 __fastcall SsUtAutoPan(s16 vc, s16 start_pan, s16 end_pan, s16 delta_time);
// t:interface
s16 __fastcall SsUtAutoVol(s16 vc, s16 start_vol, s16 end_vol, s16 delta_time);
// t:interface
s16 __fastcall SsUtChangeADSR(s16 vc, s16 vab_id, s16 prog, s16 old_note, u16 adsr1, u16 adsr2);
// t:interface
s16 __fastcall SsUtChangePitch(s16 vc, s16 vab_id, s16 prog, s16 old_note, s16 old_fine, s16 new_note, s16 new_fine);
// t:interface
void SsUtFlush(void);
// t:interface
s16 __fastcall SsUtGetProgAtr(s16 vab_id, s16 prog, ProgAtr *prog_attr_ptr);
// t:interface
s16 __fastcall SsUtGetVagAtr(s16 vab_id, s16 prog, s16 tone, VagAtr *vag_attr_ptr);
// t:interface
int __fastcall SsUtGetVagAddr(s16 vab_id, s16 vag_id);
// t:interface
unsigned int __fastcall SsUtGetVagAddrFromTone(s16 vab_id, s16 prog, s16 tone);
// t:interface
unsigned int __fastcall SsUtGetVBaddrInSB(s16 vab_id);
// t:interface
s16 __fastcall SsUtGetVabHdr(s16 vab_id, VabHdr *vab_hdr_ptr);
// t:interface
s16 __fastcall SsUtKeyOn(s16 vab_id, s16 prog, s16 tone, s16 note, s16 fine, s16 voll, s16 volr);
// t:interface
s16 __fastcall SsUtKeyOff(s16 vc, s16 vab_id, s16 prog, s16 tone, s16 note);
// t:interface
s16 __fastcall SsUtKeyOnV(s16 vc, s16 vab_id, s16 prog, s16 tone, s16 note, s16 fine, s16 voll, s16 volr);
// t:interface
s16 __fastcall SsUtKeyOffV(s16 vc);
// t:interface
s16 __fastcall SsUtPitchBend(s16 vc, s16 vab_id, s16 prog, s16 note, s16 pbend);
// t:interface
void __fastcall SsUtSetReverbDelay(s16 delay);
// t:interface
void __fastcall SsUtSetReverbDepth(s16 ldepth, s16 rdepth);
// t:interface
s16 __fastcall SsUtSetReverbType(s16 type);
// t:interface
s16 SsUtGetReverbType(void);
// t:interface
void __fastcall SsUtSetReverbFeedback(s16 feedback);
// t:interface
void SsUtReverbOff(void);
// t:interface
void SsUtReverbOn(void);
// t:interface
s16 __fastcall SsUtSetProgAtr(s16 vab_id, s16 prog, const ProgAtr *prog_attr_ptr);
// t:interface
s16 __fastcall SsUtSetVagAtr(s16 vab_id, s16 prog, s16 tone, const VagAtr *vag_attr_ptr);
// t:interface
s16 __fastcall SsUtSetVabHdr(s16 vab_id, const VabHdr *vab_hdr_ptr);
// t:interface
s16 __fastcall SsUtGetDetVVol(s16 vc, s16 *detvoll, s16 *detvolr);
// t:interface
s16 __fastcall SsUtSetDetVVol(s16 vc, s16 detvoll, s16 detvolr);
// t:interface
s16 __fastcall SsUtGetVVol(s16 vc, s16 *voll, s16 *volr);
// t:interface
s16 __fastcall SsUtSetVVol(s16 vc, s16 voll, s16 volr);
s16 SsVmAlloc_(void);
void SsVmDoAllocate_(void);
void __fastcall SeAutoPan(s16 vc, s16 start_pan, s16 end_pan, s16 delta_time);
void __fastcall SetAutoPan(int vc);
void __fastcall SeAutoVol(s16 vc, s16 start_vol, s16 end_vol, s16 delta_time);
void __fastcall SetAutoVol(int vc);
void SsVmDamperOff_(void);
void SsVmDamperOn_(void);
void __fastcall wait1fsa();
void __fastcall DumpSpu();
void __fastcall DumpVoice();
void __fastcall DumpVoice2();
void SsVmFlush_(void);
void __fastcall SsVmInit_(int voice_count);
int __fastcall SsVmKeyOn_(int seq_sep_no, s16 vab_id, s16 prog, s16 note, s16 voll, s16 unknown27);
int __fastcall SsVmKeyOff_(int seq_sep_no, s16 vab_id, s16 prog, s16 note);
int __fastcall SsVmSeKeyOn_(s16 vab_id, s16 prog, u16 note, int pitch, u16 voll, u16 volr);
int __fastcall SsVmSeKeyOff_(s16 vab_id, s16 prog, s16 note);
void KeyOnCheck(void);
s16 note2pitch(void);
s16 __fastcall note2pitch2(s16 note, s16 fine);
// t:interface
u16 __fastcall SsPitchFromNote(s16 note, s16 fine, u8 center, u8 shift);
void __fastcall vmNoiseOn(u8 vc);
void __fastcall vmNoiseOn2(u8 vc, u16 voll, u16 volr, u16 arg3, u16 arg4);
void __fastcall vmNoiseOff(u8 vc);
void __fastcall SsVmNoiseOnWithAdsr_(s32 voll, s32 volr, s32 arg2, s32 arg3);
void SsVmNoiseOff_(void);
void __fastcall SsVmNoiseOn_(u16 voll, u16 volr);
void SsVmKeyOffNow_(void);
void __fastcall SsVmKeyOnNow_(s16 vag_count, s16 pitch);
int __fastcall SsVmPBVoice_(s16 vc, s16 seq_sep_num, s16 vab_id, s16 prog, s16 pitch);
int __fastcall SsVmPitchBend_(s16 seq_sep_no, int vab_id, int prog, s16 pitch);
void __fastcall SsVmSetProgVol_(s16 vab_id, s16 prog, u8 vol);
int __fastcall SsVmGetProgVol_(s16 vab_id, s16 prog);
int __fastcall SsVmSetProgPan_(s16 vab_id, s16 prog, char mpan);
int __fastcall SsVmGetProgPan_(s16 vab_id, s16 prog);
void __fastcall SsVmSetSeqVol_(s16 seq_sep_num, s16 voll, s16 volr);
void __fastcall SsVmGetSeqVol_(s16 seq_sep_no, s16 *voll_ptr, s16 *volr_ptr);
int __fastcall SsVmGetSeqLVol_(s16 seq_sep_no);
int __fastcall SsVmGetSeqRVol_(s16 seq_sep_no);
void __fastcall SsVmSeqKeyOff_(s16 seq_sep_no);
void __fastcall SePitchBend(u8 vc, s16 arg1);
s16 __fastcall SsVmSelectToneAndVag_(u8 *vag_attr_idx_ptr, u8 *vag_nums_ptr);
void SeVibOn(void);
static void SeVibOff(void);
void SetVib(void);
void SsUtVibrateOn(void);
void SsUtVibrateOff(void);
void __fastcall SsVmSetVol_(s16 seq_sep_no, s16 vab_id, s16 prog, s16 voll, s16 volr);
int __fastcall SsVmVSetUp_(s16 vab_id, s16 prog);
// t:interface
void __fastcall SsSetAutoKeyOffMode(s16 mode);
// t:interface
void SsSetMono(void);
// t:interface
void SsSetStereo(void);
// t:interface
char __fastcall SsSetReservedVoice(char voices);
// t:interface
void __fastcall SsVabClose(s16 vab_id);
// t:interface
s16 __fastcall SsVabFakeBody(s16 vab_id);
// t:interface
s16 __fastcall SsVabOpenHeadSticky(u8 *addr, s16 vab_id, unsigned int sbaddr);
// t:interface
s16 __fastcall SsVabFakeHead(u8 *addr, s16 vab_id, unsigned int sbaddr);
static int __fastcall VsGetAddr(unsigned int size_in_bytes, int mode, s16 vab_id);
int __fastcall SsVabOpenHeadWithMode_(u8 *addr, int vab_id, libsnd2_vab_allocate_callback alloc_fn, int mode);
// t:interface
s16 __fastcall SsVabOpenHead(u8 *addr, s16 vab_id);
static int __fastcall VsGetAddrSpuMalloc(unsigned int size_in_bytes, int mode, s16 vab_id);
// t:interface
s16 __fastcall SsVabTransfer(u8 *vh_addr, u8 *vb_addr, s16 vab_id, s16 i_flag);
// t:interface
s16 __fastcall SsVabTransBody(u8 *addr, s16 vab_id);
// t:interface
s16 __fastcall SsVabTransBodyPartly(u8 *addr, unsigned int bufsize, s16 vab_id);
// t:interface
s16 __fastcall SsVabTransCompleted(s16 immediate_flag);
// t:interface
char SsBlockVoiceAllocation(void);
// t:interface
char SsUnBlockVoiceAllocation(void);
// t:interface
int __fastcall SsAllocateVoices(u8 voices, u8 priority);
// t:interface
void __fastcall SsQueueKeyOn(int voices);
// t:interface
void __fastcall SsQueueReverb(int voices, int reverb);
// t:interface
void __fastcall SsQueueRegisters(int vc, SndRegisterAttr *sra);
// t:interface
s16 __fastcall SsGetActualProgFromProg(s16 vab_id, s16 prog);
// t:interface
void __fastcall SsSetVoiceSettings(int vc, const SndVoiceStats *snd_v_attr);
// t:interface
s16 __fastcall SsVoiceCheck(int vc, int vab_id, s16 note);
int Kprintf(const char *format, ...);
int __fastcall RegisterIntrHandler(int irq, int mode, int (__fastcall *handler)(void *), void *arg);
int __fastcall ReleaseIntrHandler(int irq);
int __fastcall EnableIntr(int irq);
int __fastcall DisableIntr(int irq, int *res);
int __fastcall CpuDisableIntr();
int __fastcall CpuEnableIntr();
void FlushDcache(void);
int printf(const char *format, ...);
int __fastcall SetAlarm(iop_sys_clock_t *sys_clock, unsigned int (__fastcall *alarm_cb)(void *), void *arg);
int __fastcall CancelAlarm(unsigned int (__fastcall *alarm_cb)(void *), void *arg);
void __fastcall USec2SysClock(u32 usec, iop_sys_clock_t *sys_clock);
int __fastcall RegisterVblankHandler(int startend, int priority, int (__fastcall *handler)(void *), void *arg);
int __fastcall ReleaseVblankHandler(int startend, int (__fastcall *handler)(void *));

//-------------------------------------------------------------------------
// Data declarations

// rsd_com.o

static int ret = 0;
static int gMultiVoiceNum = 0;
#ifndef LIB_OSD_100
static volatile int g_AutoDmaIntrCount = 0;
static int g_AutoDmaInProcessing = 0;
#endif

// spu.o

vu16 *spu_RXX_ = (vu16 *)0xBF900000;
static vu32 *spu_madr_ = (vu32 *)0xBF8010C0;
static vu32 *spu_bcr_ = (vu32 *)0xBF8010C4;
static vu32 *spu_chcr_ = (vu32 *)0xBF8010C8;
static vu32 *spu_sys_pcr_ = (vu32 *)0xBF8010F0;
static vu32 *spu_delay_ = (vu32 *)0xBF801014;
u32 spu_tsa_[2] = { 0u, 0u };
u32 spu_transMode_ = 0u;
u32 spu_inTransfer_ = 1u;
SpuTransferCallbackProc spu_transferCallback_ = NULL;
SpuTransferCallbackProc spu_AutoDMACallback_ = NULL;
SpuIRQCallbackProc spu_IRQCallback_ = NULL;
static int g_DmaCoreIndex = 0;
static int spu_dma_mode_ = 0;
static int spu_transfer_startaddr_ = 0;
static int spu_transfer_time_ = 0;

// s_ini.o

u32 spu_keystat_[2] = { 0u, 0u };
u32 spu_trans_mode_ = 0u;
u32 spu_rev_flag_ = 0u;
u32 spu_rev_reserve_wa_ = 0u;
u32 spu_rev_offsetaddr_ = 0u;
SpuReverbAttr spu_rev_attr_ = { 0u, 0, { 0, 0 }, 0, 0 };
u32 spu_RQvoice_ = 0u;
u32 spu_RQmask_ = 0u;
s16 spu_voice_centerNote_[2][24] =
{
  {
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384
  },
  {
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384,
    -16384
  }
};
u32 spu_env_ = 0u;
u32 spu_isCalled_ = 0u;
SpuIRQCallbackProc spu_irq_callback_ = NULL;

// s_i.o

int spu_eea_[4] = { 15, 15, 0, 0 };

// s_m.o

int spu_AllocBlockNum_ = 0;
int spu_AllocLastNum_ = 0;
libspu2_malloc_t *spu_memList_ = NULL;

// zerobuf.o

u32 spu_zerobuf_[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
};

// s_n2p.o

static s16 spu_NTable_[12] =
{
  32768,
  -30820,
  -28756,
  -26569,
  -24251,
  -21796,
  -19196,
  -16440,
  -13521,
  -10428,
  -7151,
  -3679
};
static s16 spu_FTable_[128] =
{
  32768,
  -32754,
  -32739,
  -32724,
  -32709,
  -32694,
  -32680,
  -32665,
  -32650,
  -32635,
  -32620,
  -32605,
  -32591,
  -32576,
  -32561,
  -32546,
  -32531,
  -32516,
  -32501,
  -32486,
  -32471,
  -32456,
  -32442,
  -32427,
  -32412,
  -32397,
  -32382,
  -32367,
  -32352,
  -32337,
  -32322,
  -32307,
  -32292,
  -32277,
  -32262,
  -32247,
  -32232,
  -32217,
  -32202,
  -32187,
  -32172,
  -32157,
  -32142,
  -32126,
  -32111,
  -32096,
  -32081,
  -32066,
  -32051,
  -32036,
  -32021,
  -32006,
  -31990,
  -31975,
  -31960,
  -31945,
  -31930,
  -31915,
  -31900,
  -31884,
  -31869,
  -31854,
  -31839,
  -31824,
  -31808,
  -31793,
  -31778,
  -31763,
  -31747,
  -31732,
  -31717,
  -31702,
  -31686,
  -31671,
  -31656,
  -31640,
  -31625,
  -31610,
  -31595,
  -31579,
  -31564,
  -31549,
  -31533,
  -31518,
  -31503,
  -31487,
  -31472,
  -31456,
  -31441,
  -31426,
  -31410,
  -31395,
  -31379,
  -31364,
  -31349,
  -31333,
  -31318,
  -31302,
  -31287,
  -31271,
  -31256,
  -31240,
  -31225,
  -31209,
  -31194,
  -31178,
  -31163,
  -31147,
  -31132,
  -31116,
  -31101,
  -31085,
  -31070,
  -31054,
  -31039,
  -31023,
  -31008,
  -30992,
  -30976,
  -30961,
  -30945,
  -30930,
  -30914,
  -30898,
  -30883,
  -30867,
  -30851,
  -30836
};

// st.o

unsigned int st_core_ = 0u;
static int spu_st_stat_int_ = 0;
static int spu_st_start_voice_bit_ = 0;
static int spu_st_start_tmp_voice_bit_ = 0;
static int spu_st_start_add_voice_bit_ = 0;
static int spu_st_start_prepare_voice_bit_ = 0;
static int spu_st_start_prepare_tmp_voice_bit_ = 0;
static int spu_st_start_prepared_voice_bit_ = 0;
static int spu_st_stop_voice_bit_ = 0;
static int spu_st_stop_saved_voice_bit_ = 0;
static int spu_st_tmp_voice_bit_ = 0;

// s_rmp1.o

s32 spu_rev_workareasize_[12] = { 2, 1240, 1000, 2312, 3580, 5564, 7896, 12296, 12296, 1920, 0, 0 };

// s_rmp2.o

libspu2_reverb_param_entry_t spu_rev_param_[10] =
{
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    1u,
    1u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    1u,
    1u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    0u,
    125u,
    91u,
    28032u,
    21688u,
    48848u,
    0u,
    0u,
    47744u,
    22528u,
    21248u,
    1238u,
    819u,
    1008u,
    551u,
    884u,
    495u,
    822u,
    439u,
    821u,
    438u,
    820u,
    437u,
    820u,
    437u,
    820u,
    437u,
    436u,
    310u,
    184u,
    92u,
    32768u,
    32768u
  },
  {
    0u,
    51u,
    37u,
    28912u,
    20392u,
    48352u,
    17424u,
    49392u,
    39936u,
    21120u,
    20160u,
    996u,
    795u,
    932u,
    687u,
    882u,
    614u,
    796u,
    605u,
    604u,
    398u,
    559u,
    309u,
    466u,
    183u,
    399u,
    181u,
    180u,
    128u,
    76u,
    38u,
    32768u,
    32768u
  },
  {
    0u,
    177u,
    127u,
    28912u,
    20392u,
    48352u,
    17680u,
    48880u,
    46272u,
    21120u,
    20160u,
    2308u,
    1899u,
    2084u,
    1631u,
    1954u,
    1558u,
    1900u,
    1517u,
    1516u,
    1070u,
    1295u,
    773u,
    1122u,
    695u,
    1071u,
    613u,
    612u,
    434u,
    256u,
    128u,
    32768u,
    32768u
  },
  {
    0u,
    227u,
    169u,
    28512u,
    20392u,
    48352u,
    17680u,
    48880u,
    42624u,
    22144u,
    21184u,
    3579u,
    2904u,
    3337u,
    2620u,
    3033u,
    2419u,
    2905u,
    2266u,
    2265u,
    1513u,
    2028u,
    1200u,
    1775u,
    978u,
    1514u,
    797u,
    796u,
    568u,
    340u,
    170u,
    32768u,
    32768u
  },
  {
    0u,
    421u,
    313u,
    24576u,
    20480u,
    19456u,
    47104u,
    48128u,
    49152u,
    24576u,
    23552u,
    5562u,
    4539u,
    5314u,
    4285u,
    4540u,
    3521u,
    4544u,
    3523u,
    3520u,
    2497u,
    3012u,
    1985u,
    2560u,
    1741u,
    2498u,
    1473u,
    1472u,
    1050u,
    628u,
    314u,
    32768u,
    32768u
  },
  {
    0u,
    829u,
    561u,
    32256u,
    20480u,
    46080u,
    45056u,
    19456u,
    45056u,
    24576u,
    21504u,
    7894u,
    6705u,
    7444u,
    6203u,
    7106u,
    5810u,
    6706u,
    5615u,
    5614u,
    4181u,
    4916u,
    3885u,
    4598u,
    3165u,
    4182u,
    2785u,
    2784u,
    1954u,
    1124u,
    562u,
    32768u,
    32768u
  },
  {
    0u,
    3u,
    3u,
    32767u,
    32767u,
    0u,
    0u,
    0u,
    33024u,
    0u,
    0u,
    8189u,
    4093u,
    4105u,
    9u,
    0u,
    0u,
    4105u,
    9u,
    8191u,
    8191u,
    8190u,
    8190u,
    8190u,
    8190u,
    8190u,
    8190u,
    4104u,
    4100u,
    8u,
    4u,
    32768u,
    32768u
  },
  {
    0u,
    3u,
    3u,
    32767u,
    32767u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    8189u,
    4093u,
    4105u,
    9u,
    0u,
    0u,
    4105u,
    9u,
    8191u,
    8191u,
    8190u,
    8190u,
    8190u,
    8190u,
    8190u,
    8190u,
    4104u,
    4100u,
    8u,
    4u,
    32768u,
    32768u
  },
  {
    0u,
    23u,
    19u,
    28912u,
    20392u,
    48352u,
    17680u,
    48880u,
    34048u,
    24448u,
    21696u,
    881u,
    687u,
    741u,
    479u,
    688u,
    471u,
    856u,
    618u,
    470u,
    286u,
    301u,
    177u,
    287u,
    89u,
    416u,
    227u,
    88u,
    64u,
    40u,
    20u,
    32768u,
    32768u
  }
};

// ssinit.o

unsigned int snd_vmask_ = 0u;
static s16 volume_dat_2[16] = { 16383, 16383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

// ssinit_c.o

s16 gPitchCorrect = 0;

// ssstart.o

libsnd2_seq_tick_env_t snd_seq_tick_env_ = { 60, 1, &SsSeqCalledTbyT, NULL, 0u, 0u, 127u, 0u };
int snd_seq_interval_ = 1;

// dmyprint.o

static int is_first_dmy_SsNoteOn = 0;
static int is_first_dmy_SsSetProgramChange = 0;
static int is_first_dmy_SsGetMetaEvent = 0;
static int is_first_dmy_SsSetPitchBend = 0;
static int is_first_dmy_SsSetControlChange = 0;
static int is_first_dmy_SsContBankChange = 0;
static int is_first_dmy_SsContDataEntry = 0;
static int is_first_dmy_SsContMainVol = 0;
static int is_first_dmy_SsContPanpot = 0;
static int is_first_dmy_SsContExpression = 0;
static int is_first_dmy_SsContDamper = 0;
static int is_first_dmy_SsContExternal = 0;
static int is_first_dmy_SsContNrpn1 = 0;
static int is_first_dmy_SsContNrpn2 = 0;
static int is_first_dmy_SsContRpn1 = 0;
static int is_first_dmy_SsContRpn2 = 0;
static int is_first_dmy_SsContResetAll = 0;
static int is_first_dmy_SsSetNrpnVabAttr0 = 0;
static int is_first_dmy_SsSetNrpnVabAttr1 = 0;
static int is_first_dmy_SsSetNrpnVabAttr2 = 0;
static int is_first_dmy_SsSetNrpnVabAttr3 = 0;
static int is_first_dmy_SsSetNrpnVabAttr4 = 0;
static int is_first_dmy_SsSetNrpnVabAttr5 = 0;
static int is_first_dmy_SsSetNrpnVabAttr6 = 0;
static int is_first_dmy_SsSetNrpnVabAttr7 = 0;
static int is_first_dmy_SsSetNrpnVabAttr8 = 0;
static int is_first_dmy_SsSetNrpnVabAttr9 = 0;
static int is_first_dmy_SsSetNrpnVabAttr10 = 0;
static int is_first_dmy_SsSetNrpnVabAttr11 = 0;
static int is_first_dmy_SsSetNrpnVabAttr12 = 0;
static int is_first_dmy_SsSetNrpnVabAttr13 = 0;
static int is_first_dmy_SsSetNrpnVabAttr14 = 0;
static int is_first_dmy_SsSetNrpnVabAttr15 = 0;
static int is_first_dmy_SsSetNrpnVabAttr16 = 0;
static int is_first_dmy_SsSetNrpnVabAttr17 = 0;
static int is_first_dmy_SsSetNrpnVabAttr18 = 0;
static int is_first_dmy_SsSetNrpnVabAttr19 = 0;

// vm_n2p.o

static u16 svm_ntable_[12] =
{
  32768u,
  34716u,
  36780u,
  38967u,
  41285u,
  43740u,
  46340u,
  49096u,
  52015u,
  55108u,
  58385u,
  61857u
};
static u16 svm_ftable_[128] =
{
  32768u,
  32782u,
  32797u,
  32812u,
  32827u,
  32842u,
  32856u,
  32871u,
  32886u,
  32901u,
  32916u,
  32931u,
  32945u,
  32960u,
  32975u,
  32990u,
  33005u,
  33020u,
  33035u,
  33050u,
  33065u,
  33080u,
  33094u,
  33109u,
  33124u,
  33139u,
  33154u,
  33169u,
  33184u,
  33199u,
  33214u,
  33229u,
  33244u,
  33259u,
  33274u,
  33289u,
  33304u,
  33319u,
  33334u,
  33349u,
  33364u,
  33379u,
  33394u,
  33410u,
  33425u,
  33440u,
  33455u,
  33470u,
  33485u,
  33500u,
  33515u,
  33530u,
  33546u,
  33561u,
  33576u,
  33591u,
  33606u,
  33621u,
  33636u,
  33652u,
  33667u,
  33682u,
  33697u,
  33712u,
  33728u,
  33743u,
  33758u,
  33773u,
  33789u,
  33804u,
  33819u,
  33834u,
  33850u,
  33865u,
  33880u,
  33896u,
  33911u,
  33926u,
  33941u,
  33957u,
  33972u,
  33987u,
  34003u,
  34018u,
  34033u,
  34049u,
  34064u,
  34080u,
  34095u,
  34110u,
  34126u,
  34141u,
  34157u,
  34172u,
  34187u,
  34203u,
  34218u,
  34234u,
  34249u,
  34265u,
  34280u,
  34296u,
  34311u,
  34327u,
  34342u,
  34358u,
  34373u,
  34389u,
  34404u,
  34420u,
  34435u,
  34451u,
  34466u,
  34482u,
  34497u,
  34513u,
  34528u,
  34544u,
  34560u,
  34575u,
  34591u,
  34606u,
  34622u,
  34638u,
  34653u,
  34669u,
  34685u,
  34700u
};

// vs_vtbp.o

static s16 vabid_old_2 = -1;

// .bss

static SpuEECBData eeCBData;

static int gMode;
static int gWhichBuff;
static u8 *gHostAddr;
static int gBufferSize48;

static SpuStEnv spu_st_Info_;
static u32 spu_st_buf_sizeSBhalf_; // idb
static int spu_st_save_final_block_[98];
static int spu_st_start_prepare_voice_current_;
static SpuTransferCallbackProc spu_st_cb_transfer_saved_;
static SpuStCallbackProc spu_st_cb_prepare_finished_;
static int spu_st_start_prepare_lock_;
static int spu_st_bufferP_;
static int spu_st_start_voice_smallest_;
static int spu_st_stop_voice_smallest_;
static SpuIRQCallbackProc spu_st_cb_IRQ_saved_;
static SpuStCallbackProc spu_st_cb_stream_finished_;
static unsigned int spu_st_addrIRQ_;
static int spu_st_start_tmp_voice_current_; // idb
static int spu_st_start_add_lock_;
static SpuStCallbackProc spu_st_cb_transfer_finished_;
static int spu_st_start_prepare_voice_smallest_;

// .scommon

int VBLANK_MINUS;
int spu_core_;
VabHdr *svm_vh_;
s16 svm_stereo_mono_;
u16 svm_onos2_;
ProgAtr *svm_pg_;
s16 svm_damper_;
s16 snd_seq_t_max_;
u16 svm_okon2_;
libsnd2_auto_vol_pan_callback autovol_;
int svm_envx_ptr_;
u16 svm_okof2_;
u16 gDMADeliverEvent;
u8 svm_auto_kof_mode_;
s16 kMaxPrograms;
u16 svm_orev1_;
u16 svm_onos1_;
VagAtr *svm_tn_;
unsigned int snd_openflag_;
u16 svm_okon1_;
s16 snd_seq_s_max_;
u16 svm_okof1_;
int snd_ev_flag_;
int svm_vab_not_send_size_;
char SsVmMaxVoice_;
libsnd2_auto_vol_pan_callback autopan_;
s16 svm_vab_count_;
u16 svm_orev2_;
libspu2_malloc_t top[32]; // idb
int svm_vab_total_[16];
libsnd2_sequence_marker_t SsMarkCallback_[32];
SpuReverbAttr svm_rattr_;
int svm_vab_start_[16];
ProgAtr *svm_vab_pg_[16];
libsnd2_spu_voice_t svm_voice_[24];
unsigned int svm_envx_hist_[16];
s16 gVabOffet[16];
_SsFCALL SsFCALL;
VabHdr *svm_vab_vh_[16];
char svm_sreg_dirty_[24];
libsnd2_reg_buffer_struct_t svm_sreg_buf_[24];
libsnd2_reg_buffer_struct_2_t svm_sreg_buf2_[24];
VagAtr *svm_vab_tn_[16];
libsnd2_sequence_struct_t *ss_score_[32];
char svm_vab_used_[16];
libsnd2_svm_t svm_cur_;
u16 spu_RQ_[16];

SpuStEnv *gStPtr;
int gStThid;
char seq_table[3520]; // sizeof(libsnd2_sequence_struct_t) * 20
SpuVoiceAttr s_attr;
SpuCommonAttr c_attr;
char spu_malloc_rec[1032]; // sizeof(libspu2_malloc_t) * 129
SpuReverbAttr r_attr;
int gRpcArg[384];
char status[24];
SpuStEnv gStBuff;
SifRpcClientData_t cd;

// rsd_main.o

int __fastcall start()
{
  const int *BootMode; // [sp+10h] [+10h]
  iop_thread_t param; // [sp+18h] [+18h] BYREF
  int th; // [sp+30h] [+30h]

  FlushDcache();
  BootMode = QueryBootMode(3);
  if ( BootMode && (BootMode[1] & 2) != 0 )
    return 1;
  CpuEnableIntr();
  param.attr = 0x2000000;
  param.thread = create_th;
  param.priority = 32;
#ifdef LIB_OSD_100
  param.stacksize = 512;
#else
  param.stacksize = 1024;
#endif
  param.option = 0;
  th = CreateThread(&param);
  if ( th <= 0 )
    return 1;
  StartThread(th, 0);
  return 0;
}

void __fastcall create_th(void *userdata)
{
  iop_thread_t param; // [sp+10h] [+10h] BYREF
  int th; // [sp+28h] [+28h]

  (void)userdata;

  if ( !sceSifCheckInit() )
    sceSifInit();
  sceSifInitRpc(0);
  param.attr = 0x2000000;
  param.thread = sce_spu2_loop;
  param.priority = 34;
#ifdef LIB_OSD_100
  param.stacksize = 2048;
#else
  param.stacksize = 4096;
#endif
  param.option = 0;
  th = CreateThread(&param);
  StartThread(th, 0);
#if 0
  param.attr = 0x2000000;
  param.thread = sce_osd_spu2_loop;
  param.priority = 35;
#ifdef LIB_OSD_100
  param.stacksize = 4096;
#else
  param.stacksize = 0x2000;
#endif
  param.option = 0;
  gSth = CreateThread(&param);
  StartThread(gSth, 0);
#endif
  SleepThread();
}

// rsd_com.o

#ifndef LIB_OSD_100
static u8 *g_AutoDmaBuf;
static int g_AutoDmaBufSize;
#endif

#ifndef LIB_OSD_100
static void AutoDmaStatusCB(void)
{
  if ( g_AutoDmaIntrCount < 4 && g_AutoDmaIntrCount >= 0 )
    ++g_AutoDmaIntrCount;
}

#ifdef LIB_OSD_110
static void AutoDmaClearBuffer(void)
{
  SpuSetTransferStartAddr(0x4800u);
  SpuWrite0(0x800u);
  SpuIsTransferCompleted(1);
}
#endif
#endif

void __fastcall sce_spu2_loop(void *userdata)
{
  SifRpcDataQueue_t qd; // [sp+20h] [+20h] BYREF
  SifRpcServerData_t sd; // [sp+38h] [+38h] BYREF

  (void)userdata;

  CpuEnableIntr();
  EnableIntr(36);
  EnableIntr(40);
  EnableIntr(9);
  sceSifSetRpcQueue(&qd, GetThreadId());
  sceSifRegisterRpc(&sd, 0x80000601, (SifRpcFunc_t)spuFunc, gRpcArg, 0, 0, &qd);
  sceSifRpcLoop(&qd);
}

int __fastcall AutoDmaWaitForCompletion(unsigned int played_size, int start_wait_count)
{
  for ( ; start_wait_count <= 949999; start_wait_count += 1 )
  {
    unsigned int v3;
    unsigned int v4;

    v3 = SpuAutoDMAGetStatus();
    if ( (((v3 >> 24)) & 0xFF) == 1 )
      v4 = (v3 & 0xFFFFFF) - (_DWORD)g_AutoDmaBuf - g_AutoDmaBufSize / 2;
    else
      v4 = (v3 & 0xFFFFFF) - (_DWORD)g_AutoDmaBuf;
    if ( v4 >= played_size )
      break;
  }
  return start_wait_count;
}

void *__fastcall spuFunc(unsigned int command, void *data, int size)
{
  (void)size;

  switch (command)
  {
    case 0x0001: SpuInit(); break;
    case 0x0002: ret = SpuSetCore(*((_DWORD *)data + 1)); break;
    case 0x0005: SpuSetKey(*((_DWORD *)data + 1), *((_DWORD *)data + 2)); break;
    case 0x0006: ret = SpuSetReverb(*((_DWORD *)data + 1)); break;
    case 0x0007: ret = SpuClearReverbWorkArea(*((_DWORD *)data + 1)); break;
    case 0x0008: SpuSetReverbEndAddr(*((_DWORD *)data + 1)); break;
    case 0x000A: SpuSetReverbModeDepth(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x000B: ret = SpuSetReverbVoice(*((_DWORD *)data + 1), *((_DWORD *)data + 2)); break;
    case 0x000C: ret = SpuSetIRQ(*((_DWORD *)data + 1)); break;
    case 0x000D: ret = SpuSetIRQAddr(*((_DWORD *)data + 1)); break;
    case 0x000E: ret = SpuSetTransferMode(*((_DWORD *)data + 1)); break;
    case 0x0010: ret = SpuSetTransferStartAddr(*((_DWORD *)data + 1)); break;
    case 0x0011: ret = SpuWrite(*((u8 **)data + 1), *((_DWORD *)data + 2)); break;
    case 0x0012: ret = SpuWrite0(*((_DWORD *)data + 1)); break;
    case 0x0013: ret = SpuIsTransferCompleted(*((_DWORD *)data + 1)); break;
    case 0x0017: ret = SpuGetReverbEndAddr(); break;
    case 0x0018: ret = SpuWritePartly(*((u8 **)data + 1), *((_DWORD *)data + 2)); break;
    case 0x0019: SpuInitHot(); break;
    case 0x001A: ret = SpuIsReverbWorkAreaReserved(*((_DWORD *)data + 1)); break;
    case 0x001B: ret = SpuMallocWithStartAddr(*((_DWORD *)data + 1), *((_DWORD *)data + 2)); break;
    case 0x001C: ret = SpuRead(*((u8 **)data + 1), *((_DWORD *)data + 2)); break;
    case 0x001D: ret = SpuReadDecodedData(*((SpuDecodedData **)data + 1), *((_DWORD *)data + 2)); break;
    case 0x001E: ret = SpuReserveReverbWorkArea(*((_DWORD *)data + 1)); break;
    case 0x0020: ret = SpuSetMute(*((_DWORD *)data + 1)); break;
    case 0x0021: ret = SpuSetNoiseClock(*((_DWORD *)data + 1)); break;
    case 0x0022: ret = SpuSetNoiseVoice(*((_DWORD *)data + 1), *((_DWORD *)data + 2)); break;
    case 0x0023: ret = SpuSetPitchLFOVoice(*((_DWORD *)data + 1), *((_DWORD *)data + 2)); break;
    case 0x0024: ret = SpuStGetStatus(); break;
    case 0x0025: ret = SpuStGetVoiceStatus(); break;
    case 0x0100: ret = SpuInitMalloc(*((_DWORD *)data + 1), spu_malloc_rec); break;
    case 0x0101: ret = SpuMalloc(*((_DWORD *)data + 1)); break;
    case 0x0200:
    {
      gStPtr = SpuStInit(*((_DWORD *)data + 1));
      ret = (int)&gStBuff;
      SpuStSetPreparationFinishedCallback(spustCB_preparation_finished);
      SpuStSetTransferFinishedCallback(spustCB_transfer_finished);
      SpuStSetStreamFinishedCallback(spustCB_stream_finished);
      break;
    }
    case 0x0201: ret = SpuStQuit(); break;
    case 0x0202:
    {
      memcpy(gStPtr, &gStBuff, sizeof(SpuStEnv));
      ret = SpuStTransfer(*((_DWORD *)data + 1), *((_DWORD *)data + 2));
      break;
    }
    case 0x0203: ret = SpuStSetCore(*((_DWORD *)data + 1)); break;
    case 0x100C: ret = SpuGetIRQAddr(); break;
    case 0x1010: ret = SpuFlush(*((_DWORD *)data + 1)); break;
    case 0x1011: SpuFree(*((_DWORD *)data + 1)); break;
    case 0x1013: ret = SpuGetIRQ(); break;
    case 0x1014: ret = SpuGetMute(); break;
    case 0x1015: ret = SpuGetNoiseClock(); break;
    case 0x1016: ret = SpuGetNoiseVoice(); break;
    case 0x1017: ret = SpuGetPitchLFOVoice(); break;
    case 0x1018: ret = SpuGetReverb(); break;
    case 0x1019: ret = SpuGetReverbVoice(); break;
    case 0x101A: ret = SpuGetTransferMode(); break;
    case 0x101B: ret = SpuGetTransferStartAddr(); break;
    case 0x101C: ret = SpuGetKeyStatus(*((_DWORD *)data + 1)); break;
    case 0x1020:
    {
#ifdef LIB_OSD_100
      ret = SpuAutoDMAWrite(*((u8 **)data + 1), *((_DWORD *)data + 2), *((_DWORD *)data + 3));
#else
      if ( g_AutoDmaInProcessing )
      {
        ret = 0;
      }
      else
      {
        _DWORD *v7; // $s1
        int ii; // $s3
        int jj; // $s2
        int kk; // $s2

#ifdef LIB_OSD_110
        AutoDmaClearBuffer();
#endif
        SpuAutoDMASetCallback(AutoDmaStatusCB);
        g_AutoDmaBuf = (u8 *)*((_DWORD *)data + 1);
        g_AutoDmaBufSize = *((_DWORD *)data + 2);
        v7 = (_DWORD *)(g_AutoDmaBuf + 12288);
        memset((void *)g_AutoDmaBuf, 0, 12288);
        for ( ii = 0; ii < 512; ii += 128 )
        {
          for ( jj = 0; jj < 128; ++jj )
          {
            *v7 = *v7 / 512 * (jj + ii);
            ++v7;
          }
          for ( kk = 0; kk < 128; ++kk )
          {
            *v7 = *v7 / 512 * (kk + ii);
            ++v7;
          }
        }
        g_AutoDmaIntrCount = 10;
        ret = SpuAutoDMAWrite(*((u8 **)data + 1), *((_DWORD *)data + 2), *((_DWORD *)data + 3));
        g_AutoDmaInProcessing = 1;
      }
#endif
      break;
    }
    case 0x1021:
    {
#ifdef LIB_OSD_100
      SpuAutoDMAStop();
#else
      int n;
      _DWORD *v3; // $s0
      void *v4; // $s1
      int v5; // $s4
      int v11; // $s2
      int j; // $s3
      int k; // $s2
      int m; // $s2
#ifndef LIB_OSD_110
      _DWORD *v12; // $s5
      int v19; // [sp+38h] [+38h]
      int v20; // [sp+3Ch] [+3Ch]
      size_t sizea; // [sp+40h] [+40h]
#endif

      if ( g_AutoDmaInProcessing )
      {
        v11 = SpuAutoDMAGetStatus();
        if ( v11 >> 24 == 1 )
          v5 = (v11 & 0xFFFFFF) - (_DWORD)g_AutoDmaBuf - g_AutoDmaBufSize / 2;
        else
          v5 = (v11 & 0xFFFFFF) - (_DWORD)g_AutoDmaBuf;
#ifdef LIB_OSD_110
        if ( v5 > 49151 )
#else
        if ( v5 >= 24576 )
#endif
        {
          while ( v5 <= 61439 )
          {
            v5 = SpuAutoDMAGetStatus();
            if ( v5 >> 24 == 1 )
              v5 = (v5 & 0xFFFFFF) - (_DWORD)g_AutoDmaBuf - g_AutoDmaBufSize / 2;
            else
              v5 = (v5 & 0xFFFFFF) - (_DWORD)g_AutoDmaBuf;
          }
#ifndef LIB_OSD_110
          v19 = 0;
          v20 = 7168;
          sizea = 0x2000;
          g_AutoDmaIntrCount = 0;
#endif
          if ( v11 >> 24 == 1 )
          {
            v3 = (_DWORD *)g_AutoDmaBuf;
            v4 = (void *)(g_AutoDmaBufSize / 2 + g_AutoDmaBuf);
          }
          else
          {
            v3 = (_DWORD *)(g_AutoDmaBufSize / 2 + g_AutoDmaBuf);
            v4 = (void *)g_AutoDmaBuf;
          }
        }
        else
        {
#ifndef LIB_OSD_110
          v19 = ((v5 + 1023) / 1024) << 10;
          v20 = 0x2000 - ((v19 + ((((v5 + 1023) / 1024) & 0x200000) != 0 ? 0x3FF : 0)) >> 10 << 7);
          sizea = 0;
          g_AutoDmaIntrCount = 0;
#endif
          if ( v11 >> 24 == 1 )
          {
            v3 = (_DWORD *)(g_AutoDmaBufSize / 2 + g_AutoDmaBuf);
            v4 = (void *)g_AutoDmaBuf;
          }
          else
          {
            v3 = (_DWORD *)g_AutoDmaBuf;
            v4 = (void *)(g_AutoDmaBufSize / 2 + g_AutoDmaBuf);
          }
        }
#ifdef LIB_OSD_110
        for ( j = 0; j < 0x2000; j += 128 )
        {
          for ( k = 0; k < 128; ++k )
          {
            *v3 = *v3 / 0x2000 * (0x2000 - j - k);
            ++v3;
          }
          for ( m = 0; m < 128; ++m )
          {
            *v3 = *v3 / 0x2000 * (0x2000 - j - m);
            ++v3;
          }
        }
        memset(v4, 0, g_AutoDmaBufSize / 2);
        g_AutoDmaIntrCount = 0;
        for ( n = 0; g_AutoDmaIntrCount < 2 && n <= 949999; ++n )
          ;
#else
        v12 = &v3[v19 / 4];
        for ( j = 0; j < v20; j += 128 )
        {
          for ( k = 0; k < 128; ++k )
          {
            if ( !v20 )
              __builtin_trap();
            if ( v20 == -1 && *v12 == 0x80000000 )
              __builtin_trap();
            *v12 = *v12 / v20 * (v20 - k - j);
            v12 += 1;
          }
          for ( m = 0; m < 128; ++m )
          {
            if ( !v20 )
              __builtin_trap();
            if ( v20 == -1 && *v12 == 0x80000000 )
              __builtin_trap();
            *v12 = *v12 / v20 * (v20 - m - j);
            v12 += 1;
          }
        }
        if ( sizea )
          memset(v12, 0, sizea);
        if ( v5 >= 24576 )
        {
          n = 0;
          for ( ; g_AutoDmaIntrCount <= 0 && n <= 949999; n += 1 ) {
          }
          memset(v4, 0, g_AutoDmaBufSize / 2);
          for ( ; g_AutoDmaIntrCount < 2 && n <= 949999; n += 1 ) {
          }
        }
        else
        {
          n = AutoDmaWaitForCompletion(0xF000u, 0);
          memset(v4, 0, g_AutoDmaBufSize / 2);
          for ( ; g_AutoDmaIntrCount <= 0 && n <= 949999; n += 1 ) {
          }
        }
        memset(v3, 0, g_AutoDmaBufSize / 2);
        AutoDmaWaitForCompletion(0x4001 - sizea, n);
#endif
        SpuAutoDMAStop();
#ifdef LIB_OSD_110
        AutoDmaClearBuffer();
#endif
        g_AutoDmaInProcessing = 0;
      }
#endif
      break;
    }
    case 0x1022: ret = SpuAutoDMAGetStatus(); break;
    case 0x1023: SpuSetAutoDMAAttr(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6), *((_WORD *)data + 8)); break;
    case 0x1024: SpuSetSerialInAttr(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x1030: gMultiVoiceNum = *((_DWORD *)data + 1); break;
    case 0x1031: SpuSetDigitalOut(*((_DWORD *)data + 1)); break;
    case 0x4001: ret = SsBlockVoiceAllocation(); break;
    case 0x4002: SsEnd(); break;
    case 0x4003: SsChannelMute(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_DWORD *)data + 3)); break;
    case 0x4004: ret = SsGetActualProgFromProg(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x4005: ret = SsGetChannelMute(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x4006: ret = (int)SsGetCurrentPoint(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x4007: ret = SsGetVoiceMask(); break;
    case 0x4008: SsInit(); break;
    case 0x4009: ret = SsIsEos(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x400A: SsAllocateVoices(*((_BYTE *)data + 4), *((_BYTE *)data + 8)); break;
    case 0x4010: SsPitchCorrect(*((_WORD *)data + 2)); break;
    case 0x4011: ret = (unsigned __int16)SsPitchFromNote(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_BYTE *)data + 12), *((_BYTE *)data + 16)); break;
    case 0x4012: SsPlayBack(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6)); break;
    case 0x4013: SsQueueKeyOn(*((_DWORD *)data + 1)); break;
    case 0x4014: SsQueueReverb(*((_DWORD *)data + 1), *((_DWORD *)data + 2)); break;
    case 0x4015: SsQuit(); break;
    case 0x4017: SsSetTableSize(seq_table, *((_WORD *)data + 4), *((_WORD *)data + 6)); break;
    case 0x4018: SsSetTickMode(*((_DWORD *)data + 1)); break;
    case 0x4019: SsSepClose(*((_WORD *)data + 2)); break;
    case 0x4020: ret = SsSepOpen((unsigned int *)data + 1, *((_WORD *)data + 4), *((_WORD *)data + 6)); break;
    case 0x4021: SsSepPause(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x4022: SsSepPlay(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_BYTE *)data + 12), *((_WORD *)data + 8)); break;
    case 0x4023: SsSepReplay(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x4024: SsSepSetAccelerando(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_DWORD *)data + 3), *((_DWORD *)data + 4)); break;
    case 0x4025: SsSepSetCrescendo(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6), *((_DWORD *)data + 4)); break;
    case 0x4026: SsSepSetDecrescendo(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6), *((_DWORD *)data + 4)); break;
    case 0x4027: SsSepSetRitardando(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_DWORD *)data + 3), *((_DWORD *)data + 4)); break;
    case 0x4028: SsSepSetVol(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6), *((_WORD *)data + 8)); break;
    case 0x4029: SsSepStop(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x4030: SsSeqGetVol(*((_WORD *)data + 2), *((_WORD *)data + 4), (s16 *)data + 6, (s16 *)data + 8); break;
    case 0x4031: ret = SsSeqOpen(*((unsigned int **)data + 1), *((_WORD *)data + 4)); break;
    case 0x4032: SsSeqPause(*((_WORD *)data + 2)); break;
    case 0x4033: SsSeqPlayPtoP(*((_WORD *)data + 2), *((_WORD *)data + 4), *((u8 **)data + 3), *((u8 **)data + 4), *((_BYTE *)data + 20), *((_WORD *)data + 12)); break;
    case 0x4034: SsSeqReplay(*((_WORD *)data + 2)); break;
    case 0x4035: SsSeqSetAccelerando(*((_WORD *)data + 2), *((_DWORD *)data + 2), *((_DWORD *)data + 3)); break;
    case 0x4036: SsSeqSetCrescendo(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_DWORD *)data + 3)); break;
    case 0x4037: SsSeqSetDecrescendo(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_DWORD *)data + 3)); break;
    case 0x4038: SsSeqSetRitardando(*((_WORD *)data + 2), *((_DWORD *)data + 2), *((_DWORD *)data + 3)); break;
    case 0x4039: SsSeqSetNext(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x4040: SsSeqCalledTbyT(); break;
    case 0x4041: SsSeqClose(*((_WORD *)data + 2)); break;
    case 0x4042: SsSeqPlay(*((_WORD *)data + 2), *((_BYTE *)data + 8), *((_WORD *)data + 6)); break;
    case 0x4043: SsSeqSetVol(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6)); break;
    case 0x4044: SsSeqSkip(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_BYTE *)data + 12), *((_WORD *)data + 8)); break;
    case 0x4045: SsSeqStop(*((_WORD *)data + 2)); break;
    case 0x4046: SsSetAutoKeyOffMode(*((_WORD *)data + 2)); break;
    case 0x4047: SsSetCurrentPoint(*((_WORD *)data + 2), *((_WORD *)data + 4), *((u8 **)data + 3)); break;
    case 0x4048: SsSetLoop(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6)); break;
    case 0x4049: SsSetMono(); break;
    case 0x404A: SsSetMVol(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x4050: SsSetNext(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6), *((_WORD *)data + 8)); break;
    case 0x4051: ret = SsSetReservedVoice(*((_BYTE *)data + 4)); break;
    case 0x4052: SsSetStereo(); break;
    case 0x4053: SsSetTempo(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6)); break;
    case 0x4054: SsSetVoiceMask(*((_DWORD *)data + 1)); break;
    case 0x4055: SsStart(); break;
    case 0x4056: SsStart2(); break;
    case 0x4057: ret = SsUnBlockVoiceAllocation(); break;
    case 0x4058: SsUtFlush(); break;
    case 0x4059: ret = SsUtGetVagAddr(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x4060: ret = SsUtGetVagAddrFromTone(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6)); break;
    case 0x4061: ret = SsUtGetVBaddrInSB(*((_WORD *)data + 2)); break;
    case 0x4062: SsVabClose(*((_WORD *)data + 2)); break;
    case 0x4063: ret = SsVabOpenHead(*((u8 **)data + 1), *((_WORD *)data + 4)); break;
    case 0x4064: ret = SsVabTransBodyPartly(*((u8 **)data + 1), *((_DWORD *)data + 2), *((_WORD *)data + 6)); break;
    case 0x4065: ret = SsVabTransCompleted(*((_WORD *)data + 2)); break;
    case 0x4066: SsVabTransBody(*((u8 **)data + 1), *((_WORD *)data + 4)); break;
    case 0x4067: ret = SsVoiceCheck(*((_DWORD *)data + 1), *((_DWORD *)data + 2), *((_WORD *)data + 6)); break;
    case 0x4068: ret = SsVoKeyOff(*((_DWORD *)data + 1), *((_DWORD *)data + 2)); break;
    case 0x4069: ret = SsVoKeyOn(*((_DWORD *)data + 1), *((_DWORD *)data + 2), *((_WORD *)data + 6), *((_WORD *)data + 8)); break;
    case 0x4070: ret = SsVabOpenHeadSticky(*((u8 **)data + 1), *((_WORD *)data + 4), *((_DWORD *)data + 3)); break;
#if 0
    case 0x5001: StInit(); break;
    case 0x5002: StQuit(); break;
    case 0x5003: StCalledVSync(); break;
    case 0x5005: ret = (__int16)StVabOpen(*((__int16 **)data + 1), *((_DWORD *)data + 2), *((_DWORD *)data + 3)); break;
    case 0x5006: ret = (__int16)StVabOpenFakeBody(*((_DWORD *)data + 1), *((_DWORD *)data + 2)); break;
    case 0x5007: StVabOpenCompleted(); break; // CHECKME
    case 0x5008: ret = (__int16)StVabClose(*((_WORD *)data + 2)); break;
    case 0x5009: ret = (__int16)StBgmOpen(*((_WORD *)data + 2), *((_DWORD *)data + 2)); break; // CHECKME
    case 0x500A: StSetTickMode(*((_WORD *)data + 2)); break;
    case 0x500B: ret = (__int16)StBgmClose(*((_WORD *)data + 2)); break;
    case 0x500C: StSetReverbType(*((_WORD *)data + 2), *((_WORD *)data + 4)); break; // CHECKME
    case 0x500D: StSetReverbDepth(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6)); break;
    case 0x500E: StSetReverbDelaytime(*((_WORD *)data + 2), *((_WORD *)data + 4)); break; // CHECKME
    case 0x500F: StSetReverbFeedback(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x5010: ret = StGetSlotStatus(*((_WORD *)data + 2)); break;
    case 0x5011: StSetSbClear(*((_DWORD *)data + 1)); break; // CHECKME
    case 0x5012: StSetMasterVol(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_WORD *)data + 6)); break;
    case 0x5013: ret = (__int16)StSetBgmVol(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x5014: StBgmPlay(*((_WORD *)data + 2)); break; // CHECKME
    case 0x5015: StBgmStop(*((_WORD *)data + 2), *((_WORD *)data + 4), *((_DWORD *)data + 3)); break;
    case 0x5016: StSetBgmTempo(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x5017: ret = (__int16)StGetBgmTempo(*((_WORD *)data + 2)); break; // CHECKME
    case 0x5018: ret = (__int16)StGetBgmStatus(); break;
    case 0x5019: ret = (__int16)StGetBgmChStatus(); break; // CHECKME
    case 0x501A: ret = (__int16)StDmaWrite(*((__int16 **)data + 1), *((_DWORD *)data + 2), *((_DWORD *)data + 3)); break;
    case 0x501B: ret = (__int16)StDmaRead(*((_DWORD *)data + 1), *((u8 **)data + 2), *((_DWORD *)data + 3)); break;
    case 0x5100: ret = SetTimer(&common); break;
    case 0x5101: ret = ReleaseTimer(); break;
    case 0x5200: ret = StSePlay(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
    case 0x5201: ret = StSetSeVol(*((_WORD *)data + 2), *((_WORD *)data + 4)); break;
#endif
    case 0x6128:
    {
      SpuGetCommonAttr(&c_attr);
      return &c_attr;
    }
    case 0x6240:
    {
      s_attr.voice = *((_DWORD *)data + 2);
      SpuGetVoiceAttr(&s_attr);
      return &s_attr;
    }
    case 0x6314:
    {
      SpuGetReverbModeParam(&r_attr);
      return &r_attr;
    }
    case 0x6418:
    {
      SpuGetAllKeysStatus(status);
      return status;
    }
    case 0x7128: SpuSetCommonAttr((SpuCommonAttr *)data); break;
    case 0x7240: SpuSetVoiceAttr((SpuVoiceAttr *)data); break;
    case 0x7314: SpuSetReverbModeParam((SpuReverbAttr *)data); break;
    case 0x7440: SpuSetKeyOnWithAttr((SpuVoiceAttr *)data); break;
    case 0x7508: SpuSetEnv((const SpuEnv *)data); break;
    case 0x7600:
    {
      int i; // [sp+18h] [+18h]

      for ( i = 0; i < gMultiVoiceNum; ++i )
        SpuSetVoiceAttr((SpuVoiceAttr *)data + i);
      break;
    }
    case 0x8100: SpuSetTransferCallback(DMA1CallBackProc); break;
    case 0x8200: SpuSetIRQCallback(IRQCallBackProc); break;
    case 0x8600: SpuAutoDMASetCallback(DMA0CallBackProc); break;
    case 0xE621:
    {
      iop_thread_t param; // [sp+20h] [+20h] BYREF

      param.attr = 0x2000000;
      param.thread = sce_spust_loop;
      param.priority = 34;
#ifdef LIB_OSD_100
      param.stacksize = 2048;
#else
      param.stacksize = 4096;
#endif
      param.option = 0;
      gStThid = CreateThread(&param);
      StartThread(gStThid, 0);
      break;
    }
  }

  return &ret;
}

// rsd_cb.o

void __fastcall sceSifCmdLoop2()
{
  while ( 1 )
  {
    if ( eeCBData.mode )
    {
      sceSifCallRpc(&cd, 0, 0, &eeCBData, 16, 0, 0, 0, 0);
      if ( eeCBData.mode < 4 )
        memcpy(gStPtr, &gStBuff, sizeof(SpuStEnv));
      eeCBData.mode = 0;
    }
    SleepThread();
  }
}

void __fastcall DMA0CallBackProc(void)
{
  eeCBData.mode = 4;
  iWakeupThread(gStThid);
}

void __fastcall DMA1CallBackProc(void)
{
  eeCBData.mode = 5;
  iWakeupThread(gStThid);
}

void __fastcall IRQCallBackProc(void)
{
  eeCBData.mode = 6;
  iWakeupThread(gStThid);
}

void __fastcall spustCB_preparation_finished(unsigned int voice_bit, int p_status)
{
  eeCBData.mode = 1;
  eeCBData.voice_bit = voice_bit;
  eeCBData.status = p_status;
  iWakeupThread(gStThid);
}

void __fastcall spustCB_transfer_finished(unsigned int voice_bit, int t_status)
{
  eeCBData.mode = 2;
  eeCBData.voice_bit = voice_bit;
  eeCBData.status = t_status;
  iWakeupThread(gStThid);
}

void __fastcall spustCB_stream_finished(unsigned int voice_bit, int s_status)
{
  eeCBData.mode = 3;
  eeCBData.voice_bit = voice_bit;
  eeCBData.status = s_status;
  iWakeupThread(gStThid);
}

void __fastcall sce_spust_loop(void *userdata)
{
  int i; // [sp+10h] [+10h]

  (void)userdata;

  eeCBData.mode = 0;
  while ( sceSifBindRpc(&cd, 0x80000603, 0) >= 0 )
  {
    for ( i = 10000; i != -1; --i )
      ;
    if ( cd.server )
      sceSifCmdLoop2();
  }
  while ( 1 )
    ;
}

// config.o

//----- (00400040) --------------------------------------------------------
void spu2_config_iop_(void)
{
  *((vu32 *)0xBF801404) = 0xBF900000;
  *((vu32 *)0xBF80140C) = 0xBF900800;
  *spu_sys_pcr_ |= 0x80000u;
  *((vu32 *)0xBF801570) |= 8u;
  *spu_delay_ = 0x200B31E1;
  *((vu32 *)0xBF801414) = 0x200B31E1;
}

//----- (004000B4) --------------------------------------------------------
static void __fastcall spu2_config_SPDIF_(int flag)
{
  *((vu16 *)0xBF9007C6) = 2304;
  *((vu16 *)0xBF9007C8) = 512;
  if ( flag )
    *((vu16 *)0xBF9007C8) = 0;
  *((vu16 *)0xBF9007CA) = 8;
}

//----- (004000F4) --------------------------------------------------------
void spu2_config_initialize_(void)
{
  spu2_config_iop_();
  spu2_config_SPDIF_(0);
}

//----- (0040011C) --------------------------------------------------------
void spu2_config_initialize_typically_(void)
{
  *((vu16 *)0xBF9007C0) = -16334;
  *((vu16 *)0xBF90019A) = -16384;
  *((vu16 *)0xBF90059A) = -16383;
  *((vu16 *)0xBF900188) = -1;
  *((vu16 *)0xBF90018A) = 255;
  *((vu16 *)0xBF900190) = -1;
  *((vu16 *)0xBF900192) = 255;
  *((vu16 *)0xBF90018C) = -1;
  *((vu16 *)0xBF90018E) = 255;
  *((vu16 *)0xBF900194) = -1;
  *((vu16 *)0xBF900196) = 255;
  *((vu16 *)0xBF900588) = -1;
  *((vu16 *)0xBF90058A) = 255;
  *((vu16 *)0xBF900590) = -1;
  *((vu16 *)0xBF900592) = 255;
  *((vu16 *)0xBF90058C) = -1;
  *((vu16 *)0xBF90058E) = 255;
  *((vu16 *)0xBF900594) = -1;
  *((vu16 *)0xBF900596) = 255;
  *((vu16 *)0xBF900198) = 4095;
  *((vu16 *)0xBF900598) = 4095;
  *((vu16 *)0xBF900760) = 0;
  *((vu16 *)0xBF900762) = 0;
  *((vu16 *)0xBF900788) = 0;
  *((vu16 *)0xBF90078A) = 0;
  *((vu16 *)0xBF900764) = 0;
  *((vu16 *)0xBF900766) = 0;
  *((vu16 *)0xBF90078C) = 0;
  *((vu16 *)0xBF90078E) = 0;
  *((vu16 *)0xBF900768) = 0;
  *((vu16 *)0xBF90076A) = 0;
  *((vu16 *)0xBF900790) = 0x7FFF;
  *((vu16 *)0xBF900792) = 0x7FFF;
  *((vu16 *)0xBF90076C) = 0;
  *((vu16 *)0xBF90076E) = 0;
  *((vu16 *)0xBF900794) = 0;
  *((vu16 *)0xBF900796) = 0;
  *((vu16 *)0xBF90033C) = 14;
  *((vu16 *)0xBF90073C) = 15;
}

//----- (004003E8) --------------------------------------------------------
void spu2_config_initialize_hot_(void)
{
  *((vu16 *)0xBF9007C0) = -16334;
  *((vu16 *)0xBF90019A) = -16256;
  *((vu16 *)0xBF90059A) = -16255;
  *((vu16 *)0xBF900188) = -1;
  *((vu16 *)0xBF90018A) = 255;
  *((vu16 *)0xBF900190) = -1;
  *((vu16 *)0xBF900192) = 255;
  *((vu16 *)0xBF90018C) = -1;
  *((vu16 *)0xBF90018E) = 255;
  *((vu16 *)0xBF900194) = -1;
  *((vu16 *)0xBF900196) = 255;
  *((vu16 *)0xBF900588) = -1;
  *((vu16 *)0xBF90058A) = 255;
  *((vu16 *)0xBF900590) = -1;
  *((vu16 *)0xBF900592) = 255;
  *((vu16 *)0xBF90058C) = -1;
  *((vu16 *)0xBF90058E) = 255;
  *((vu16 *)0xBF900594) = -1;
  *((vu16 *)0xBF900596) = 255;
  *((vu16 *)0xBF900198) = 4095;
  *((vu16 *)0xBF900598) = 4095;
  *((vu16 *)0xBF900768) = 0;
  *((vu16 *)0xBF90076A) = 0;
  *((vu16 *)0xBF900790) = 0x7FFF;
  *((vu16 *)0xBF900792) = 0x7FFF;
  *((vu16 *)0xBF90076C) = 0;
  *((vu16 *)0xBF90076E) = 0;
  *((vu16 *)0xBF900794) = 0;
  *((vu16 *)0xBF900796) = 0;
}

//----- (004005E8) --------------------------------------------------------
void spu2_config_before_compatible_(void)
{
  *((vu16 *)0xBF9007C0) = -16334;
  *((vu16 *)0xBF900188) = -1;
  *((vu16 *)0xBF90018A) = 255;
  *((vu16 *)0xBF900190) = -1;
  *((vu16 *)0xBF900192) = 255;
  *((vu16 *)0xBF90018C) = -1;
  *((vu16 *)0xBF90018E) = 255;
  *((vu16 *)0xBF900194) = -1;
  *((vu16 *)0xBF900196) = 255;
  *((vu16 *)0xBF900198) = 4095;
  *((vu16 *)0xBF90033C) = 3;
  spu2_config_SPDIF_(1);
}

// spu.o

//----- (004006A0) --------------------------------------------------------
int __fastcall spu_init_(int flag)
{
  if ( !flag )
  {
    vu16 *v2; // $v0

    *spu_sys_pcr_ |= 0xB0000u;
    v2 = &spu_RXX_[20 * spu_core_];
    v2[944] = 0;
    v2[945] = 0;
    v2[1456] = 0;
    v2[1457] = 0;
#ifndef LIB_1300
    // Added in OSDSND 110U
    *((vu16 *)0xBF9007C0) = 0;
    spu_Fw1ts_();
    spu_Fw1ts_();
    *((vu16 *)0xBF9007C0) = 0x8000;
    spu_Fw1ts_();
#endif
    for ( spu_core_ = 0; (unsigned int)spu_core_ < 2; spu_core_ += 1 )
    {
      vu16 *v7; // $a0
      vu16 *v8; // $v0
      unsigned int v9; // $a0
      vu16 *v11; // $v0
      vu16 *v12; // $v1
      int v13; // $v1

      spu_transMode_ = 0;
      spu_tsa_[spu_core_] = 0;
#ifndef LIB_1300
      // Added in OSDSND 110U
      *(_WORD *)((spu_core_ << 10) + 0xbf9001b0) = 0;
#endif
      spu_RXX_[512 * spu_core_ + 205] = 0;
      spu_Fw1ts_();
      spu_Fw1ts_();
      v7 = &spu_RXX_[512 * spu_core_];
      v7[205] = 0x8000;
      v8 = &spu_RXX_[20 * spu_core_];
      v8[944] = 0;
      v8[945] = 0;
      v9 = 1;
      while ( (v7[418] & 0x7FF) != 0 )
      {
        if ( v9 >= 0xF01 )
        {
          printf("SPU:T/O [%s]\n", "wait (reset)");
          break;
        }
        ++v9;
      }
      v11 = &spu_RXX_[20 * spu_core_];
      v12 = &spu_RXX_[512 * spu_core_];
      v11[946] = 0;
      v11[947] = 0;
      v12[210] = -1;
      v12[211] = -1;
      spu_RXX_[205] &= ~0x80u;
      for ( v13 = 0; v13 < 10; v13 += 1 )
      {
        spu_RQ_[v13] = 0;
      }
    }
    for ( spu_core_ = 0; (unsigned int)spu_core_ < 2; spu_core_ += 1 )
    {
      vu16 *v17; // $v0
      vu16 *v18; // $v0

      v17 = &spu_RXX_[512 * spu_core_];
      v17[192] = 0;
      v17[193] = 0;
      v17[194] = 0;
      v17[195] = 0;
      v18 = &spu_RXX_[20 * spu_core_];
      v18[968] = 0;
      v18[969] = 0;
      v18[970] = 0;
      v18[971] = 0;
    }
  }
  spu_core_ = 0;
  SpuStopFreeRun();
  spu_inTransfer_ = 1;
  spu_transferCallback_ = 0;
  spu_IRQCallback_ = 0;
  return 0;
}

int __fastcall spu_do_set_DmaCoreIndex(int dma_core_index)
{
  int (__fastcall *v1)(void *); // $a0

  g_DmaCoreIndex = dma_core_index;
  if ( dma_core_index )
  {
    SpuDataCallback_(spu_FiAutoDMA_);
    v1 = spu_FiDMA_;
  }
  else
  {
    SpuDataCallback_(spu_FiDMA_);
    v1 = spu_FiAutoDMA_;
  }
  SpuAutoDMACallback_(v1);
  return g_DmaCoreIndex;
}

int spu_do_get_DmaCoreIndex()
{
  return g_DmaCoreIndex;
}

//----- (00400974) --------------------------------------------------------
static void __fastcall spu_FwriteByIO_(void *addr, u32 size)
{
  spu_RXX_[725] = spu_tsa_[1];
  spu_RXX_[724] = (spu_tsa_[1] >> 16) & 0xFFFF;
  while ( size )
  {
    signed __int32 v6; // $s0
    signed __int32 i; // $v1
    unsigned int v9; // $v1

    v6 = 64;
    if ( size < 0x41 )
      v6 = size;
    for ( i = 0; i < v6; i += 2 )
    {
      *((vu16 *)0xBF9001AC) = *(_WORD *)((char *)addr + 2 * i);
    }
    *((vu16 *)0xBF90019A) = (*((vu16 *)0xBF90019A) & 0xFFCF) | 0x10;
    v9 = 1;
    while ( (*((vu16 *)0xBF900344) & 0x400) != 0 )
    {
      if ( v9 >= 0xF01 )
      {
        printf("SPU:T/O [%s]\n", "wait (SPU2_STATX_WRDY_M)");
        break;
      }
      ++v9;
    }
    size -= v6;
  }
  *((vu16 *)0xBF90019A) &= 0xFFCFu;
}

//----- (00400AC4) --------------------------------------------------------
int __fastcall spu_FiDMA_(void *userdata)
{
  int v1; // $v1
  unsigned int v3; // $v1

  (void)userdata;

  v1 = 1;
  while ( (*((vu16 *)0xBF900744) & 0x80) != 0 )
  {
    if ( v1 > 0x1000000 )
    {
      printf("SPU:T/O [%s]\n", "wait (SPU2_STATX_DREQ)");
      break;
    }
    ++v1;
  }
  spu_RXX_[717] &= 0xFFCFu;
  v3 = 1;
  while ( (spu_RXX_[717] & 0x30) != 0 )
  {
    if ( v3 >= 0xF01 )
      break;
    ++v3;
  }
  if ( spu_transferCallback_ )
    spu_transferCallback_();
  else
    gDMADeliverEvent = 1;
  FlushDcache();
  return 1;
}

//----- (00400BD8) --------------------------------------------------------
int __fastcall spu_FiAutoDMA_(void *userdata)
{
  (void)userdata;

#ifdef LIB_OSD_100
  if ( gMode )
  {
    gWhichBuff = 1 - gWhichBuff;
    if ( gWhichBuff )
      *spu_madr_ = (u32)&gHostAddr[512 * (gBufferSize48 / 512)];
    else
      *spu_madr_ = (u32)&gHostAddr[0];
    if ( gWhichBuff )
    {
      int v1; // $v0
      int v2; // $a1

      v1 = (gBufferSize48 / 512) << 9;
      v2 = (2 * gBufferSize48 - v1) >> 6;
      if ( 2 * gBufferSize48 - v1 < 0 )
        v2 = (2 * gBufferSize48 - v1 + 63) >> 6;
      *((vu16 *)0xBF8010C6) = v2 + ((2 * gBufferSize48 - ((gBufferSize48 / 512) << 9)) % 64 > 0);
    }
    else
    {
     *((vu16 *)0xBF8010C6) = 8 * (gBufferSize48 / 512);
    }
    *spu_chcr_ = 16777729;
  }
#else
  if ( (gMode & 1) != 0 )
  {
    gWhichBuff = 1 - gWhichBuff;
    if ( gWhichBuff )
      *(_DWORD *)(1088 * g_DmaCoreIndex + 0xBF8010C0) = (u32)&gHostAddr[512 * (gBufferSize48 / 512)];
    else
      *(_DWORD *)(1088 * g_DmaCoreIndex + 0xBF8010C0) = (u32)gHostAddr;
    if ( gWhichBuff )
      *(_WORD *)(1088 * g_DmaCoreIndex + 0xBF8010C6) = (2 * gBufferSize48 - ((gBufferSize48 / 512) << 9)) / 64
                                                 + ((2 * gBufferSize48 - ((gBufferSize48 / 512) << 9)) % 64 > 0);
    else
      *(_WORD *)(1088 * g_DmaCoreIndex + 0xBF8010C6) = 8 * (gBufferSize48 / 512);
    *(_DWORD *)(1088 * g_DmaCoreIndex + 0xBF8010C8) = 16777729;
  }
#endif
  else
  {
    *((vu16 *)0xBF90019A) &= 0xFFCFu;
    *((vu16 *)0xBF900198) &= 0xFF3Fu;
    *((vu16 *)0xBF9001B0) = 0;
  }
  if ( spu_AutoDMACallback_ )
    spu_AutoDMACallback_();
  FlushDcache();
  return 1;
}

//----- (00400DC8) --------------------------------------------------------
void __fastcall spu_Fr__(void *data, int addr, u32 size)
{
  spu_RXX_[725] = addr;
  spu_RXX_[724] = (addr >> 16) & 0xFFFF;
  spu_RXX_[717] |= 0x30u;
  spu_FsetDelayR_(1);
  *spu_madr_ = (vu32)data;
  *spu_bcr_ = (size << 16) | 0x10;
  spu_dma_mode_ = 1;
  *spu_chcr_ = 16777728;
}

//----- (00400E60) --------------------------------------------------------
int spu_t_(int count, ...)
{
  u32 v6; // $a2
  int spu_tmp; // [sp+1Ch] [+Ch]
  unsigned int ck; // [sp+20h] [+10h]
  va_list va; // [sp+24h] [+14h] BYREF

  va_start(va, count);
  spu_tmp = va_arg(va, _DWORD);
  ck = va_arg(va, _DWORD);
  va_end(va);
  switch (count)
  {
    case 0:
      spu_dma_mode_ = 1;
      spu_RXX_[717] = spu_RXX_[717] | 0x30;
      break;
    case 1:
      spu_dma_mode_ = 0;
      spu_RXX_[717] = (spu_RXX_[717] & 0xFFCF) | 0x20;
      break;
    case 2:
      spu_tsa_[1] = spu_tmp;
      spu_RXX_[725] = spu_tmp;
      spu_RXX_[724] = (spu_tsa_[1] >> 16) & 0xFFFF;
      break;
    case 3:
      if ( spu_dma_mode_ == 1 )
        spu_FsetDelayR_(1);
      else
        spu_FsetDelayW_(1);
      spu_transfer_startaddr_ = spu_tmp;
      spu_transfer_time_ = (ck >> 6) + ((ck & 0x3F) != 0);
      spu_madr_[272] = spu_tmp;
      spu_bcr_[272] = (spu_transfer_time_ << 16) | 0x10;
      v6 = 16777729;
      if ( spu_dma_mode_ == 1 )
        v6 = 16777728;
      spu_chcr_[272] = v6;
      break;
    default:
      break;
  }
  return 0;
}

//----- (0040101C) --------------------------------------------------------
int __fastcall spu_Fw_(void *addr, u32 size)
{
  if ( spu_transMode_ )
  {
    spu_FwriteByIO_(addr, size);
  }
  else
  {
    spu_t_(2, spu_tsa_[1]);
    spu_t_(1);
    spu_t_(3, addr, size);
  }
  return size;
}

//----- (00401094) --------------------------------------------------------
int spu_StopAutoDMA_(void)
{
#ifdef LIB_1300
  *((vu16 *)0xBF90019A) &= 0xFFCFu;
#else
  int v0; // $t1

  v0 = 0;
#ifdef LIB_OSD_100
  if ( *((vu16 *)0xBF9001B0) )
    v0 = *spu_madr_;
  *spu_chcr_ &= ~0x1000000u;
#else
  int do_set_dmacoreindex; // $t3
  _WORD *v2; // $t2

  do_set_dmacoreindex = 0;
  if ( (*((vu16 *)0xBF9007C0) & 4) != 0 )
  {
    do_set_dmacoreindex = 1;
    *((vu16 *)0xBF9007C0) &= 0xFF3Fu;
  }
  v2 = (_WORD *)((g_DmaCoreIndex << 10) + 0xBF9001B0);
  if ( *v2 )
    v0 = *(_DWORD *)(1088 * g_DmaCoreIndex + 0xBF8010C0);
  *(_DWORD *)(1088 * g_DmaCoreIndex + 0xBF8010C8) &= ~0x1000000u;
#endif
#endif
#ifdef LIB_OSD_100
  *((vu16 *)0xBF900198) &= 0xFF0Fu;
  *((vu16 *)0xBF9001B0) = 0;
  *((vu16 *)0xBF90076E) = 0;
  *((vu16 *)0xBF90076C) = 0;
#else
  *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF900198) &= 0xFF0Fu;
  *v2 = 0;
  *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF90076E) = 0;
  *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF90076C) = *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF90076E);
  if ( (*((vu16 *)0xBF9007C0) & 4) != 0 )
    *((vu16 *)0xBF9007C0) &= 0xFF3Bu;
  if ( do_set_dmacoreindex )
    spu_do_set_DmaCoreIndex(0);
#endif
#ifdef LIB_1300
  return 0;
#else
  return (gWhichBuff << 24) | (v0 & 0xFFFFFF);
#endif
}

//----- (00401130) --------------------------------------------------------
int spu_AutoDMAGetStatus_(void)
{
  int v0; // $a0

  v0 = 0;
#ifdef LIB_OSD_100
  if ( *((vu16 *)0xBF9001B0) )
    v0 = *spu_madr_;
#else
  if ( *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF9001B0) )
    v0 = *(_DWORD *)(1088 * g_DmaCoreIndex + 0xBF8010C0);
#endif
  return (gWhichBuff << 24) | (v0 & 0xFFFFFF);
}

//----- (00401174) --------------------------------------------------------
unsigned int __fastcall spu_FwAutoDMA_(u8 *addr, unsigned int size, int mode)
{
  gHostAddr = addr;
  gWhichBuff = 0;
  gBufferSize48 = size;
  gMode = mode;
#ifdef LIB_OSD_100
  *((vu16 *)0xBF90019A) &= 0xFFCFu;
  *((vu16 *)0xBF9001A8) = 0;
  *((vu16 *)0xBF9001AA) = 0;
  *((vu16 *)0xBF9001B0) = 1;
  *spu_madr_ = (u32)addr;
  *spu_bcr_ = 16;
  *((vu16 *)0xBF8010C6) = 8 * ((int)size / 512);
  *spu_chcr_ = 16777729;
  *((vu16 *)0xBF900198) |= 0xC0u;
  *((vu16 *)0xBF90076E) = 0x7FFF;
  *((vu16 *)0xBF90076C) = 0x7FFF;
#else
  if ( (mode & 0x11) != 0 )
  {
    spu_do_set_DmaCoreIndex(1);
    *((vu16 *)0xBF9007C0) |= 4u;
  }
  *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF90019A) &= 0xFFCFu;
  *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF9001A8) = 0;
  *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF9001AA) = 0;
  if ( g_DmaCoreIndex != 0 )
    *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF9001B0) = 2;
  else
    *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF9001B0) = 1;
  spu_FsetDelayW_(g_DmaCoreIndex);
  *(_DWORD *)(((17 * g_DmaCoreIndex) << 6) + 0xBF8010C0) = (u32)addr;
  *(_WORD *)(((17 * g_DmaCoreIndex) << 6) + 0xBF8010C4) = 16;
  *(_WORD *)(((17 * g_DmaCoreIndex) << 6) + 0xBF8010C6) = 8 * (gBufferSize48 / 512);
  if ( (mode & 0x11) != 0 )
  {
    __int16 v15; // $a0

    v15 = mode & 0x40;
    if ( (mode & 0x80) != 0 )
      v15 |= 0x80;
    *((vu16 *)0xBF9007C0) |= v15;
  }
  *(_DWORD *)((1088 * g_DmaCoreIndex) + 0xBF8010C8) = 16777729;
  if ( (mode & 0x10) == 0 )
  {
    *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF900198) |= 0xC0u;
    *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF90076E) = 0x7FFF;
    *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF90076C) = 0x7FFF;
  }
#endif
  return size;
}

//----- (00401270) --------------------------------------------------------
unsigned int __fastcall spu_FwAutoDMAfrom_(u8 *addr, unsigned int size, int mode, u8 *unk_a4)
{
  u8 *v4; // $t2
  int v5; // $t1
#ifdef LIB_OSD_100
  int v7; // $v1
#endif

  v4 = unk_a4;
  if ( !unk_a4 )
    v4 = addr;
  gHostAddr = addr;
  gWhichBuff = 0;
  gBufferSize48 = size;
  gMode = mode;
  v5 = size - (v4 - addr);
  if ( (unsigned int)(v4 - addr) >= size )
  {
#ifdef LIB_OSD_100
    if ( mode != 1 )
#else
    if ( (mode & 1) == 0 )
#endif
      return 0;
    ++gWhichBuff;
    v5 = size - (v4 - addr - size);
  }
  if ( v5 % 1024 > 0 )
  {
    v5 = (v5 / 1024 + 1) << 10;
    v4 = &addr[gWhichBuff * size + size - v5];
  }
#ifdef LIB_OSD_100
  *((vu16 *)0xBF90019A) &= 0xFFCFu;
  *((vu16 *)0xBF9001A8) = 0;
  *((vu16 *)0xBF9001AA) = 0;
  *((vu16 *)0xBF9001B0) = 1;
  *spu_madr_ = (u32)v4;
  *spu_bcr_ = 16;
  v7 = v5 >> 6;
  if ( v5 < 0 )
    v7 = (v5 + 63) >> 6;
  *((vu16 *)0xBF8010C6) = v7 + (v5 - (v7 << 6) > 0);
  *spu_chcr_ = 16777729;
  *((vu16 *)0xBF900198) |= 0xC0u;
  *((vu16 *)0xBF90076E) = 0x7FFF;
  *((vu16 *)0xBF90076C) = 0x7FFF;
#else
  if ( (mode & 0x11) != 0 )
  {
    spu_do_set_DmaCoreIndex(1);
    *((vu16 *)0xBF9007C0) |= 4u;
  }
  
  *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF90019A) &= 0xFFCFu;
  *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF9001A8) = 0;
  *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF9001AA) = 0;
  if ( g_DmaCoreIndex != 0 )
    *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF9001B0) = 2;
  else
    *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF9001B0) = 1;
  *(_DWORD *)((1088 * g_DmaCoreIndex) + 0xBF8010C0) = (u32)v4;
  *(_WORD *)((1088 * g_DmaCoreIndex) + 0xBF8010C4) = 16;
  *(_WORD *)((1088 * g_DmaCoreIndex) + 0xBF8010C6) = v5 / 64 + (v5 % 64 > 0);
  if ( (mode & 0x11) != 0 )
  {
    __int16 v17; // $a0

    v17 = mode & 0x40;
    if ( (mode & 0x80) != 0 )
      v17 |= 0x80;
    *((vu16 *)0xBF9007C0) |= v17;
  }
  *(_DWORD *)(1088 * g_DmaCoreIndex + 0xBF8010C8) = 16777729;
  if ( (mode & 0x10) == 0 )
  {
    *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF900198) |= 0xC0u;
    *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF90076E) = 0x7FFF;
    *(_WORD *)((g_DmaCoreIndex << 10) + 0xBF90076C) = 0x7FFF;
  }
#endif
  return size;
}

//----- (00401400) --------------------------------------------------------
void __fastcall spu_Fr_(void *addr, u32 size)
{
  spu_t_(2, spu_tsa_[1]);
  spu_t_(0);
  spu_t_(3, addr, size);
}

//----- (00401458) --------------------------------------------------------
void __fastcall spu_MGFsetRXX2_(int offset, int value)
{
  int v2; // $a1
  vu16 *v3; // $v0

  v2 = 4 * value;
  v3 = &spu_RXX_[512 * spu_core_ + offset];
  *v3 = (v2 >> 16) & 0xFFFF;
  v3[1] = v2;
}

//----- (0040148C) --------------------------------------------------------
void __fastcall spu_FsetRXX_(int l, u32 addr, int flag)
{
  vu16 *v3; // $v0

  v3 = &spu_RXX_[512 * spu_core_ + l];
  if ( flag )
  {
    *v3 = addr >> 17;
    v3[1] = addr >> 1;
  }
  else
  {
    *v3 = addr >> 14;
    v3[1] = 4 * addr;
  }
}

//----- (004014FC) --------------------------------------------------------
int __fastcall spu_FsetRXXa_(int l, u32 flag)
{
  if ( l == -2 )
    return flag;
  if ( l == -1 )
    return flag >> 1;
  spu_RXX_[512 * spu_core_ + l] = flag >> 1;
  return flag;
}

//----- (00401550) --------------------------------------------------------
int __fastcall spu_MGFgetRXX2_(int offset)
{
  return 2 * (spu_RXX_[512 * spu_core_ + 1 + offset] | (spu_RXX_[512 * spu_core_ + offset] << 16));
}

//----- (00401588) --------------------------------------------------------
void __fastcall spu_FsetPCR_(int flag)
{
  (void)flag;
}

//----- (00401590) --------------------------------------------------------
static void __fastcall spu_FsetDelayW_(int flag)
{
  spu_delay_[256 * flag] = (spu_delay_[256 * flag] & 0xD0FFFFFF) | 0x20000000;
}

//----- (004015C0) --------------------------------------------------------
static void __fastcall spu_FsetDelayR_(int flag)
{
  spu_delay_[256 * flag] = (spu_delay_[256 * flag] & 0xD0FFFFFF) | 0x22000000;
}

//----- (004015F0) --------------------------------------------------------
void __attribute__((optimize("no-unroll-loops"))) spu_Fw1ts_(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 13;
  for ( i = 0; i < 60; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

// s_cb.o

//----- (00401650) --------------------------------------------------------
void __fastcall SpuCallback_(SpuIRQCallbackProc cb)
{
  spu_irq_callback_ = cb;
}

// s_dcb.o

//----- (00401660) --------------------------------------------------------
void __fastcall SpuDataCallback_(int (__fastcall *callback)(void *userdata))
{
  char dummyarg[8]; // [sp+10h] [-8h] BYREF

  ReleaseIntrHandler(40);
  RegisterIntrHandler(40, 1, callback, dummyarg);
}

//----- (0040169C) --------------------------------------------------------
void __fastcall SpuAutoDMACallback_(int (__fastcall *callback)(void *userdata))
{
  char dummyarg[8]; // [sp+10h] [-8h] BYREF

  ReleaseIntrHandler(36);
  RegisterIntrHandler(36, 1, callback, dummyarg);
}

// s_do.o

//----- (004016E0) --------------------------------------------------------
void __fastcall SpuSetDigitalOut(int mode)
{
  __int16 v1; // $a2
  int v2; // $v1
  __int16 v3; // $a1
  int v5; // $v1
  __int16 v6; // $a1
  __int16 v7; // $a1

  v1 = *((vu16 *)0xBF9007C0);
  v2 = mode & 0xF;
  v3 = *((vu16 *)0xBF9007C6);
  switch (v2)
  {
    case 0:
      v1 = *((vu16 *)0xBF9007C0) & 0xFED7;
      break;
    case 1:
      v3 = *((vu16 *)0xBF9007C6) & 0xFFFD;
      v1 = (*((vu16 *)0xBF9007C0) & 0xFED7) | 0x20;
      break;
    case 2:
      v3 = *((vu16 *)0xBF9007C6) | 2;
      v1 = (*((vu16 *)0xBF9007C0) & 0xFED7) | 0x100;
      break;
    case 3:
      v1 = (*((vu16 *)0xBF9007C0) & 0xFED7) | 8;
      break;
    default:
      break;
  }
  v5 = mode & 0xF0;
  if ( v5 == 128 )
    v6 = v3 | 0x8000;
  else
    v6 = v3 & 0x7FFF;
  switch (mode & 0xF00)
  {
    case 2048:
      *((vu16 *)0xBF9007C8) = 512;
      v7 = v6 | 0x1800;
      break;
    case 1024:
      *((vu16 *)0xBF9007C8) = 0;
      v7 = v6 & 0xE7FF;
      break;
    default:
      *((vu16 *)0xBF9007C8) = 512;
      v7 = (v6 & 0xE7FF) | 0x800;
      break;
  }
  *((vu16 *)0xBF9007C0) = v1;
  *((vu16 *)0xBF9007C6) = v7;
}

// s_ini.o

//----- (00401800) --------------------------------------------------------
void __fastcall SpuInit_(int mode)
{
  spu_init_(mode);
  if ( !mode )
  {
    int v2; // $a1

    for ( v2 = 0; v2 < 2; v2 += 1 )
    {
      int v4; // $a0

      for ( v4 = 0; v4 < 24; v4 += 1 )
      {
        spu_voice_centerNote_[v2][v4] = -16384;
      }
    }
  }
  SpuStart();
  if ( !mode )
  {
    spu_rev_flag_ = 0;
    spu_rev_reserve_wa_ = 0;
    spu_rev_attr_.mode = 0;
    spu_rev_attr_.depth.left = 0;
    spu_rev_attr_.depth.right = 0;
    spu_rev_attr_.delay = 0;
    spu_rev_attr_.feedback = 0;
    spu_rev_offsetaddr_ = SpuGetReverbEndAddr() - (8 * spu_rev_workareasize_[0] - 2);
    spu_FsetRXX_(368, spu_rev_offsetaddr_, 1);
  }
  spu_keystat_[0] = 0;
  spu_keystat_[1] = 0;
  spu_AllocBlockNum_ = 0;
  spu_AllocLastNum_ = 0;
  spu_memList_ = 0;
  spu_trans_mode_ = 0;
  spu_transMode_ = 0;
  spu_RQmask_ = 0;
  spu_RQvoice_ = 0;
  spu_env_ = 0;
}

//----- (0040192C) --------------------------------------------------------
int __fastcall SpuDefaultCallback_(void *userdata)
{
  (void)userdata;

  spu_irq_callback_();
  return 0;
}

//----- (00401954) --------------------------------------------------------
void SpuStart(void)
{
  int v0; // [sp+10h] [-8h] BYREF

  v0 = 0;
  spu_isCalled_ = 1;
  CpuDisableIntr();
  SpuDataCallback_(spu_FiDMA_);
  SpuAutoDMACallback_(spu_FiAutoDMA_);
  gDMADeliverEvent = 0;
  CpuEnableIntr();
  EnableIntr(36);
  EnableIntr(40);
  ReleaseIntrHandler(9);
  RegisterIntrHandler(9, 1, SpuDefaultCallback_, &v0);
}

// s_sfr.o

//----- (004019E0) --------------------------------------------------------
void SpuStopFreeRun(void)
{
  _WORD *v1; // $a2
  __int16 *v2; // $a1
  _WORD *v3; // $t0
  _WORD *v4; // $a3
  int v15; // [sp+0h] [-8h]
  int i; // [sp+0h] [-8h]
  int j; // [sp+0h] [-8h]
  int k; // [sp+0h] [-8h]

  v1 = (_WORD *)0xBF900000;
  v2 = (__int16 *)0xBF900400;
  v3 = (_WORD *)0xBF9001C0;
  v4 = (_WORD *)0xBF9005C0;
  *((vu16 *)0xBF9001A8) = 0;
  *((vu16 *)0xBF9001AA) = 10240;
  // Unofficial: Fixed out of bounds dummy array access by replacing with constant setting
  for ( v15 = 0; v15 < 16; v15 += 1 )
  {
    *((vu16 *)0xBF9001AC) = 1799u;
  }
  *((vu16 *)0xBF90019A) = (*((vu16 *)0xBF90019A) & 0xFFCF) | 0x10;
  while ( (*((vu16 *)0xBF900344) & 0x400) != 0 )
    ;
  *((vu16 *)0xBF90019A) &= 0xFFCFu;
  for ( i = 0; i < 24; ++i )
  {
    __int16 *v6; // $a1
    _WORD *v7; // $a2
    _WORD *v13; // $a3
    _WORD *v14; // $t0

    v6 = v2 + (i * 8);
    v7 = v1 + (i * 8);
    v13 = v4 + (i * 6);
    v14 = v3 + (i * 6);
    v6[0] = 0;
    v7[0] = v6[0];
    v6[1] = 0;
    v7[1] = v6[1];
    v6[2] = 0x3FFF;
    v7[2] = v6[2];
    v6[3] = 0;
    v7[3] = v6[3];
    v6[4] = 0;
    v7[4] = v6[4];
    v13[0] = 0;
    v14[0] = v13[0];
    v13[1] = 10240;
    v14[1] = v13[1];
  }
  *((vu16 *)0xBF9005A0) = -1;
  *((vu16 *)0xBF9001A0) = -1;
  *((vu16 *)0xBF9005A2) = 255;
  *((vu16 *)0xBF9001A2) = 255;
  for ( j = 0; j < 3124; ++j )
  {
    __asm__ __volatile__("" : "+g" (j) : :);
  }
  *((vu16 *)0xBF9005A4) = -1;
  *((vu16 *)0xBF9001A4) = -1;
  *((vu16 *)0xBF9005A6) = 255;
  *((vu16 *)0xBF9001A6) = 255;
  for ( k = 0; k < 3124; ++k )
  {
    __asm__ __volatile__("" : "+g" (k) : :);
  }
  *((vu16 *)0xBF900342) = 0;
  *((vu16 *)0xBF900340) = 0;
}

// s_i.o

//----- (00401C90) --------------------------------------------------------
void SpuInit(void)
{
  spu_core_ = 0;
  spu2_config_initialize_();
  SpuInit_(0);
  spu2_config_initialize_typically_();
}

//----- (00401CC8) --------------------------------------------------------
unsigned int __fastcall SpuSetCore(unsigned int which_core)
{
  unsigned int result; // $v0

  result = spu_core_;
  spu_core_ = which_core & 1;
  return result;
}

//----- (00401CE4) --------------------------------------------------------
unsigned int SpuGetCore(void)
{
  return spu_core_;
}

//----- (00401CF4) --------------------------------------------------------
void __fastcall SpuSetReverbEndAddr(unsigned int eea)
{
  int v1; // $v1

  v1 = spu_core_ << 10;
  spu_eea_[spu_core_] = (eea >> 17) & 0xF;
  *(vu16 *)((char *)spu_RXX_ + v1 + 828) = spu_eea_[spu_core_];
}

//----- (00401D4C) --------------------------------------------------------
unsigned int SpuGetReverbEndAddr(void)
{
  return (spu_RXX_[512 * spu_core_ + 414] << 17) | 0x1FFFF;
}

// s_ih.o

//----- (00401D80) --------------------------------------------------------
void SpuInitHot(void)
{
  spu2_config_initialize_();
  SpuInit_(1);
  spu2_config_initialize_hot_();
}

// s_q.o

//----- (00401DB0) --------------------------------------------------------
void SpuQuit(void)
{
  if ( spu_isCalled_ == 1 )
  {
#ifndef LIB_1300
    // Added in OSDSND 110U
    int v0[2]; // [sp+10h] [-8h] BYREF
#endif

    spu_isCalled_ = 0;
    CpuDisableIntr();
    spu_transferCallback_ = 0;
    spu_IRQCallback_ = 0;
    SpuDataCallback_(0);
    SpuAutoDMACallback_(0);
#ifndef LIB_1300
    // Added in OSDSND 110U
    ReleaseIntrHandler(40);
    ReleaseIntrHandler(36);
    ReleaseIntrHandler(9);
    DisableIntr(40, v0);
    DisableIntr(36, v0);
    DisableIntr(9, v0);
#endif
    CpuEnableIntr();
  }
}

// s_sm.o

//----- (00401E60) --------------------------------------------------------
int __fastcall SpuSetMute(int on_off)
{
  vu16 *v2; // $v0

  v2 = &spu_RXX_[512 * spu_core_];
  if ( on_off == 0 )
  {
    v2[205] |= 0x4000;
  }
  else if ( on_off == 1 )
  {
    v2[205] &= 0xBFFF;
  }
  return on_off;
}

// s_gm.o

//----- (00401ED0) --------------------------------------------------------
int SpuGetMute(void)
{
  return (spu_RXX_[512 * spu_core_ + 205] & 0x4000) == 0;
}

// s_m_int.o

//----- (00401F00) --------------------------------------------------------
void spu_gcSPU_(void)
{
  int counter_1; // $t1
  libspu2_malloc_t *p_cur_block_2; // $a1
  int counter_3; // $t1
  libspu2_malloc_t *p_next_block; // $a0
  u32 addr_area; // $a3
  u32 size_area_1; // $v1
  int idx; // $t1
  const libspu2_malloc_t *p_cur_block_3; // $v0
  u32 size_area_2; // $v0
  int alloc_last_num_1; // $t1
  u32 size_area_3; // $v0

  for ( counter_1 = 0; counter_1 <= spu_AllocLastNum_; counter_1 += 1 )
  {
    while ( (spu_memList_[counter_1].addr_area & 0x80000000) != 0 )
    {
      int list_idx; // $a2

      for ( list_idx = counter_1 + 1; spu_memList_[list_idx].addr_area == 805306367; list_idx += 1 ) {}
      p_cur_block_2 = &spu_memList_[list_idx];
      if ( (p_cur_block_2->addr_area & 0x80000000) != 0
        && (p_cur_block_2->addr_area & 0xFFFFFFF) == (spu_memList_[counter_1].addr_area & 0xFFFFFFF) + spu_memList_[counter_1].size_area )
      {
        p_cur_block_2->addr_area = 805306367;
        spu_memList_[counter_1].size_area += p_cur_block_2->size_area;
        continue;
      }
      break;
    }
  }
  if ( spu_AllocLastNum_ >= 0 )
  {
    if ( !spu_memList_[0].size_area )
      spu_memList_[0].addr_area = 805306367;
  }
  for ( counter_3 = 0; counter_3 <= spu_AllocLastNum_; counter_3 += 1 )
  {
    int counter_next; // $a2

    if ( (spu_memList_[counter_3].addr_area & 0x40000000) != 0 )
      break;
    for ( counter_next = counter_3 + 1; spu_AllocLastNum_ >= counter_next; counter_next += 1 )
    {
      p_next_block = &spu_memList_[counter_next];
      if ( (p_next_block->addr_area & 0x40000000) != 0 )
        break;
      addr_area = spu_memList_[counter_3].addr_area;
      if ( (p_next_block->addr_area & 0xFFFFFFF) < (spu_memList_[counter_3].addr_area & 0xFFFFFFF) )
      {
        spu_memList_[counter_3].addr_area = p_next_block->addr_area;
        size_area_1 = spu_memList_[counter_3].size_area;
        spu_memList_[counter_3].size_area = p_next_block->size_area;
        p_next_block->addr_area = addr_area;
        p_next_block->size_area = size_area_1;
      }
    }
  }
  for ( idx = 0; idx <= spu_AllocLastNum_; idx += 1 )
  {
    if ( (spu_memList_[idx].addr_area & 0x40000000) != 0 )
    {
      break;
    }
    if ( spu_memList_[idx].addr_area == 805306367 )
    {
      p_cur_block_3 = &spu_memList_[spu_AllocLastNum_];
      spu_memList_[idx].addr_area = p_cur_block_3->addr_area;
      size_area_2 = p_cur_block_3->size_area;
      spu_AllocLastNum_ = idx;
      spu_memList_[idx].size_area = size_area_2;
      break;
    }
  }
  for ( alloc_last_num_1 = spu_AllocLastNum_ - 1; alloc_last_num_1 >= 0; alloc_last_num_1 -= 1 )
  {
    int alloc_last_num_2; // $v1
    libspu2_malloc_t *p_prev_block; // $a0

    p_prev_block = &spu_memList_[alloc_last_num_1];
    if ( (p_prev_block->addr_area & 0x80000000) == 0 )
      break;
    alloc_last_num_2 = spu_AllocLastNum_;
    p_prev_block->addr_area = (p_prev_block->addr_area & 0xFFFFFFF) | 0x40000000;
    size_area_3 = p_prev_block->size_area;
    spu_AllocLastNum_ = alloc_last_num_1;
    p_prev_block->size_area = size_area_3 + spu_memList_[alloc_last_num_2].size_area;
  }
}

// s_m_init.o

//----- (00402200) --------------------------------------------------------
int __fastcall SpuInitMalloc(int num, char *top)
{
  libspu2_malloc_t *top_tmp;

  if ( num <= 0 )
    return 0;
  top_tmp = (libspu2_malloc_t *)top;
  spu_memList_ = top_tmp;
  spu_AllocLastNum_ = 0;
  top_tmp->addr_area = 0x40005010;
  spu_AllocBlockNum_ = num;
  top_tmp->size_area = 0x1FAFF0;
  return num;
}

// s_m_util.o

//----- (00402250) --------------------------------------------------------
int __fastcall SpuIsInAllocateArea_(u32 addr)
{
  libspu2_malloc_t *p_a; // $a1
  unsigned int ptr; // $v1

  if ( !spu_memList_ )
    return 0;
  for ( p_a = spu_memList_; ; ++p_a )
  {
    if ( (p_a->addr_area & 0x80000000) != 0 )
      continue;
    ptr = p_a->addr_area & 0xFFFFFFF;
    if ( (p_a->addr_area & 0x40000000) != 0 )
      break;
    if ( ptr >= addr || addr < ptr + p_a->size_area )
      return 1;
  }
  return 0;
}

//----- (004022D4) --------------------------------------------------------
int __fastcall SpuIsInAllocateArea__(u32 addr)
{
  return SpuIsInAllocateArea_(addr);
}

// s_m_m.o

//----- (00402300) --------------------------------------------------------
int __fastcall SpuMalloc(int size)
{
  int found_block_idx; // $s2
  u32 rev_size_zero; // $s3
  unsigned int size_adjusted; // $s1
  int p_allocated; // $s0
  libspu2_malloc_t *p_cur_block; // $a2
  u32 addr_area; // $v1
  u32 addr_area_1; // $v0
  u32 p_alloc_last_addr; // $v1
  libspu2_malloc_t *p_last_block_2; // $v0
  u32 addr_area_2; // $a1
  u32 size_area_1; // $a0
  libspu2_malloc_t *p_last_block_3; // $v1

  found_block_idx = -1;
  if ( spu_rev_reserve_wa_ )
    rev_size_zero = 0x200000 - spu_rev_offsetaddr_;
  else
    rev_size_zero = 0;
  size_adjusted = 2 * (size >> 1);
  if ( (spu_memList_->addr_area & 0x40000000) != 0 )
  {
    found_block_idx = 0;
  }
  else
  {
    int cur_idx; // $s0

    spu_gcSPU_();
    for ( cur_idx = 0; cur_idx < spu_AllocBlockNum_; cur_idx += 1 )
    {
      if ( !((spu_memList_[cur_idx].addr_area & 0x40000000) == 0
         && ((spu_memList_[cur_idx].addr_area & 0x80000000) == 0 || spu_memList_[cur_idx].size_area < size_adjusted)) )
      {
        found_block_idx = cur_idx;
        break;
      }
    }
  }
  p_allocated = found_block_idx;
  if ( found_block_idx == -1 )
  {
    return -1;
  }
  p_cur_block = &spu_memList_[p_allocated];
  addr_area = spu_memList_[p_allocated].addr_area;
  if ( (addr_area & 0x40000000) != 0 )
  {
    libspu2_malloc_t *p_last_block_1; // $v1

    if ( found_block_idx >= spu_AllocBlockNum_ )
    {
      return -1;
    }
    if ( p_cur_block->size_area - rev_size_zero < size_adjusted )
    {
      return -1;
    }
    p_last_block_1 = &spu_memList_[found_block_idx + 1];
    p_last_block_1->addr_area = ((p_cur_block->addr_area & 0xFFFFFFF) + size_adjusted) | 0x40000000;
    p_last_block_1->size_area = p_cur_block->size_area - size_adjusted;
    addr_area_1 = p_cur_block->addr_area;
    spu_AllocLastNum_ = found_block_idx + 1;
    p_cur_block->size_area = size_adjusted;
    p_cur_block->addr_area = addr_area_1 & 0xFFFFFFF;
    spu_gcSPU_();
    return spu_memList_[p_allocated].addr_area;
  }
  else
  {
    unsigned int size_area;

    size_area = p_cur_block->size_area;
    if ( size_adjusted < size_area )
    {
      p_alloc_last_addr = addr_area + size_adjusted;
      if ( spu_AllocLastNum_ < spu_AllocBlockNum_ )
      {
        p_last_block_2 = &spu_memList_[spu_AllocLastNum_];
        addr_area_2 = p_last_block_2->addr_area;
        size_area_1 = p_last_block_2->size_area;
        p_last_block_2->addr_area = p_alloc_last_addr | 0x80000000;
        p_last_block_2->size_area = size_area - size_adjusted;
        spu_AllocLastNum_ += 1;
        p_last_block_2[1].addr_area = addr_area_2;
        p_last_block_2[1].size_area = size_area_1;
      }
    }
    p_last_block_3 = &spu_memList_[found_block_idx];
    p_last_block_3->size_area = size_adjusted;
    p_last_block_3->addr_area = p_last_block_3->addr_area & 0xFFFFFFF;
    spu_gcSPU_();
    return spu_memList_[found_block_idx].addr_area;
  }
}

// s_m_wsa.o

//----- (00402590) --------------------------------------------------------
int __fastcall SpuMallocWithStartAddr(unsigned int addr, int size)
{
  int v2; // $s4
  int NeedBlock; // $s5
  int size_area; // $s7
  unsigned int v5; // $fp
  u32 v7; // $a1
  int v8; // $s1
  int v9; // $s2
  int v11; // $s6
  int v12; // $s3
  int v13; // $s0
  int v15; // $s0
  const libspu2_malloc_t *v17; // $v1
  int v20; // $a0
  libspu2_malloc_t *v22; // $v1
  int v29; // [sp+10h] [-8h]

  if ( spu_rev_reserve_wa_ )
    v7 = 0x200000 - spu_rev_offsetaddr_;
  else
    v7 = 0;
  v8 = 2 * ((int)addr >> 1);
  v9 = 2 * (size >> 1);
  if ( v8 < 20496 || (int)(0x200000 - v7) < v8 + v9 )
    return -1;
  spu_gcSPU_();
  v11 = spu_AllocBlockNum_;
  v12 = -1;
  for ( v13 = 0; v13 < spu_AllocBlockNum_; v13 += 1 )
  {
    if ( (spu_memList_[v13].addr_area & 0x40000000) != 0 )
    {
      v11 = v13;
      break;
    }
  }
  v29 = spu_AllocBlockNum_ - v11;
  for ( v15 = 0; v15 < spu_AllocBlockNum_; v15 += 1 )
  {
    int addr_area; // $a2
    int v19; // $a3

    v17 = &spu_memList_[v15];
    size_area = v17->size_area;
    addr_area = v17->addr_area;
    v2 = v17->addr_area & 0xFFFFFFF;
    v19 = size_area;
    if ( v2 < v8 )
      v19 = size_area - (v8 - v2);
    if ( v19 >= v9 )
    {
      v5 = addr_area & 0xF0000000;
      if ( (addr_area & 0xF0000000) != 0 )
      {
        NeedBlock = getNeedBlock(v8, v9, addr_area, v19);
        if ( v29 >= NeedBlock )
        {
          v12 = v15;
          break;
        }
      }
    }
  }
  if ( v12 < 0 )
  {
    return -1;
  }
  v20 = -1;
  if ( NeedBlock )
  {
    int v21; // $s0

    for ( v21 = v11; v21 > v12; v21 -= 1 )
    {
      const libspu2_malloc_t *v25; // $a0

      v25 = &spu_memList_[v11];
      if ( spu_AllocBlockNum_ >= v21 + NeedBlock )
      {
        libspu2_malloc_t *v26; // $v0

        v26 = &spu_memList_[v21 + NeedBlock];
        v26->addr_area = v25->addr_area;
        v26->size_area = v25->size_area;
      }
    }
    if ( v2 >= v8 )
    {
      libspu2_malloc_t *v28; // $v1

      v20 = v2;
      v28 = &spu_memList_[v12];
      v28[1].addr_area = (v2 + v9) | v5;
      v28->addr_area = v2;
      v28->size_area = v9;
      v28[1].size_area = size_area - v9;
    }
    else
    {
      libspu2_malloc_t *v27; // $v1

      v27 = &spu_memList_[v12];
      v27->addr_area = v2 | 0x80000000;
      v27->size_area = v8 - v2;
      v27[1].addr_area = v8;
      v27[1].size_area = v9;
      if ( NeedBlock == 2 )
      {
        v27[2].addr_area = (v8 + v9) | v5;
        v27[2].size_area = size_area - (v8 - v2) - v9;
      }
      return v8;
    }
  }
  else
  {
    v22 = &spu_memList_[v12];
    v20 = v22->addr_area & 0xFFFFFFF;
    v22->addr_area = v20;
  }
  return v20;
}
// 402734: variable 'NeedBlock' is possibly undefined
// 4027C4: variable 'v2' is possibly undefined
// 402800: variable 'v5' is possibly undefined
// 402808: variable 'size_area' is possibly undefined

//----- (00402880) --------------------------------------------------------
static int __fastcall getNeedBlock(int unk_a1, int unk_a2, int addr_area, int unk_a4)
{
  if ( (addr_area & 0xFFFFFFF) >= unk_a1 )
  {
    if ( unk_a2 != unk_a4 )
      return 1;
    return (addr_area & 0x40000000) != 0;
  }
  else
  {
    if ( unk_a2 == unk_a4 )
    {
      if ( (addr_area & 0x40000000) != 0 )
        return 2;
      return 1;
    }
  }
  return 2;
}

// s_m_f.o

//----- (004028E0) --------------------------------------------------------
void __fastcall SpuFree(unsigned int addr)
{
  int block_counter; // $a2

  for ( block_counter = 0; block_counter < spu_AllocBlockNum_; block_counter += 1 )
  {
    if ( (spu_memList_[block_counter].addr_area & 0x40000000) != 0 )
    {
      break;
    }
    if ( spu_memList_[block_counter].addr_area == addr )
    {
      spu_memList_[block_counter].addr_area = addr | 0x80000000;
      break;
    }
  }
  spu_gcSPU_();
}

// s_m_x.o

//----- (00402960) --------------------------------------------------------
void spu_print_(void)
{
  int v0; // $s1

  for ( v0 = 0; v0 <= spu_AllocBlockNum_; v0 += 1 )
  {
    printf(
      "[%d] %08lx / %08lx (%08ld)\n",
      v0,
      spu_memList_[v0].addr_area,
      spu_memList_[v0].size_area,
      spu_memList_[v0].size_area);
    if ((spu_memList_[v0].addr_area & 0x40000000) != 0)
    {
      break;
    }
  }
}

// s_se.o

//----- (00402A10) --------------------------------------------------------
void __fastcall SpuSetEnv(const SpuEnv *env)
{
  if ( !env->mask || (env->mask & 1) != 0 )
  {
    if ( env->queueing )
      spu_env_ |= 1u;
    else
      spu_env_ &= ~1u;
  }
}

// s_f.o

//----- (00402A80) --------------------------------------------------------
unsigned int __fastcall SpuFlush(unsigned int ev)
{
  // Unofficial: Fixed spu_RQ_ access offsets
  unsigned int retval; // $a2
  unsigned int ev_tmp;

  retval = 0;
  ev_tmp = ev;
  if ( ev_tmp == 0 )
  {
    ev_tmp = 0xFFFFFFFF;
  }
  if ( ((ev_tmp & 2) != 0) && (spu_RQmask_ & 2) != 0 )
  {
    vu16 *regstmp1; // $v1

    spu_RQmask_ &= ~2u;
    regstmp1 = &spu_RXX_[512 * spu_core_];
    regstmp1[192] = spu_RQ_[4];
    retval |= 2u;
    regstmp1[193] = spu_RQ_[5];
  }
  if ( ((ev_tmp & 4) != 0) && (spu_RQmask_ & 4) != 0 )
  {
    vu16 *regstmp2; // $v1

    spu_RQmask_ &= ~4u;
    regstmp2 = &spu_RXX_[512 * spu_core_];
    regstmp2[194] = spu_RQ_[6];
    retval |= 4u;
    regstmp2[195] = spu_RQ_[7];
  }
  if ( ((ev_tmp & 8) != 0) && (spu_RQmask_ & 8) != 0 )
  {
    vu16 *regstmp3; // $v1
    spu_RQmask_ &= ~8u;
    regstmp3 = &spu_RXX_[512 * spu_core_];
    regstmp3[198] = spu_RQ_[10];
    regstmp3[202] = spu_RQ_[14];
    regstmp3[199] = spu_RQ_[11];
    retval |= 8u;
    regstmp3[203] = spu_RQ_[15];
  }
  if ( ((ev_tmp & 1) != 0) && (spu_RQmask_ & 1) != 0 )
  {
    vu16 *regstmp4; // $v1
    int i1; // $a0

    spu_RQmask_ &= ~1u;
    regstmp4 = &spu_RXX_[512 * spu_core_];
    regstmp4[208] = spu_RQ_[0];
    regstmp4[209] = spu_RQ_[1];
    regstmp4[210] = spu_RQ_[2];
    regstmp4[211] = spu_RQ_[3];
    for ( i1 = 0; i1 < 4; i1 += 1 )
    {
      spu_RQ_[i1] = 0;
    }
    retval |= 1u;
    if ( (spu_env_ & 1) != 0 )
      spu_keystat_[spu_core_] = spu_RQvoice_;
  }
  return retval;
}

// s_sav.o

//----- (00402CF0) --------------------------------------------------------
unsigned int __fastcall SpuSetAnyVoice_(int on_off_flags, unsigned int voice_bits, int word_idx1, int word_idx2)
{
  // Unofficial: Fixed spu_RQ_ access offsets
  int p_register_1; // $v0
  int p_register_2; // $v1
  unsigned int ret_bits; // $t0

  if ( (spu_env_ & 1) != 0 )
  {
    p_register_1 = spu_RQ_[word_idx1 - 188];
    p_register_2 = (u8)spu_RQ_[word_idx2 - 188];
  }
  else
  {
    p_register_1 = spu_RXX_[512 * spu_core_ + word_idx1];
    p_register_2 = (u8)spu_RXX_[512 * spu_core_ + word_idx2];
  }
  ret_bits = p_register_1 | (p_register_2 << 16);
  if ( on_off_flags == 1 )
  {
    if ( (spu_env_ & 1) != 0 )
    {
      spu_RQ_[word_idx1 - 188] |= voice_bits;
      spu_RQ_[word_idx2 - 188] |= BYTE2(voice_bits);
      spu_RQmask_ |= 1 << ((word_idx1 - 210) >> 1);
    }
    else
    {
      spu_RXX_[512 * spu_core_ + word_idx1] |= voice_bits;
      spu_RXX_[512 * spu_core_ + word_idx2] |= BYTE2(voice_bits);
    }
    ret_bits |= voice_bits & 0xFFFFFF;
  }
  else if ( on_off_flags >= 2 )
  {
    if ( on_off_flags == 8 )
    {
      if ( (spu_env_ & 1) != 0 )
      {
        spu_RQ_[word_idx1 - 188] = voice_bits;
        spu_RQ_[word_idx2 - 188] = BYTE2(voice_bits);
        spu_RQmask_ |= 1 << ((word_idx1 - 210) >> 1);
      }
      else
      {
        spu_RXX_[512 * spu_core_ + word_idx1] = voice_bits;
        spu_RXX_[512 * spu_core_ + word_idx2] = BYTE2(voice_bits);
      }
      ret_bits = voice_bits & 0xFFFFFF;
    }
  }
  else if ( !on_off_flags )
  {
    if ( (spu_env_ & 1) != 0 )
    {
      spu_RQ_[word_idx1 - 188] &= ~(_WORD)voice_bits;
      spu_RQ_[word_idx2 - 188] &= ~BYTE2(voice_bits);
      spu_RQmask_ |= 1 << ((word_idx1 - 210) >> 1);
    }
    else
    {
      spu_RXX_[512 * spu_core_ + word_idx1] &= ~(_WORD)voice_bits;
      spu_RXX_[512 * spu_core_ + word_idx2] &= ~BYTE2(voice_bits);
    }
    ret_bits &= ~(voice_bits & 0xFFFFFF);
  }
  return ret_bits & 0xFFFFFF;
}

// s_gav.o

//----- (00403060) --------------------------------------------------------
unsigned int __fastcall SpuGetAnyVoice_(int word_idx1, int word_idx2)
{
  return spu_RXX_[512 * spu_core_ + word_idx1] | ((u8)spu_RXX_[512 * spu_core_ + word_idx2] << 16);
}

// s_snv.o

//----- (004030B0) --------------------------------------------------------
unsigned int __fastcall SpuSetNoiseVoice(int on_off, unsigned int voice_bit)
{
  return SpuSetAnyVoice_(on_off, voice_bit, 194, 195);
}

// s_gnv.o

//----- (004030E0) --------------------------------------------------------
unsigned int SpuGetNoiseVoice(void)
{
  return SpuGetAnyVoice_(194, 195);
}

// s_snc.o

//----- (00403110) --------------------------------------------------------
int __fastcall SpuSetNoiseClock(int n_clock)
{
  int n_clock_fixed; // $a1

  n_clock_fixed = 0;
  if ( n_clock >= 0 )
  {
    n_clock_fixed = n_clock;
    if ( n_clock >= 64 )
      n_clock_fixed = 63;
  }
  spu_RXX_[512 * spu_core_ + 205] = (spu_RXX_[512 * spu_core_ + 205] & 0xC0FF) | ((n_clock_fixed & 0x3F) << 8);
  return n_clock_fixed;
}

// s_gnc.o

//----- (00403170) --------------------------------------------------------
int SpuGetNoiseClock(void)
{
  return (u16)(spu_RXX_[512 * spu_core_ + 205] & 0x3F00) >> 8;
}

// s_sr.o

//----- (004031A0) --------------------------------------------------------
int __fastcall SpuSetReverb(int on_off)
{
  vu16 *v1; // $v0

  switch ( on_off )
  {
    case 0:
      v1 = &spu_RXX_[512 * spu_core_];
      spu_rev_flag_ = 0;
      v1[205] =  v1[205] & 0xFF7F;
      break;
    case 1:
      v1 = &spu_RXX_[512 * spu_core_];
      spu_rev_flag_ = 1;
      v1[205] = v1[205] | 0x80;
      break;
    default:
      break;
  }
  return spu_rev_flag_;
}

// s_gr.o

//----- (00403220) --------------------------------------------------------
int SpuGetReverb(void)
{
  return (spu_RXX_[512 * spu_core_ + 205] & 0x80) != 0;
}

// s_srmp.o

//----- (0040327C) --------------------------------------------------------
int __fastcall SpuSetReverbModeParam(SpuReverbAttr *attr)
{
  int b_set_spucnt; // $s7
  int b_r_mode_in_bounds; // $s5
  int b_mode_is_7_to_9_bit0x8; // $s6
  unsigned int mask; // $s2
  int b_mode_is_7_to_9_bit0x10; // $fp
  u32 flagstmp; // $v0
  libspu2_reverb_param_entry_t entry; // [sp+10h] [-50h] BYREF
  int b_clear_reverb_work_area; // [sp+58h] [-8h]

  b_set_spucnt = 0;
  b_r_mode_in_bounds = 0;
  b_mode_is_7_to_9_bit0x8 = 0;
  b_clear_reverb_work_area = 0;
  mask = attr->mask;
  b_mode_is_7_to_9_bit0x10 = 0;
  entry.flags = 0;
  if (mask == 0)
    mask = 0xFFFFFFFF;
  if ( (mask & 1) != 0 )
  {
    unsigned int mode; // $s0

    mode = attr->mode;
    if ( (mode & 0x100) != 0 )
    {
      mode &= ~0x100u;
      b_clear_reverb_work_area = 1;
    }
    b_r_mode_in_bounds = 1;
    if ( mode >= 0xA )
      return -1;
    spu_rev_attr_.mode = mode;
    spu_rev_offsetaddr_ = SpuGetReverbEndAddr() - (8 * spu_rev_workareasize_[mode] - 2);
    printf("_spu_rev_offsetaddr %x\n", spu_rev_offsetaddr_);
    memcpy(&entry, &spu_rev_param_[spu_rev_attr_.mode], sizeof(entry));
    switch ( spu_rev_attr_.mode )
    {
      case 7:
        spu_rev_attr_.feedback = 127;
        spu_rev_attr_.delay = 127;
        break;
      case 8:
        spu_rev_attr_.feedback = 0;
        spu_rev_attr_.delay = 127;
        break;
      default:
        spu_rev_attr_.feedback = 0;
        spu_rev_attr_.delay = 0;
        break;
    }
  }
  if ( ((mask & 8) != 0) && spu_rev_attr_.mode < 9 && spu_rev_attr_.mode >= 7 )
  {
    int delay_converted; // $a0

    b_mode_is_7_to_9_bit0x8 = 1;
    if ( !b_r_mode_in_bounds )
    {
      memcpy(&entry, &spu_rev_param_[spu_rev_attr_.mode], sizeof(entry));
      entry.flags = 201399296;
    }
    spu_rev_attr_.delay = attr->delay;
    entry.mLSAME = (__int16)((spu_rev_attr_.delay & 0xFFFF) << 13) / 127 - entry.dAPF1;
    delay_converted = (spu_rev_attr_.delay << 12) / 127;
    entry.mRSAME = delay_converted - entry.dAPF2;
    entry.dLSAME = entry.dRSAME + delay_converted;
    entry.mLCOMB1 = entry.mRCOMB1 + delay_converted;
    entry.mRAPF1 = entry.mRAPF2 + delay_converted;
    entry.mLAPF1 = entry.mLAPF2 + delay_converted;
  }
  if ( ((mask & 0x10) != 0) && spu_rev_attr_.mode < 9 && spu_rev_attr_.mode >= 7 )
  {
    b_mode_is_7_to_9_bit0x10 = 1;
    if ( !b_r_mode_in_bounds )
    {
      if ( b_mode_is_7_to_9_bit0x8 )
      {
        flagstmp = entry.flags | 0x80;
      }
      else
      {
        memcpy(&entry, &spu_rev_param_[spu_rev_attr_.mode], sizeof(entry));
        flagstmp = 128;
      }
      entry.flags = flagstmp;
    }
    spu_rev_attr_.feedback = attr->feedback;
    entry.vWALL = 33024 * spu_rev_attr_.feedback / 127;
  }
  if ( b_r_mode_in_bounds )
  {
    vu16 *regsptr; // $a0
    vu16 *regstmp1; // $v0

    regsptr = &spu_RXX_[512 * spu_core_];
    b_set_spucnt = (regsptr[205] >> 7) & 1;
    if ( b_set_spucnt )
      regsptr[205] &= ~0x80u;
    regstmp1 = &spu_RXX_[20 * spu_core_];
    regstmp1[946] = 0;
    regstmp1[947] = 0;
    spu_rev_attr_.depth.left = 0;
    spu_rev_attr_.depth.right = 0;
  }
  else
  {
    if ( (mask & 2) != 0 )
    {
      spu_RXX_[20 * spu_core_ + 946] = attr->depth.left;
      spu_rev_attr_.depth.left = attr->depth.left;
    }
    if ( (mask & 4) != 0 )
    {
      spu_RXX_[20 * spu_core_ + 947] = attr->depth.right;
      spu_rev_attr_.depth.right = attr->depth.right;
    }
  }
  if ( b_r_mode_in_bounds || b_mode_is_7_to_9_bit0x8 || b_mode_is_7_to_9_bit0x10 )
    spu_setReverbAttr_(&entry);
  if ( b_clear_reverb_work_area )
    SpuClearReverbWorkArea(spu_rev_attr_.mode);
  if ( b_r_mode_in_bounds )
  {
    spu_FsetRXX_(368, spu_rev_offsetaddr_, 1);
    if ( b_set_spucnt )
      spu_RXX_[512 * spu_core_ + 205] |= 0x80u;
  }
  return 0;
}

// s_grmp.o

//----- (00403760) --------------------------------------------------------
void __fastcall SpuGetReverbModeParam(SpuReverbAttr *attr)
{
  attr->mode = spu_rev_attr_.mode;
  attr->delay = spu_rev_attr_.delay;
  attr->feedback = spu_rev_attr_.feedback;
  attr->depth = spu_rev_attr_.depth;
}

// s_sra.o

//----- (004037B0) --------------------------------------------------------
void __fastcall spu_setReverbAttr_(const libspu2_reverb_param_entry_t *p_rev_param_entry)
{
  u32 flags; // $s0

  flags = p_rev_param_entry->flags;
  if ( flags == 0 )
    flags = 0xFFFFFFFF;
  if ( (flags & 1) != 0 )
    spu_MGFsetRXX2_(370, p_rev_param_entry->dAPF1);
  if ( (flags & 2) != 0 )
    spu_MGFsetRXX2_(372, p_rev_param_entry->dAPF2);
  if ( (flags & 4) != 0 )
    spu_RXX_[20 * spu_core_ + 954] = p_rev_param_entry->vIIR;
  if ( (flags & 8) != 0 )
    spu_RXX_[20 * spu_core_ + 955] = p_rev_param_entry->vCOMB1;
  if ( (flags & 0x10) != 0 )
    spu_RXX_[20 * spu_core_ + 956] = p_rev_param_entry->vCOMB2;
  if ( (flags & 0x20) != 0 )
    spu_RXX_[20 * spu_core_ + 957] = p_rev_param_entry->vCOMB3;
  if ( (flags & 0x40) != 0 )
    spu_RXX_[20 * spu_core_ + 958] = p_rev_param_entry->vCOMB4;
  if ( (flags & 0x80) != 0 )
    spu_RXX_[20 * spu_core_ + 959] = p_rev_param_entry->vWALL;
  if ( (flags & 0x100) != 0 )
    spu_RXX_[20 * spu_core_ + 960] = p_rev_param_entry->vAPF1;
  if ( (flags & 0x200) != 0 )
    spu_RXX_[20 * spu_core_ + 961] = p_rev_param_entry->vAPF2;
  if ( (flags & 0x400) != 0 )
    spu_MGFsetRXX2_(374, p_rev_param_entry->mLSAME);
  if ( (flags & 0x800) != 0 )
    spu_MGFsetRXX2_(376, p_rev_param_entry->mRSAME);
  if ( (flags & 0x1000) != 0 )
    spu_MGFsetRXX2_(378, p_rev_param_entry->mLCOMB1);
  if ( (flags & 0x2000) != 0 )
    spu_MGFsetRXX2_(380, p_rev_param_entry->mRCOMB1);
  if ( (flags & 0x4000) != 0 )
    spu_MGFsetRXX2_(382, p_rev_param_entry->mLCOMB2);
  if ( (flags & 0x8000) != 0 )
    spu_MGFsetRXX2_(384, p_rev_param_entry->mRCOMB2);
  if ( (flags & 0x10000) != 0 )
    spu_MGFsetRXX2_(386, p_rev_param_entry->dLSAME);
  if ( (flags & 0x20000) != 0 )
    spu_MGFsetRXX2_(388, p_rev_param_entry->dRSAME);
  if ( (flags & 0x40000) != 0 )
    spu_MGFsetRXX2_(390, p_rev_param_entry->mLDIFF);
  if ( (flags & 0x80000) != 0 )
    spu_MGFsetRXX2_(392, p_rev_param_entry->mRDIFF);
  if ( (flags & 0x100000) != 0 )
    spu_MGFsetRXX2_(394, p_rev_param_entry->mLCOMB3);
  if ( (flags & 0x200000) != 0 )
    spu_MGFsetRXX2_(396, p_rev_param_entry->mRCOMB3);
  if ( (flags & 0x400000) != 0 )
    spu_MGFsetRXX2_(398, p_rev_param_entry->mLCOMB4);
  if ( (flags & 0x800000) != 0 )
    spu_MGFsetRXX2_(400, p_rev_param_entry->mRCOMB4);
  if ( (flags & 0x1000000) != 0 )
    spu_MGFsetRXX2_(402, p_rev_param_entry->dLDIFF);
  if ( (flags & 0x2000000) != 0 )
    spu_MGFsetRXX2_(404, p_rev_param_entry->dRDIFF);
  if ( (flags & 0x4000000) != 0 )
    spu_MGFsetRXX2_(406, p_rev_param_entry->mLAPF1);
  if ( (flags & 0x8000000) != 0 )
    spu_MGFsetRXX2_(408, p_rev_param_entry->mRAPF1);
  if ( (flags & 0x10000000) != 0 )
    spu_MGFsetRXX2_(410, p_rev_param_entry->mLAPF2);
  if ( (flags & 0x20000000) != 0 )
    spu_MGFsetRXX2_(412, p_rev_param_entry->mRAPF2);
  if ( (flags & 0x40000000) != 0 )
    spu_RXX_[20 * spu_core_ + 962] = p_rev_param_entry->vLIN;
  if ( (flags & 0x80000000) != 0 )
    spu_RXX_[20 * spu_core_ + 963] = p_rev_param_entry->vRIN;
}

// s_rrwa.o

//----- (00403CC0) --------------------------------------------------------
int __fastcall SpuReserveReverbWorkArea(int on_off)
{
  if ( on_off )
  {
    spu_rev_reserve_wa_ = 1;
  }
  else
  {
    spu_rev_reserve_wa_ = 0;
  }
  return spu_rev_reserve_wa_;
}

// s_irwar.o

//----- (00403CF0) --------------------------------------------------------
int __fastcall SpuIsReverbWorkAreaReserved(int on_off)
{
  if ( on_off == -1 )
    return spu_rev_reserve_wa_;
  return SpuIsInAllocateArea__(spu_rev_offsetaddr_) == 0;
}

// s_srd.o

//----- (00403D30) --------------------------------------------------------
int __fastcall SpuSetReverbDepth(SpuReverbAttr *attr)
{
  unsigned int mask; // $a1

  mask = attr->mask;
  if ( mask == 0 )
    mask = 0xFFFFFFFF;
  if ( (mask & 2) != 0 )
  {
    spu_RXX_[20 * spu_core_ + 946] = attr->depth.left;
    spu_rev_attr_.depth.left = attr->depth.left;
  }
  if ( (mask & 4) != 0 )
  {
    spu_RXX_[20 * spu_core_ + 947] = attr->depth.right;
    spu_rev_attr_.depth.right = attr->depth.right;
  }
  return 0;
}

// s_srv.o

//----- (00403DE0) --------------------------------------------------------
unsigned int __fastcall SpuSetReverbVoice(int on_off, unsigned int voice_bit)
{
  SpuSetAnyVoice_(on_off, voice_bit, 198, 199);
  return SpuSetAnyVoice_(on_off, voice_bit, 202, 203);
}

// s_grv.o

//----- (00403E30) --------------------------------------------------------
unsigned int SpuGetReverbVoice(void)
{
  return 0;
}

// s_crwa.o

//----- (00403E40) --------------------------------------------------------
int __fastcall SpuClearReverbWorkArea(int mode)
{
  int ck_1; // $s5
  unsigned int m; // $s1
  unsigned int n; // $s2
  u32 t; // $s4
  int ck_2; // $s3
  void (*bk)(void); // [sp+10h] [-8h]

  bk = 0;
  ck_1 = 0;
  if ( (unsigned int)mode >= 0xA )
    return -1;
  if ( mode )
  {
    m = 8 * spu_rev_workareasize_[mode];
    n = (SpuGetReverbEndAddr() - m) >> 1;
  }
  else
  {
    m = 32;
    n = 2097120;
  }
  printf("### addr = %u  size = %u\n", n, m);
  t = spu_transMode_;
  if ( spu_transMode_ == 1 )
  {
    spu_transMode_ = 0;
    ck_1 = 1;
  }
  ck_2 = 1;
  if ( spu_transferCallback_ )
  {
    bk = spu_transferCallback_;
    spu_transferCallback_ = 0;
  }
  while ( ck_2 )
  {
    int m_tmp; // $s0

    m_tmp = 1024;
    if ( m < 0x401 )
    {
      m_tmp = m;
      ck_2 = 0;
    }
    gDMADeliverEvent = 0;
    spu_t_(2, n);
    spu_t_(1);
    spu_t_(3, spu_zerobuf_, m_tmp);
    while ( !gDMADeliverEvent )
      ;
    gDMADeliverEvent = 0;
    m -= 1024;
    n += 512;
  }
  if ( ck_1 )
    spu_transMode_ = t;
  if ( bk )
  {
    spu_transferCallback_ = bk;
  }
  return 0;
}

// s_rdd.o

//----- (00403FE0) --------------------------------------------------------
int __fastcall SpuReadDecodedData(SpuDecodedData *d_data, int flag)
{
  int v3; // $a1
  u32 v4; // $a2

  v3 = 0;
  switch (flag)
  {
    case 5:
      v4 = 32;
      break;
    case 6:
      d_data = (SpuDecodedData *)((char *)d_data + 2048);
      v3 = 256;
      v4 = 32;
      break;
    default:
      v4 = 64;
      break;
  }
  spu_Fr__(d_data, v3, v4);
  return (spu_RXX_[512 * spu_core_ + 418] & 0x800) != 0;
}

// s_si.o

//----- (00404060) --------------------------------------------------------
int __fastcall SpuSetIRQ(int on_off)
{
  int v7; // [sp+10h] [-8h] BYREF

  if ( on_off == 0 || on_off == 3 )
  {
    vu16 *v2; // $v0
    unsigned int v3; // $a0

    v2 = &spu_RXX_[512 * spu_core_];
    v2[205] &= ~0x40u;
    v3 = 1;
    while ( (v2[205] & 0x40) != 0 )
    {
      if ( v3 >= 0xF01 )
      {
        printf("SPU:T/O [%s]\n", "wait (IRQ/ON)");
        return -1;
      }
      ++v3;
    }
    DisableIntr(9, &v7);
  }
  if ( on_off == 1 || on_off == 3 )
  {
    vu16 *v5; // $v0
    unsigned int v6; // $a0

    v5 = &spu_RXX_[512 * spu_core_];
    v5[205] |= 0x40u;
    v6 = 1;
    while ( (v5[205] & 0x40) == 0 )
    {
      if ( v6 >= 0xF01 )
      {
        printf("SPU:T/O [%s]\n", "wait (IRQ/OFF)");
        return -1;
      }
      ++v6;
    }
    EnableIntr(9);
  }
  return on_off;
}

// s_gi.o

//----- (004041E0) --------------------------------------------------------
int SpuGetIRQ(void)
{
  return (spu_RXX_[512 * spu_core_ + 205] & 0x40) != 0;
}

// s_sia.o

//----- (00404210) --------------------------------------------------------
unsigned int __fastcall SpuSetIRQAddr(unsigned int addr)
{
  if ( addr > 0x1FFFF8 )
    return 0;
  spu_FsetRXX_(206, addr, 1);
#ifdef LIB_OSD_100
  return 2 * addr;
#else
  // Added in OSDSND 110U
  return 2 * (addr >> 1);
#endif
}

// s_gia.o

//----- (00404260) --------------------------------------------------------
unsigned int SpuGetIRQAddr(void)
{
  return spu_MGFgetRXX2_(206);
}

//----- (00404280) --------------------------------------------------------
unsigned int __fastcall SpuGetNextAddr(int v_num)
{
  return spu_MGFgetRXX2_(6 * v_num + 228);
}

// s_sic.o

//----- (004042B0) --------------------------------------------------------
SpuIRQCallbackProc __fastcall SpuSetIRQCallback(SpuIRQCallbackProc func)
{
  void (*v1)(void); // $s0

  v1 = spu_IRQCallback_;
  if ( func != spu_IRQCallback_ )
  {
    spu_IRQCallback_ = func;
    SpuCallback_(func);
  }
  return v1;
}

// s_sk.o

//----- (004042F0) --------------------------------------------------------
void __fastcall SpuSetKey(int on_off, unsigned int voice_bit)
{
  unsigned int voice_bit_tmp; // $a1

  voice_bit_tmp = voice_bit & 0xFFFFFF;
  if ( on_off == 0 )
  {
    if ( (spu_env_ & 1) != 0 )
    {
      spu_RQ_[2] = voice_bit_tmp & 0xFFFF;
      spu_RQ_[3] = (voice_bit_tmp >> 16) & 0xFFFF;
      spu_RQmask_ |= 1u;
      spu_RQvoice_ &= ~voice_bit_tmp;
      if ( (spu_RQ_[0] & (u16)voice_bit_tmp) != 0 )
        spu_RQ_[0] &= ~(_WORD)voice_bit_tmp;
      if ( (spu_RQ_[1] & ((voice_bit_tmp >> 16) & 0xFFFF)) != 0 )
        spu_RQ_[1] &= ~((voice_bit_tmp >> 16) & 0xFFFF);
    }
    else
    {
      spu_RXX_[512 * spu_core_ + 210] = voice_bit_tmp & 0xFFFF;
      spu_RXX_[512 * spu_core_ + 211] = (voice_bit_tmp >> 16) & 0xFFFF;
      spu_keystat_[spu_core_] &= ~voice_bit_tmp;
    }
  }
  if ( on_off == 1 )
  {
    if ( (spu_env_ & 1) != 0 )
    {
      spu_RQ_[0] = voice_bit_tmp & 0xFFFF;
      spu_RQ_[1] = (voice_bit_tmp >> 16) & 0xFFFF;
      spu_RQmask_ |= 1u;
      spu_RQvoice_ |= voice_bit_tmp;
      if ( (spu_RQ_[2] & (u16)voice_bit_tmp) != 0 )
        spu_RQ_[2] &= ~(_WORD)voice_bit_tmp;
      if ( (spu_RQ_[3] & ((voice_bit_tmp >> 16) & 0xFFFF)) != 0 )
        spu_RQ_[3] &= ~((voice_bit_tmp >> 16) & 0xFFFF);
    }
    else
    {
      spu_RXX_[512 * spu_core_ + 208] = voice_bit_tmp & 0xFFFF;
      spu_RXX_[512 * spu_core_ + 209] = (voice_bit_tmp >> 16) & 0xFFFF;
      spu_keystat_[spu_core_] |= voice_bit_tmp;
    }
  }
}

// s_gks.o

//----- (004044F0) --------------------------------------------------------
int __fastcall SpuGetKeyStatus(unsigned int voice_bit)
{
  int v1; // $a1
  int v2; // $v1

  v1 = -1;
  for ( v2 = 0; v2 < 24; v2 += 1 )
  {
    if ( (voice_bit & (1 << v2)) != 0 )
    {
      v1 = v2;
      break;
    }
  }
  if ( v1 == -1 )
  {
    return -1;
  }
  if ( (spu_keystat_[spu_core_] & (1 << v1)) != 0 )
  {
    if ( !spu_RXX_[512 * spu_core_ + 5 + 8 * v1] )
      return 3;
    return 1;
  }
  else
  {
    return 2 * (spu_RXX_[512 * spu_core_ + 5 + 8 * v1] != 0);
  }
}

// s_skowa.o

//----- (004045A0) --------------------------------------------------------
void __fastcall SpuSetKeyOnWithAttr(SpuVoiceAttr *attr)
{
  SpuSetVoiceAttr(attr);
  SpuSetKey(1, attr->voice);
}

// s_gvea.o

//----- (004045D0) --------------------------------------------------------
void __fastcall SpuGetVoiceEnvelopeAttr(int v_num, int *key_stat, s16 *envx)
{
  int v3; // $v1
  int v4; // $v0

  v3 = spu_RXX_[512 * spu_core_ + 5 + 8 * v_num];
  *envx = v3;
  v4 = v3 << 16;
  if ( (spu_keystat_[spu_core_] & (1 << v_num)) != 0 )
  {
    if ( v4 <= 0 )
      *key_stat = 3;
    else
      *key_stat = 1;
  }
  else if ( v4 <= 0 )
  {
    *key_stat = 0;
  }
  else
  {
    *key_stat = 2;
  }
}

// s_r.o

//----- (00404660) --------------------------------------------------------
unsigned int __fastcall SpuRead(u8 *addr, unsigned int size)
{
  unsigned int size_tmp; // $s0

  size_tmp = size;
  if ( size > 0x1FAFF0 )
    size_tmp = 0x1FAFF0;
  spu_Fr_(addr, size_tmp);
  if ( !spu_transferCallback_ )
    spu_inTransfer_ = 0;
  return size_tmp;
}

// s_w.o

//----- (004046C0) --------------------------------------------------------
unsigned int __fastcall SpuWrite(u8 *addr, unsigned int size)
{
  unsigned int size_tmp; // $s0

  size_tmp = size;
  if ( size > 0x1FAFF0 )
    size_tmp = 0x1FAFF0;
  spu_Fw_(addr, size_tmp);
  if ( !spu_transferCallback_ )
    spu_inTransfer_ = 0;
  return size_tmp;
}

//----- (0040471C) --------------------------------------------------------
unsigned int SpuAutoDMAWrite(u8 *addr, unsigned int size, unsigned int mode, ...)
{
#ifdef LIB_1300
  if ( mode == 1 )
    size >>= 1;
  spu_FwAutoDMA_(addr, size, mode);
  return size;
#else
  u8 *v6; // [sp+24h] [+14h]
  va_list va; // [sp+28h] [+18h] BYREF

  va_start(va, mode);
  v6 = va_arg(va, u8 *);
  va_end(va);
  if ( (mode & 1) != 0 )
    size >>= 1;
  if ( (mode & 2) != 0 )
    return spu_FwAutoDMAfrom_(addr, size, mode & 1, v6);
  return spu_FwAutoDMA_(addr, size, mode & 1);
#endif
}

//----- (0040477C) --------------------------------------------------------
int SpuAutoDMAStop(void)
{
  return spu_StopAutoDMA_();
}

//----- (0040479C) --------------------------------------------------------
int SpuAutoDMAGetStatus(void)
{
  return spu_AutoDMAGetStatus_();
}

// s_w0.o

//----- (004047C0) --------------------------------------------------------
unsigned int __fastcall SpuWrite0(unsigned int size)
{
  u32 old_tmode; // $s5
  int ck_1; // $s6
  int ck_2; // $s4
  u32 tsa; // $s2
  unsigned int written; // $s3
  void (*bk)(void); // [sp+10h] [-8h]

  old_tmode = spu_transMode_;
  bk = 0;
  ck_1 = 0;
  if ( spu_transMode_ == 1 )
  {
    spu_transMode_ = 0;
    ck_1 = 1;
  }
  ck_2 = 1;
  tsa = spu_tsa_[1];
  written = 0;
  if ( spu_transferCallback_ )
  {
    bk = spu_transferCallback_;
    spu_transferCallback_ = 0;
    written = 0;
  }
  while ( ck_2 )
  {
    unsigned int bsize_1; // $v0
    int bsize_2; // $s0

    bsize_1 = size >> 6;
    if ( size < 0x401 )
    {
      bsize_2 = bsize_1 << 6;
      ck_2 = 0;
      if ( (unsigned int)bsize_2 < size )
        bsize_2 += 64;
    }
    else
    {
      bsize_2 = 1024;
    }
    spu_t_(2, tsa);
    spu_t_(1);
    FlushDcache();
    spu_t_(3, spu_zerobuf_, bsize_2);
    while ( !gDMADeliverEvent )
      ;
    gDMADeliverEvent = 0;
    size -= 1024;
    tsa += 512;
    written += bsize_2;
  }
  if ( ck_1 )
    spu_transMode_ = old_tmode;
  if ( bk )
  {
    spu_transferCallback_ = bk;
  }
  return written;
}

// s_stsa.o

//----- (00404930) --------------------------------------------------------
unsigned int __fastcall SpuSetTransferStartAddr(unsigned int addr)
{
  if ( addr - 20496 > 0x1FAFE8 )
    return 0;
  spu_tsa_[1] = addr >> 1;
  return 2 * (addr >> 1);
}

// s_gtsa.o

//----- (00404960) --------------------------------------------------------
unsigned int SpuGetTransferStartAddr(void)
{
  return 2 * spu_tsa_[1];
}

// s_stm.o

//----- (00404970) --------------------------------------------------------
int __fastcall SpuSetTransferMode(int mode)
{
  int result; // $v0

  if ( mode != 0 )
    result = mode == 1;
  else
    result = 0;
  spu_trans_mode_ = mode;
  spu_transMode_ = result;
  return result;
}

// s_gtm.o

//----- (004049B0) --------------------------------------------------------
int SpuGetTransferMode(void)
{
  if ( spu_transMode_ && spu_transMode_ == 1 )
    spu_trans_mode_ = spu_transMode_;
  else
    spu_trans_mode_ = 0;
  return spu_trans_mode_;
}

// s_wp.o

//----- (00404A00) --------------------------------------------------------
unsigned int __fastcall SpuWritePartly(u8 *addr, unsigned int size)
{
  unsigned int size_tmp; // $s2

  size_tmp = size;
  if ( size > 0x1FAFF0 )
    size_tmp = 0x1FAFF0;
  spu_Fw_(addr, size_tmp);
  spu_tsa_[1] = ((2 * spu_tsa_[1]) + size_tmp) >> 1;
  if ( !spu_transferCallback_ )
    spu_inTransfer_ = 0;
  return size_tmp;
}

// s_itc.o

//----- (00404A90) --------------------------------------------------------
int __fastcall SpuIsTransferCompleted(int flag)
{
  int result; // $v0

  if ( spu_trans_mode_ == 1 || spu_inTransfer_ == 1 )
    return 1;
  result = (__int16)gDMADeliverEvent;
  if ( flag == 1 )
  {
    while ( !gDMADeliverEvent )
      ;
    gDMADeliverEvent = 0;
    spu_inTransfer_ = 1;
    return 1;
  }
  else if ( gDMADeliverEvent == 1 )
  {
    spu_inTransfer_ = (__int16)gDMADeliverEvent;
#ifndef LIB_1300
    // Added in OSDSND 110U
    gDMADeliverEvent = 0;
#endif
  }
  return result;
}

// s_stc.o

//----- (00404B30) --------------------------------------------------------
SpuTransferCallbackProc __fastcall SpuSetTransferCallback(SpuTransferCallbackProc func)
{
  SpuTransferCallbackProc result; // $v0

  result = spu_transferCallback_;
  if ( func != spu_transferCallback_ )
    spu_transferCallback_ = func;
  return result;
}

//----- (00404B54) --------------------------------------------------------
SpuTransferCallbackProc __fastcall SpuAutoDMASetCallback(SpuTransferCallbackProc func)
{
  SpuTransferCallbackProc result; // $v0

  result = spu_AutoDMACallback_;
  if ( func != spu_AutoDMACallback_ )
    spu_AutoDMACallback_ = func;
  return result;
}

// s_it.o

//----- (00404B80) --------------------------------------------------------
void __fastcall spu_setInTransfer_(int mode)
{
  spu_inTransfer_ = mode != 1;
}

//----- (00404BAC) --------------------------------------------------------
int spu_getInTransfer_(void)
{
  return spu_inTransfer_ != 1;
}

// s_splv.o

//----- (00404BD0) --------------------------------------------------------
unsigned int __fastcall SpuSetPitchLFOVoice(int on_off, unsigned int voice_bit)
{
  return SpuSetAnyVoice_(on_off, voice_bit, 192, 193);
}

// s_gplv.o

//----- (00404C00) --------------------------------------------------------
unsigned int SpuGetPitchLFOVoice(void)
{
  return SpuGetAnyVoice_(192, 193);
}

// s_sca.o

//----- (00404C30) --------------------------------------------------------
void __fastcall SpuSetCommonAttr(SpuCommonAttr *attr)
{
  s16 left_1; // $v1
  unsigned int mask; // $t0
  s16 right_1; // $a3
  int mov_left_part1; // $a1
  int mov_right_part1; // $a1
  vu16 *regstmp1; // $v0
  u16 attrtmp1; // $v1
  vu16 *regstmp2; // $v0
  u16 attrtmp2; // $v1
  vu16 *regstmp3; // $v0
  u16 attrtmp3; // $v1

  left_1 = 0;
  mask = attr->mask;
  right_1 = 0;
  mov_left_part1 = 0;
  mov_right_part1 = 0;
  if (mask == 0)
  {
    mask = 0xFFFFFFFF;
  }
  if ( (mask & 1) != 0 )
  {
    if ( (mask & 4) != 0 )
    {
      switch ( attr->mvolmode.left )
      {
        case 1:
          mov_left_part1 = 0x8000;
          break;
        case 2:
          mov_left_part1 = 0x9000;
          break;
        case 3:
          mov_left_part1 = 0xA000;
          break;
        case 4:
          mov_left_part1 = 0xB000;
          break;
        case 5:
          mov_left_part1 = 0xC000;
          break;
        case 6:
          mov_left_part1 = 0xD000;
          break;
        case 7:
          mov_left_part1 = 0xE000;
          break;
        default:
          left_1 = attr->mvol.left;
          break;
      }
    }
    if ( mov_left_part1 )
    {
      int left_2; // $a2

      left_2 = attr->mvol.left;
      left_1 = 127;
      if ( left_2 < 128 )
      {
        left_1 = 0;
        if ( left_2 >= 0 )
          left_1 = attr->mvol.left;
      }
    }
    spu_RXX_[20 * spu_core_ + 944] = (left_1 & 0x7FFF) | mov_left_part1;
  }
  if ( (mask & 2) != 0 )
  {
    __int16 right_masked; // $v1

    if ( (mask & 8) != 0 )
    {
      switch ( attr->mvolmode.right )
      {
        case 1:
          mov_right_part1 = 0x8000;
          break;
        case 2:
          mov_right_part1 = 36864;
          break;
        case 3:
          mov_right_part1 = 40960;
          break;
        case 4:
          mov_right_part1 = 45056;
          break;
        case 5:
          mov_right_part1 = 49152;
          break;
        case 6:
          mov_right_part1 = 53248;
          break;
        case 7:
          mov_right_part1 = 57344;
          break;
        default:
          right_1 = attr->mvol.right;
          break;
      }
    }
    right_masked = right_1 & 0x7FFF;
    if ( mov_right_part1 )
    {
      int right_2; // $a0
      s16 right_3; // $a3

      right_2 = attr->mvol.right;
      right_3 = 127;
      if ( right_2 < 128 )
      {
        right_3 = 0;
        if ( right_2 >= 0 )
          right_3 = attr->mvol.right;
      }
      right_masked = right_3 & 0x7FFF;
    }
    spu_RXX_[20 * spu_core_ + 945] = right_masked | mov_right_part1;
  }
  if ( (mask & 0x40) != 0 )
    spu_RXX_[20 * spu_core_ + 968] = attr->cd.volume.left;
  if ( (mask & 0x80) != 0 )
    spu_RXX_[20 * spu_core_ + 969] = attr->cd.volume.right;
  if ( (mask & 0x400) != 0 )
    spu_RXX_[20 * spu_core_ + 970] = attr->ext.volume.left;
  if ( (mask & 0x800) != 0 )
    spu_RXX_[20 * spu_core_ + 971] = attr->ext.volume.right;
  if ( (mask & 0x100) != 0 )
  {
    regstmp1 = &spu_RXX_[512 * spu_core_];
    if ( attr->cd.reverb )
      attrtmp1 = regstmp1[205] | 4;
    else
      attrtmp1 = regstmp1[205] & 0xFFFB;
    regstmp1[205] = attrtmp1;
  }
  if ( (mask & 0x200) != 0 )
  {
    regstmp2 = &spu_RXX_[512 * spu_core_];
    if ( attr->cd.mix )
      attrtmp2 = regstmp2[205] | 1;
    else
      attrtmp2 = regstmp2[205] & 0xFFFE;
    regstmp2[205] = attrtmp2;
  }
  if ( (mask & 0x1000) != 0 )
  {
    regstmp3 = &spu_RXX_[512 * spu_core_];
    if ( attr->ext.reverb )
      attrtmp3 = regstmp3[205] | 8;
    else
      attrtmp3 = regstmp3[205] & 0xFFF7;
    regstmp3[205] = attrtmp3;
  }
  if ( (mask & 0x2000) != 0 )
  {
    if ( attr->ext.mix )
      spu_RXX_[512 * spu_core_ + 205] |= 2u;
    else
      spu_RXX_[512 * spu_core_ + 205] &= ~2u;
  }
}

// s_gca.o

//----- (004050A0) --------------------------------------------------------
void __fastcall SpuGetCommonAttr(SpuCommonAttr *attr)
{
  s16 v2; // $a2
  const vu16 *v3; // $v0
  u16 v4; // $a0
  u16 v5; // $t0
  s16 v6; // $a1
  SpuVolume *v11; // $v0
  const vu16 *v13; // $v0
  int v14; // $v1

  v2 = 0;
  v3 = &spu_RXX_[20 * spu_core_];
  v4 = v3[944];
  v5 = v3[945];
  v6 = 0;
  if ( (v4 & 0x8000) != 0 )
  {
    switch (v4 & 0xF000)
    {
      case 0x8000:
        v2 = 1;
        break;
      case 36864:
        v2 = 2;
        break;
      case 40960:
        v2 = 3;
        break;
      case 45056:
        v2 = 4;
        break;
      case 49152:
        v2 = 5;
        break;
      case 53248:
        v2 = 6;
        break;
      case 57344:
      case 61440:
        v2 = 7;
        break;
      default:
        break;
    }
    v4 &= 0xFFFu;
  }
  if ( (v5 & 0x8000) != 0 )
  {
    switch (v5 & 0xF000)
    {
      case 0x8000:
        v6 = 1;
        break;
      case 36864:
        v6 = 2;
        break;
      case 40960:
        v6 = 3;
        break;
      case 45056:
        v6 = 4;
        break;
      case 49152:
        v6 = 5;
        break;
      case 53248:
        v6 = 6;
        break;
      case 57344:
      case 61440:
        v6 = 7;
        break;
      default:
        break;
    }
    v5 &= 0xFFFu;
  }
  if ( v4 < 0x4000u )
    attr->mvol.left = v4;
  else
    attr->mvol.left = v4 + 0x8000;
  if ( v5 < 0x4000u )
    attr->mvol.right = v5;
  else
    attr->mvol.right = v5 + 0x8000;
  attr->mvolmode.right = v6;
  attr->mvolmode.left = v2;
  v11 = (SpuVolume *)&spu_RXX_[20 * spu_core_];
  attr->mvolx = v11[486];
  attr->cd.volume.left = v11[484].left;
  attr->cd.volume.right = v11[484].right;
  attr->cd.reverb = (spu_RXX_[512 * spu_core_ + 205] & 4) != 0;
  attr->cd.mix = (spu_RXX_[512 * spu_core_ + 205] & 1) != 0;
  v13 = &spu_RXX_[20 * spu_core_];
  v14 = spu_core_ << 10;
  attr->ext.volume.left = v13[970];
  attr->ext.volume.right = v13[971];
  attr->ext.reverb = (*(vu16 *)((char *)spu_RXX_ + v14 + 410) & 8) != 0;
  attr->ext.mix = (spu_RXX_[512 * spu_core_ + 205] & 2) != 0;
}

// s_n2p.o

//----- (00405400) --------------------------------------------------------
u16 __fastcall spu_note2pitch_(u16 cen_note_high, u16 cen_note_low, u16 note_high, u16 note_low)
{
  u16 max_lo; // $a3
  int calc_note; // $a0
  u16 max_lo_idx; // $a3
  int calc_note_div12; // $a1
  int calc_note_div12_min12; // $a2
  int calc_note_mod12; // $a0
  int calc_note_mod12_idx; // $v1

  max_lo = note_low + cen_note_low;
  calc_note = (__int16)(note_high + (max_lo >> 7) - cen_note_high);
  max_lo_idx = max_lo & 0x7F;
  calc_note_div12 = calc_note / 12;
  calc_note_div12_min12 = calc_note / 12 - 2;
  calc_note_mod12 = calc_note % 12;
  calc_note_mod12_idx = calc_note_mod12;
  if ( (calc_note_mod12 & 0x8000) != 0 )
  {
    calc_note_mod12_idx = calc_note_mod12 + 12;
    calc_note_div12_min12 = calc_note_div12 - 3;
  }
  if ( (calc_note_div12_min12 & 0x8000u) == 0 )
    return 0x3FFF;
  return (unsigned int)(((spu_NTable_[calc_note_mod12_idx] * (u16)spu_FTable_[max_lo_idx]) >> 16)
                      + (1 << (-(__int16)calc_note_div12_min12 - 1))) >> -(__int16)calc_note_div12_min12;
}

//----- (004054D0) --------------------------------------------------------
int __fastcall spu_pitch2note_(s16 note_high, s16 note_low, u16 pitch)
{
  __int16 v3; // $t0
  u16 v4; // $t1
  __int16 v5; // $t2
  int v6; // $a3
  int v8; // $a2
  int v9; // $a3
  int v11; // $a3

  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( pitch >= 0x4000u )
    pitch = 0x3FFF;
  for ( v6 = 0; v6 < 14; v6 += 1 )
  {
    if ( (((int)pitch >> v6) & 1) != 0 )
      v5 = v6;
  }
  v8 = pitch << (15 - v5);
  for ( v9 = 11; v9 >= 0; v9 -= 1 )
  {
    if ( (u16)v8 >= (unsigned int)(u16)spu_NTable_[v9] )
    {
      v4 = v9;
      break;
    }
  }
  if ( !spu_NTable_[v4] )
    __builtin_trap();
  for ( v11 = 127; v11 >= 0; v11 -= 1 )
  {
    if ( (u16)(((u16)v8 << 15) / (unsigned int)(u16)spu_NTable_[v4]) >= (unsigned int)(u16)spu_FTable_[v11] )
    {
      v3 = v11;
      break;
    }
  }
  return ((u16)(v4 + note_high + 12 * (v5 - 12) + ((u16)(note_low + v3 + 1) >> 7)) << 8) | ((note_low + v3 + 1) & 0x7E);
}
// 405560: variable 'v4' is possibly undefined
// 4055C4: variable 'v3' is possibly undefined

// sr_gaks.o

//----- (00405610) --------------------------------------------------------
int __fastcall SpuRGetAllKeysStatus(int min_, int max_, char *status)
{
  int voice; // $a3

  if ( min_ < 0 )
  {
    min_ = 0;
  }
  if ( min_ < 0 || min_ >= 24 )
    return -3;
  if ( max_ >= 24 )
    max_ = 23;
  if ( max_ < 0 )
    return -3;
  if ( max_ < min_ )
    return -3;
  for ( voice = min_; voice < (max_ + 1); voice += 1 )
  {
    const vu16 *v9; // $v1

    v9 = &spu_RXX_[512 * spu_core_ + 8 * voice];
    if ( (spu_keystat_[spu_core_] & (1 << voice)) != 0 )
    {
      if ( v9[5] )
        status[voice] = 1;
      else
        status[voice] = 3;
    }
    else if ( v9[5] )
    {
      status[voice] = 2;
    }
    else
    {
      status[voice] = 0;
    }
  }
  return 0;
}

//----- (004056F8) --------------------------------------------------------
void __fastcall SpuGetAllKeysStatus(char *status)
{
  SpuRGetAllKeysStatus(0, 23, status);
}

// st.o

//----- (00405720) --------------------------------------------------------
static void __fastcall SpuStSetMarkSTART_(int voice)
{
  _BYTE *v1; // $v0

  v1 = (_BYTE *)(spu_st_Info_.voice[voice].data_addr + 1);
  *v1 = 6;
  v1[16] = 2;
  v1[spu_st_buf_sizeSBhalf_ - 16] = 2;
  FlushDcache();
}

//----- (00405774) --------------------------------------------------------
static void __fastcall SpuStSetMarkEND_(int voice)
{
  _BYTE *v1; // $v0

  v1 = (_BYTE *)(spu_st_Info_.voice[voice].data_addr + 1);
  *v1 = 2;
  v1[16] = 2;
  v1[spu_st_buf_sizeSBhalf_ - 16] = 3;
  FlushDcache();
}

//----- (004057C8) --------------------------------------------------------
static void __fastcall SpuStSetMarkFINAL_(int voice)
{
  unsigned int v1; // $a0
  int *v2; // $a1
  _BYTE *v3; // $v1
  int v4; // $a0
  _BYTE *v5; // $a1
  _BYTE *v6; // $v1

  v1 = 16 * voice;
  v2 = &spu_st_save_final_block_[v1 / 4];
  v3 = (_BYTE *)(spu_st_Info_.voice[v1 / 0x10].data_addr + spu_st_Info_.voice[v1 / 0x10].last_size - 16);
  *(_BYTE *)v2 = *v3;
  *v3++ = 0;
  v2 = (int *)((char *)v2 + 1);
  *(_BYTE *)v2 = *v3;
  v5 = (_BYTE *)v2 + 1;
  *v3 = 7;
  v6 = v3 + 1;
  for ( v4 = 0; v4 < 14; v4 += 1 )
  {
    v5[v4] = v6[v4];
    v6[v4] = 0;
  }
  FlushDcache();
}

//----- (00405868) --------------------------------------------------------
static void __fastcall SpuStSetMarkFINALrecover_(int voice)
{
  unsigned int v1; // $a0
  int *v2; // $a2
  int v3; // $a1
  _BYTE *v4; // $v1

  v1 = 16 * voice;
  v2 = &spu_st_save_final_block_[v1 / 4];
  v4 = (_BYTE *)(spu_st_Info_.voice[v1 / 0x10].data_addr + spu_st_Info_.voice[v1 / 0x10].last_size - 16);
  for ( v3 = 0; v3 < 16; v3 += 1 )
  {
    v4[v3] = ((_BYTE *)v2)[v3];
  }
  FlushDcache();
}

//----- (004058D8) --------------------------------------------------------
static SpuStVoiceAttr *__fastcall SpuStSetPrepareEnv_(int voice)
{
  SpuStVoiceAttr *v2; // $s0

  v2 = &spu_st_Info_.voice[voice];
  spu_t_(2, 8 * (v2->buf_addr >> 4));
  SpuStSetMarkSTART_(voice);
  spu_t_(1);
  return v2;
}

//----- (00405938) --------------------------------------------------------
void __fastcall SpuStCBPrepare_()
{
  int v0; // $v1

  v0 = spu_st_start_prepare_voice_bit_ & ~(1 << spu_st_start_prepare_voice_current_);
  spu_st_start_prepare_voice_bit_ = v0;
  if ( v0 )
  {
    int v1; // $a0

    for ( v1 = spu_st_start_prepare_voice_current_ + 1; v1 < 24; v1 += 1 )
    {
      if ( (v0 & (1 << v1)) != 0 )
        break;
    }
    spu_st_start_prepare_voice_current_ = v1;
    if ( v1 < 24 )
    {
      spu_t_(3, SpuStSetPrepareEnv_(v1)->data_addr, spu_st_buf_sizeSBhalf_);
    }
  }
  else
  {
    SpuSetTransferCallback(spu_st_cb_transfer_saved_);
    if ( spu_st_Info_.low_priority )
      spu_FsetPCR_(1);
    spu_st_stat_int_ = 34;
    if ( spu_st_cb_prepare_finished_ )
    {
      spu_st_cb_prepare_finished_(spu_st_start_prepare_tmp_voice_bit_, 4);
      spu_st_start_prepare_tmp_voice_bit_ = 0;
    }
  }
  FlushDcache();
}

//----- (00405A44) --------------------------------------------------------
static int __fastcall SpuStStartPrepare_(int voice_bit)
{
  int v1; // $s1
  int v3; // $v1

  for ( v1 = 0; v1 < 24; v1 += 1 )
  {
    if ( (voice_bit & (1 << v1)) != 0 )
      break;
  }
  v3 = spu_st_stat_int_ & 0xF0;
  if ( v3 == 32 )
    return -3;
  if ( (spu_st_stat_int_ & 0xF0u) >= 0x21 )
  {
    if ( v3 == 48 )
    {
      spu_st_start_prepare_tmp_voice_bit_ = voice_bit;
      spu_st_start_prepare_voice_bit_ = voice_bit;
      spu_st_start_prepare_voice_current_ = v1;
      spu_st_start_prepare_lock_ = 0;
      return 1;
    }
  }
  else
  {
    if ( v3 == 16 )
    {
      unsigned int data_addr; // $a1

      spu_st_stat_int_ = 32;
      spu_st_start_prepare_tmp_voice_bit_ = voice_bit;
      spu_st_start_prepare_voice_bit_ = voice_bit;
      spu_st_buf_sizeSBhalf_ = spu_st_Info_.size >> 1;
      spu_st_cb_transfer_saved_ = SpuSetTransferCallback(SpuStCBPrepare_);
      if ( spu_st_Info_.low_priority )
        spu_FsetPCR_(0);
      spu_st_bufferP_ = 0;
      spu_st_start_prepare_voice_current_ = v1;
      data_addr = SpuStSetPrepareEnv_(v1)->data_addr;
      spu_st_stat_int_ = 33;
      spu_t_(3, data_addr, spu_st_buf_sizeSBhalf_);
      return 1;
    }
  }
  return -3;
}

//----- (00405BB0) --------------------------------------------------------
int IntFunc(void)
{
  Kprintf("*********------------\n");
  Kprintf("*********------------\n");
  Kprintf("*********------------\n");
  Kprintf("*********------------\n");
  Kprintf("*********------------\n");
  FlushDcache();
  return 1;
}

//----- (00405C08) --------------------------------------------------------
static SpuStVoiceAttr *__fastcall SpuStSetTransferEnv_(int voice)
{
  SpuStVoiceAttr *v2; // $s2
  int v3; // $s0

  v2 = &spu_st_Info_.voice[voice];
  v3 = (v2->buf_addr >> 4) << 4;
  if ( spu_st_bufferP_ )
  {
    v3 += spu_st_buf_sizeSBhalf_;
    SpuStSetMarkEND_(voice);
  }
  else
  {
    SpuStSetMarkSTART_(voice);
  }
  spu_t_(2, v3 >> 1);
  if ( v2->status == 2 )
  {
    int v4; // $v1

    spu_st_start_voice_bit_ &= ~(1 << voice);
    spu_st_stop_voice_bit_ |= 1 << voice;
    SpuStSetMarkFINAL_(voice);
    if ( spu_st_start_voice_bit_ )
    {
      for ( v4 = 0; v4 < 24; v4 += 1 )
      {
        if ( (spu_st_start_voice_bit_ & (1 << v4)) != 0 )
          break;
      }
      spu_st_start_voice_smallest_ = v4;
    }
    else
    {
      spu_st_start_voice_smallest_ = 24;
      for ( v4 = 0; v4 < 24; v4 += 1 )
      {
        if ( (spu_st_stop_voice_bit_ & (1 << v4)) != 0 )
          break;
      }
      spu_st_stop_voice_smallest_ = v4;
    }
  }
  spu_t_(1);
  return v2;
}

//----- (00405D70) --------------------------------------------------------
void SpuStCB_IRQfinal_(void)
{
  unsigned int v0; // $s0

  v0 = SpuSetCore(st_core_);
  SpuSetIRQ(0);
  SpuSetCore(v0);
  spu_st_stat_int_ = 67;
  SpuSetIRQCallback(spu_st_cb_IRQ_saved_);
  SpuSetTransferCallback(spu_st_cb_transfer_saved_);
  if ( spu_st_Info_.low_priority )
    spu_FsetPCR_(1);
  if ( spu_st_cb_stream_finished_ && spu_st_stop_voice_bit_ )
    spu_st_cb_stream_finished_(spu_st_stop_voice_bit_, 8);
  spu_st_stop_voice_bit_ = 0;
  spu_st_stop_saved_voice_bit_ = 0;
  spu_st_stat_int_ = 16;
}

//----- (00405E4C) --------------------------------------------------------
static void SpuStCB_IRQ_(void)
{
  int v0; // $s6
  unsigned int v1; // $s2
  int v2; // $s4
  int v3; // $v0

  FlushDcache();
  v0 = -1;
  v1 = SpuSetCore(st_core_);
  SpuSetIRQ(0);
  SpuSetCore(v1);
  v2 = 0;
  if ( (spu_st_stat_int_ & 0xF0) == 64 )
    v3 = 66;
  else
    v3 = 51;
  spu_st_stat_int_ = v3;
  if ( spu_st_stop_voice_bit_ )
  {
    int v4; // $s1

    for ( v4 = 0; v4 < 24; v4 += 1 )
    {
      if ( (spu_st_stop_voice_bit_ & (1 << v4)) != 0 )
      {
        int last_size; // $s3
        unsigned int v8; // $s0
        int v9; // $s2

        last_size = spu_st_Info_.voice[v4].last_size;
#ifdef LIB_1300
        v8 = ((spu_st_Info_.voice[v4].buf_addr >> 4) << 4) + last_size - 8;
#else
        // Added in OSDSND 110U
        v8 = ((spu_st_Info_.voice[v4].buf_addr >> 4) << 4) + last_size - 16;
#endif
        if ( !spu_st_bufferP_ )
          v8 += spu_st_buf_sizeSBhalf_;
        v9 = SpuSetCore(st_core_);
        spu_FsetRXX_(226 + (v4 * 6), (v8 >> 4) << 4, 1);
        spu_core_ = v9;
        if ( v2 < last_size )
        {
          v2 = last_size;
          v0 = v4;
        }
      }
    }
  }
  if ( !spu_st_start_voice_bit_ )
  {
    unsigned int v10; // $a0
    unsigned int v11; // $s2

#ifdef LIB_1300
    if ( v2 < 9 )
#else
    // Added in OSDSND 110U
    if ( v2 < 17 )
#endif
    {
      SpuStCB_IRQfinal_();
      return;
    }
    SpuSetIRQCallback(SpuStCB_IRQfinal_);
#ifdef LIB_1300
    v10 = ((spu_st_Info_.voice[v0].buf_addr >> 4) << 4) + v2 - 8;
#else
    // Added in OSDSND 110U
    v10 = ((spu_st_Info_.voice[v0].buf_addr >> 4) << 4) + v2 - 16;
#endif
    spu_st_addrIRQ_ = v10;
    if ( !spu_st_bufferP_ )
      spu_st_addrIRQ_ = v10 + spu_st_buf_sizeSBhalf_;
    v11 = SpuSetCore(st_core_);
    SpuSetIRQAddr(spu_st_addrIRQ_);
    SpuSetCore(v11);
  }
  if ( spu_st_cb_stream_finished_ && spu_st_stop_saved_voice_bit_ )
    spu_st_cb_stream_finished_(spu_st_stop_saved_voice_bit_, 6);
  if ( spu_st_start_voice_bit_ )
  {
    spu_st_start_tmp_voice_bit_ = spu_st_start_voice_bit_;
    spu_st_stop_saved_voice_bit_ = spu_st_stop_voice_bit_;
    spu_st_start_tmp_voice_current_ = spu_st_start_voice_smallest_;
    if ( spu_st_bufferP_ )
    {
      if ( spu_st_start_add_voice_bit_ && spu_st_start_prepared_voice_bit_ && !spu_st_start_add_lock_ )
      {
        int v16; // $s0
        unsigned int v17; // $s2
        int v18; // $s1
        int v20; // $v1

        v16 = spu_st_start_add_voice_bit_ & spu_st_start_prepared_voice_bit_;
        v17 = SpuSetCore(st_core_);
        SpuSetKey(1, v16);
        SpuSetCore(v17);
        if ( (spu_env_ & 1) != 0 )
        {
          unsigned int v19; // $s2

          v19 = SpuSetCore(st_core_);
          SpuFlush(1u);
          SpuSetCore(v19);
        }
        spu_st_start_prepared_voice_bit_ = 0;
        spu_st_start_add_voice_bit_ = 0;
        v20 = spu_st_start_voice_bit_ | v16;
        spu_st_start_voice_bit_ = v20;
        spu_st_start_tmp_voice_bit_ = v20;
        for ( v18 = 0; v18 < 24; v18 += 1 )
        {
          if ( (v20 & (1 << v18)) != 0 )
            break;
        }
        spu_st_start_tmp_voice_current_ = v18;
        spu_st_start_voice_smallest_ = v18;
      }
    }
    else
    {
      int v13; // $v1

      v13 = spu_st_start_prepare_voice_bit_;
      if ( spu_st_start_prepare_voice_bit_ && !spu_st_start_prepare_lock_ )
      {
        int v14; // $s1

        spu_st_start_tmp_voice_bit_ = spu_st_start_voice_bit_ | spu_st_start_prepare_voice_bit_;
        spu_st_start_prepared_voice_bit_ = spu_st_start_prepare_voice_bit_;
        spu_st_start_prepare_tmp_voice_bit_ = spu_st_start_prepare_voice_bit_;
        spu_st_start_prepare_voice_bit_ = 0;
        for ( v14 = 0; v14 < 24; v14 += 1 )
        {
          if ( ((spu_st_start_voice_bit_ | v13) & (1 << v14)) != 0 )
            break;
        }
        spu_st_start_tmp_voice_current_ = v14;
      }
    }
    spu_st_stop_voice_bit_ = 0;
    spu_st_stat_int_ = 49;
    spu_t_(3, SpuStSetTransferEnv_(spu_st_start_tmp_voice_current_)->data_addr, spu_st_buf_sizeSBhalf_);
  }
  else
  {
    unsigned int v12; // $s2

    spu_st_stat_int_ = 65;
    v12 = SpuSetCore(st_core_);
    SpuSetIRQ(1);
    SpuSetCore(v12);
  }
  FlushDcache();
}

//----- (004062F8) --------------------------------------------------------
static void SpuStCB_Transfer_(void)
{
  SpuStVoiceAttr *v0; // $s0
  unsigned int v1; // $s1

  FlushDcache();
  spu_st_start_tmp_voice_bit_ &= ~(1 << spu_st_start_tmp_voice_current_);
  v0 = &spu_st_Info_.voice[spu_st_start_tmp_voice_current_];
  if ( v0->status == 2 )
  {
    SpuStSetMarkFINALrecover_(spu_st_start_tmp_voice_current_);
    v0->status = 6;
  }
  v1 = SpuSetCore(st_core_);
  spu_FsetRXX_(6 * spu_st_start_tmp_voice_current_ + 226, (v0->buf_addr >> 4) << 4, 1);
  SpuSetCore(v1);
  if ( spu_st_start_tmp_voice_bit_ )
  {
    int v6; // $a0

    for ( v6 = spu_st_start_tmp_voice_current_ + 1; v6 < 24; v6 += 1 )
    {
      if ( (spu_st_start_tmp_voice_bit_ & (1 << v6)) != 0 )
        break;
    }
    spu_st_start_tmp_voice_current_ = v6;
    spu_t_(3, SpuStSetTransferEnv_(v6)->data_addr, spu_st_buf_sizeSBhalf_);
  }
  else
  {
    int v2; // $v0
    unsigned int v3; // $a0
    unsigned int v4; // $s1
    unsigned int v5; // $s1

    if ( !spu_st_bufferP_ && spu_st_cb_prepare_finished_ && spu_st_start_prepare_tmp_voice_bit_ )
    {
      spu_st_cb_prepare_finished_(spu_st_start_prepare_tmp_voice_bit_, 6);
      spu_st_start_prepare_tmp_voice_bit_ = 0;
    }
    if ( spu_st_cb_transfer_finished_ && spu_st_start_voice_bit_ )
      spu_st_cb_transfer_finished_(spu_st_start_voice_bit_, 6);
    v2 = spu_st_stop_voice_smallest_;
    if ( spu_st_start_voice_smallest_ < 24 )
      v2 = spu_st_start_voice_smallest_;
    v3 = (spu_st_Info_.voice[v2].buf_addr >> 4) << 4;
    spu_st_addrIRQ_ = v3;
    spu_st_bufferP_ = spu_st_bufferP_ != 1;
    if ( spu_st_bufferP_ != 1 )
      spu_st_addrIRQ_ = v3 + spu_st_buf_sizeSBhalf_;
    v4 = SpuSetCore(st_core_);
    SpuSetIRQAddr(spu_st_addrIRQ_);
    SpuSetCore(v4);
    v5 = SpuSetCore(st_core_);
    SpuSetIRQ(1);
    SpuSetCore(v5);
    spu_st_stat_int_ = 64;
    if ( spu_st_start_voice_smallest_ < 24 )
      spu_st_stat_int_ = 50;
  }
  FlushDcache();
}

//----- (004065C4) --------------------------------------------------------
static int __fastcall SpuStStart_(unsigned int voice_bit)
{
  FlushDcache();
  if ( (spu_st_stat_int_ & 0xF0) == 32 )
  {
    if ( spu_st_stat_int_ == 34 )
    {
      int v3; // $s0
      unsigned int v5; // $s1
      const SpuStVoiceAttr *v6; // $s0
      unsigned int v7; // $s1

      spu_st_stat_int_ = 48;
      for ( v3 = 0; v3 < 24; v3 += 1 )
      {
        if ( (voice_bit & (1 << v3)) != 0 )
          break;
      }
      v5 = SpuSetCore(st_core_);
      SpuSetKey(1, voice_bit);
      SpuSetCore(v5);
      if ( (spu_env_ & 1) != 0 )
        SpuFlush(1u);
      spu_st_start_voice_bit_ = voice_bit;
      spu_st_start_tmp_voice_bit_ = voice_bit;
      spu_st_stop_saved_voice_bit_ = 0;
      spu_st_stop_voice_bit_ = 0;
      spu_st_cb_transfer_saved_ = SpuSetTransferCallback(SpuStCB_Transfer_);
      if ( spu_st_Info_.low_priority )
        spu_FsetPCR_(0);
      spu_st_cb_IRQ_saved_ = SpuSetIRQCallback(SpuStCB_IRQ_);
      spu_st_bufferP_ = 1;
      spu_st_start_tmp_voice_current_ = v3;
      spu_st_start_voice_smallest_ = v3;
      v6 = SpuStSetTransferEnv_(v3);
      v7 = SpuSetCore(st_core_);
      SpuSetIRQ(0);
      SpuSetCore(v7);
      spu_st_stat_int_ = 49;
      spu_t_(3, v6->data_addr, spu_st_buf_sizeSBhalf_);
      FlushDcache();
      return 1;
    }
  }
  else
  {
    if ( (spu_st_stat_int_ & 0xF0u) >= 0x21 )
    {
      if ( (spu_st_stat_int_ & 0xF0) == 48 )
      {
        spu_st_start_add_voice_bit_ = voice_bit;
        spu_st_start_add_lock_ = 0;
        return 1;
      }
    }
  }
  return -3;
}

//----- (004067C8) --------------------------------------------------------
int __fastcall SpuStTransfer(int flag, unsigned int voice_bit)
{
  unsigned int v4; // $a0

  if ( !spu_st_stat_int_ )
    return 0;
  v4 = voice_bit & 0xFFFFFF;
  if ( (voice_bit & 0xFFFFFF) == 0 )
  {
    return -2;
  }
  if ( flag == 4 )
  {
    return SpuStStartPrepare_(v4);
  }
  if ( flag >= 4 && flag < 7 )
  {
    return SpuStStart_(v4);
  }
  return -2;
}

//----- (00406848) --------------------------------------------------------
static void SpuStReset_(void)
{
  int v0; // $a0

  spu_st_cb_transfer_finished_ = 0;
  spu_st_cb_prepare_finished_ = 0;
  spu_st_cb_stream_finished_ = 0;
  spu_st_cb_transfer_saved_ = 0;
  spu_st_cb_IRQ_saved_ = 0;
  spu_st_start_voice_bit_ = 0;
  spu_st_start_tmp_voice_bit_ = 0;
  spu_st_start_add_voice_bit_ = 0;
  spu_st_start_prepare_voice_bit_ = 0;
  spu_st_start_prepare_tmp_voice_bit_ = 0;
  spu_st_start_prepared_voice_bit_ = 0;
  spu_st_stop_voice_bit_ = 0;
  spu_st_stop_saved_voice_bit_ = 0;
  spu_st_tmp_voice_bit_ = 0;
  spu_st_start_voice_smallest_ = 24;
  spu_st_start_tmp_voice_current_ = 24;
  spu_st_start_prepare_voice_current_ = 24;
  spu_st_start_prepare_voice_smallest_ = 24;
  spu_st_stop_voice_smallest_ = 24;
  for ( v0 = 0; v0 < 24; v0 += 1 )
  {
    spu_st_Info_.voice[v0].status = 6;
    spu_st_Info_.voice[v0].last_size = 0;
    spu_st_Info_.voice[v0].buf_addr = 0;
    spu_st_Info_.voice[v0].data_addr = 0;
  }
  spu_st_Info_.size = 0;
  spu_st_Info_.low_priority = 0;
  spu_st_buf_sizeSBhalf_ = 0;
  spu_st_bufferP_ = 0;
  spu_st_start_prepare_lock_ = 0;
  spu_st_start_add_lock_ = 0;
}

//----- (0040694C) --------------------------------------------------------
SpuStEnv *__fastcall SpuStInit(int mode)
{
  (void)mode;

  spu_st_stat_int_ = 16;
  SpuStReset_();
  return &spu_st_Info_;
}

//----- (00406978) --------------------------------------------------------
int SpuStQuit(void)
{
  if ( spu_st_stat_int_ != 16 )
    return -3;
  spu_st_stat_int_ = 0;
  SpuStReset_();
  return 1;
}

//----- (004069B8) --------------------------------------------------------
int SpuStGetStatus(void)
{
  switch (spu_st_stat_int_ & 0xF0)
  {
    case 0:
      return 0;
    case 16:
      return 3;
    case 32:
      return 4;
    case 48:
      return 7;
    case 64:
      return 8;
    default:
      return -3;
  }
}

//----- (00406A3C) --------------------------------------------------------
unsigned int SpuStGetVoiceStatus(void)
{
  return spu_st_start_voice_bit_;
}

//----- (00406A4C) --------------------------------------------------------
SpuStCallbackProc __fastcall SpuStSetPreparationFinishedCallback(SpuStCallbackProc func)
{
  SpuStCallbackProc result; // $v0

  result = spu_st_cb_prepare_finished_;
  if ( func != spu_st_cb_prepare_finished_ )
    spu_st_cb_prepare_finished_ = func;
  return result;
}

//----- (00406A70) --------------------------------------------------------
SpuStCallbackProc __fastcall SpuStSetTransferFinishedCallback(SpuStCallbackProc func)
{
  SpuStCallbackProc result; // $v0

  result = spu_st_cb_transfer_finished_;
  if ( func != spu_st_cb_transfer_finished_ )
    spu_st_cb_transfer_finished_ = func;
  return result;
}

//----- (00406A94) --------------------------------------------------------
SpuStCallbackProc __fastcall SpuStSetStreamFinishedCallback(SpuStCallbackProc func)
{
  SpuStCallbackProc result; // $v0

  result = spu_st_cb_stream_finished_;
  if ( func != spu_st_cb_stream_finished_ )
    spu_st_cb_stream_finished_ = func;
  return result;
}

//----- (00406AB8) --------------------------------------------------------
unsigned int __fastcall SpuStSetCore(unsigned int core)
{
  unsigned int result; // $v0

  result = st_core_;
  st_core_ = core & 1;
  return result;
}

// s_svv.o

//----- (00406AD0) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait_(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (00406B2C) --------------------------------------------------------
void __fastcall SpuSetVoiceVolume(int v_num, s16 voll, s16 volr)
{
  vu16 *regstmp; // $v0

  regstmp = &spu_RXX_[512 * spu_core_ + 8 * v_num];
  *regstmp = voll & 0x7FFF;
  regstmp[1] = volr & 0x7FFF;
  spu_wait_();
}

// s_svva.o

//----- (00406B80) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__00(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (00406BDC) --------------------------------------------------------
void __fastcall SpuSetVoiceVolumeAttr(int v_num, s16 voll, s16 volr, s16 voll_mode, s16 volr_mode)
{
  __int16 v5; // $a1
  __int16 v6; // $t0
  int v7; // $a0
  __int16 v8; // $a3
  __int16 v9; // $a2

  v5 = voll & 0x7FFF;
  v6 = 0;
  v7 = 8 * v_num;
  switch ( voll_mode )
  {
    case 1:
      v6 = 0x8000;
      break;
    case 2:
      v6 = 0x9000;
      break;
    case 3:
      v6 = 0xA000;
      break;
    case 4:
      v6 = 0xB000;
      break;
    case 5:
      v6 = 0xC000;
      break;
    case 6:
      v6 = 0xD000;
      break;
    case 7:
      v6 = 0xE000;
      break;
    default:
      break;
  }
  v8 = volr & 0x7FFF;
  v9 = 0;
  spu_RXX_[512 * spu_core_ + v7] = v5 | v6;
  switch ( volr_mode )
  {
    case 1:
      v9 = 0x8000;
      break;
    case 2:
      v9 = -28672;
      break;
    case 3:
      v9 = -24576;
      break;
    case 4:
      v9 = -20480;
      break;
    case 5:
      v9 = -16384;
      break;
    case 6:
      v9 = -12288;
      break;
    case 7:
      v9 = -8192;
      break;
    default:
      break;
  }
  spu_RXX_[512 * spu_core_ + 1 + v7] = v8 | v9;
  spu_wait__00();
}

// s_svp.o

//----- (00406D30) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__01(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (00406D8C) --------------------------------------------------------
void __fastcall SpuSetVoicePitch(int v_num, u16 pitch)
{
  spu_RXX_[512 * spu_core_ + 2 + 8 * v_num] = pitch;
  spu_wait__01();
}

// s_svn.o

//----- (00406DD0) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__02(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (00406E2C) --------------------------------------------------------
void __fastcall SpuSetVoiceNote(int v_num, u16 note)
{
  u8 v2; // $a3
  int v3; // $a2
  unsigned int v4; // $a1

  v2 = note;
  v3 = (u16)(note & 0xFF00) >> 8;
  v4 = (u16)spu_voice_centerNote_[spu_core_][v_num];
  spu_RXX_[512 * spu_core_ + 2 + 8 * v_num] = spu_note2pitch_(v4 >> 8, (u8)v4, v3, v2);
  spu_wait__02();
}

// s_svsn.o

//----- (00406EC0) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__03(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (00406F1C) --------------------------------------------------------
void __fastcall SpuSetVoiceSampleNote(int v_num, u16 sample_note)
{
  spu_voice_centerNote_[spu_core_][v_num] = sample_note;
  spu_wait__03();
}

// s_svsa.o

//----- (00406F70) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__04(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (00406FCC) --------------------------------------------------------
void __fastcall SpuSetVoiceStartAddr(int v_num, unsigned int start_addr)
{
  spu_FsetRXX_(6 * v_num + 224, (start_addr >> 4) << 4, 1);
  spu_wait__04();
}

// s_svlsa.o

//----- (00407010) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__05(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040706C) --------------------------------------------------------
void __fastcall SpuSetVoiceLoopStartAddr(int v_num, unsigned int lsa)
{
  spu_FsetRXX_(6 * v_num + 226, (lsa >> 4) << 4, 1);
  spu_wait__05();
}

// s_svar.o

//----- (004070B0) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__06(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040710C) --------------------------------------------------------
void __fastcall SpuSetVoiceAR(int v_num, u16 ar)
{
  vu16 *v2; // $v0

  v2 = &spu_RXX_[512 * spu_core_ + 8 * v_num];
  v2[3] = (u8)v2[3] | (u16)(ar << 8);
  spu_wait__06();
}

// s_svdr.o

//----- (00407160) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__07(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (004071BC) --------------------------------------------------------
void __fastcall SpuSetVoiceDR(int v_num, u16 dr)
{
  vu16 *v2; // $v0

  v2 = &spu_RXX_[512 * spu_core_ + 8 * v_num];
  v2[3] = (v2[3] & 0xFF0F) | (16 * dr);
  spu_wait__07();
}

// s_svsr.o

//----- (00407210) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__08(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040726C) --------------------------------------------------------
void __fastcall SpuSetVoiceSR(int v_num, u16 sr)
{
  vu16 *v2; // $v0

  v2 = &spu_RXX_[512 * spu_core_ + 8 * v_num];
  v2[4] = (v2[4] & 0x3F) | ((sr | 0x100) << 6);
  spu_wait__08();
}

// s_svrro

//----- (004072D0) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__09(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040732C) --------------------------------------------------------
void __fastcall SpuSetVoiceRR(int v_num, u16 rr)
{
  vu16 *v2; // $v1

  v2 = &spu_RXX_[512 * spu_core_ + 8 * v_num];
  v2[4] = (v2[4] & 0xFFC0) | rr;
  spu_wait__09();
}

// s_svsl.o

//----- (00407380) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__10(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (004073DC) --------------------------------------------------------
void __fastcall SpuSetVoiceSL(int v_num, u16 sl)
{
  vu16 *v2; // $v1

  v2 = &spu_RXX_[512 * spu_core_ + 8 * v_num];
  v2[3] = (v2[3] & 0xFFF0) | sl;
  spu_wait__10();
}

// s_svara.o

//----- (00407430) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__11(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040748C) --------------------------------------------------------
void __fastcall SpuSetVoiceARAttr(int v_num, u16 ar, int ar_mode)
{
  vu16 *v3; // $v0

  v3 = &spu_RXX_[512 * spu_core_ + 8 * v_num];
  v3[3] = (u8)v3[3] | (u16)((ar | ((ar_mode == 5) << 7)) << 8);
  spu_wait__11();
}

// s_svsra.o

//----- (004074F0) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__12(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040754C) --------------------------------------------------------
void __fastcall SpuSetVoiceSRAttr(int v_num, u16 sr, int sr_mode)
{
  __int16 v3; // $a3
  int v4; // $a0

  v4 = 8 * v_num;
  switch (sr_mode)
  {
    case 1:
      v3 = 0;
      break;
    case 5:
      v3 = 512;
      break;
    case 7:
      v3 = 768;
      break;
    default:
      v3 = 256;
      break;
  }
  spu_RXX_[512 * spu_core_ + 4 + v4] = (spu_RXX_[512 * spu_core_ + 4 + v4] & 0x3F) | ((sr | (u16)v3) << 6);
  spu_wait__12();
}

// s_svrra.o

//----- (00407600) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__13(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040765C) --------------------------------------------------------
void __fastcall SpuSetVoiceRRAttr(int v_num, u16 rr, int rr_mode)
{
  __int16 v3; // $a3
  int v4; // $a0

  v3 = 0;
  v4 = 8 * v_num;
  if ( rr_mode != 3 )
    v3 = 32 * (rr_mode == 7);
  spu_RXX_[512 * spu_core_ + 4 + v4] = (spu_RXX_[512 * spu_core_ + 4 + v4] & 0xFFC0) | rr | v3;
  spu_wait__13();
}

// s_svado

//----- (004076D0) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__14(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040772C) --------------------------------------------------------
void __fastcall SpuSetVoiceADSR(int v_num, u16 ar, u16 dr, u16 sr, u16 rr, u16 sl)
{
  vu16 *v6; // $v1

  v6 = &spu_RXX_[512 * spu_core_ + 8 * v_num];
  v6[3] = ((ar & 0x7F) << 8) | (16 * (dr & 0xF)) | (sl & 0xF);
  v6[4] = ((sr & 0x7F) << 6) | (rr & 0x1F) | 0x4000;
  spu_wait__14();
}

// s_svada.o

//----- (004077B0) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__15(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040780C) --------------------------------------------------------
void __fastcall SpuSetVoiceADSRAttr(
        int v_num,
        u16 ar,
        u16 dr,
        u16 sr,
        u16 rr,
        u16 sl,
        int ar_mode,
        int sr_mode,
        int rr_mode)
{
  __int16 v9; // $a1
  __int16 v10; // $a3
  int v11; // $a2
  __int16 v12; // $t0
  u16 v13; // $a0

  v9 = ((ar & 0x7F) << 8) | (16 * (dr & 0xF));
  v10 = ((sr & 0x7F) << 6) | (rr & 0x1F);
  v11 = 8 * v_num;
  spu_RXX_[512 * spu_core_ + 3 + 8 * v_num] = v9 | (sl & 0xF) | ((ar_mode == 5) << 15);
  switch (sr_mode)
  {
    case 1:
      v12 = 0;
      break;
    case 5:
      v12 = 0x8000;
      break;
    case 7:
      v12 = -16384;
      break;
    default:
      v12 = 0x4000;
      break;
  }
  v13 = v10 | v12;
  if ( rr_mode == 7 )
    v13 = v10 | v12 | 0x20;
  spu_RXX_[512 * spu_core_ + 4 + v11] = v13;
  spu_wait__15();
}

// s_sva.o

//----- (00407930) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__16(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040798C) --------------------------------------------------------
void __fastcall SpuSetVoiceAttr(SpuVoiceAttr *arg)
{
  int voice_num; // $s4
  unsigned int attr_mask; // $s0
  int regtmp; // $s6
  int vol_left_upper; // $a0
  __int16 vol_left_clamped; // $a1
  int vol_left; // $v1
  int vol_right_upper; // $a0
  __int16 vol_right_clamped; // $a1
  int vol_right; // $v1
  unsigned int attr_ar; // $a1
  __int16 adsr_ar_part; // $a2
  unsigned int adsr_dr_part; // $a1
  unsigned int adsr_sr_part; // $a1
  __int16 converted_s_mode; // $a2
  int attr_s_mode; // $v1
  unsigned int adsr_rr_part; // $a1
  __int16 attr_r_mode_converted; // $a2
  int attr_r_mode; // $v1
  unsigned int attr_sl; // $a1

  attr_mask = arg->mask;
  if ( attr_mask == 0 )
  {
    attr_mask = 0xFFFFFFFF;
  }
  for ( voice_num = 0; voice_num < 24; voice_num += 1 )
  {
    if ( (arg->voice & (1 << voice_num)) != 0 )
    {
      int converted_voice_num; // $s3

      converted_voice_num = 8 * voice_num;
      regtmp = 2 * (voice_num * 2 + voice_num);
      if ( (attr_mask & 0x10) != 0 )
        spu_RXX_[512 * spu_core_ + 2 + converted_voice_num] = arg->pitch;
      if ( (attr_mask & 0x40) != 0 )
        spu_voice_centerNote_[spu_core_][voice_num] = arg->sample_note;
      if ( (attr_mask & 0x20) != 0 )
        spu_RXX_[512 * spu_core_ + 2 + converted_voice_num] = spu_note2pitch_(
                                                                (spu_voice_centerNote_[spu_core_][voice_num] >> 8) & 0xFF,
                                                                (u8)spu_voice_centerNote_[spu_core_][voice_num],
                                                                (arg->note >> 8) & 0xFF,
                                                                (u8)arg->note);
      if ( (attr_mask & 1) != 0 )
      {
        vol_left_upper = 0;
        vol_left_clamped = arg->volume.left & 0x7FFF;
        if ( (attr_mask & 4) != 0 )
        {
          switch ( arg->volmode.left )
          {
            case 1:
              vol_left_upper = 0x8000;
              break;
            case 2:
              vol_left_upper = 36864;
              break;
            case 3:
              vol_left_upper = 40960;
              break;
            case 4:
              vol_left_upper = 45056;
              break;
            case 5:
              vol_left_upper = 49152;
              break;
            case 6:
              vol_left_upper = 53248;
              break;
            case 7:
              vol_left_upper = 57344;
              break;
            default:
              break;
          }
        }
        if ( vol_left_upper )
        {
          vol_left = arg->volume.left;
          if ( vol_left < 128 )
          {
            if ( vol_left < 0 )
              vol_left_clamped = 0;
          }
          else
          {
            vol_left_clamped = 127;
          }
        }
        spu_RXX_[512 * spu_core_ + converted_voice_num] = vol_left_clamped | vol_left_upper;
      }
      if ( (attr_mask & 2) != 0 )
      {
        vol_right_upper = 0;
        vol_right_clamped = arg->volume.right & 0x7FFF;
        if ( (attr_mask & 8) != 0 )
        {
          switch ( arg->volmode.right )
          {
            case 1:
              vol_right_upper = 0x8000;
              break;
            case 2:
              vol_right_upper = 36864;
              break;
            case 3:
              vol_right_upper = 40960;
              break;
            case 4:
              vol_right_upper = 45056;
              break;
            case 5:
              vol_right_upper = 49152;
              break;
            case 6:
              vol_right_upper = 53248;
              break;
            case 7:
              vol_right_upper = 57344;
              break;
            default:
              break;
          }
        }
        if ( vol_right_upper )
        {
          vol_right = arg->volume.right;
          if ( vol_right < 128 )
          {
            if ( vol_right < 0 )
              vol_right_clamped = 0;
          }
          else
          {
            vol_right_clamped = 127;
          }
        }
        spu_RXX_[512 * spu_core_ + 1 + converted_voice_num] = vol_right_clamped | vol_right_upper;
      }
      if ( (attr_mask & 0x80) != 0 )
        spu_FsetRXX_(regtmp + 224, (arg->addr >> 4) << 4, 1);
      if ( (attr_mask & 0x10000) != 0 )
        spu_FsetRXX_(regtmp + 226, (arg->loop_addr >> 4) << 4, 1);
      if ( (attr_mask & 0x20000) != 0 )
        spu_RXX_[512 * spu_core_ + 3 + converted_voice_num] = arg->adsr1;
      if ( (attr_mask & 0x40000) != 0 )
        spu_RXX_[512 * spu_core_ + 4 + converted_voice_num] = arg->adsr2;
      if ( (attr_mask & 0x800) != 0 )
      {
        attr_ar = arg->ar;
        if ( attr_ar >= 0x80 )
          attr_ar = 127;
        adsr_ar_part = 0;
        if ( ((attr_mask & 0x100) != 0) && arg->a_mode == 5 )
          adsr_ar_part = 128;
        spu_RXX_[512 * spu_core_ + 3 + converted_voice_num] = (u8)spu_RXX_[512 * spu_core_
                                                                                      + 3
                                                                                      + converted_voice_num] | (u16)(((u16)attr_ar | (u16)adsr_ar_part) << 8);
      }
      if ( (attr_mask & 0x1000) != 0 )
      {
        adsr_dr_part = arg->dr;
        if ( adsr_dr_part >= 0x10 )
          adsr_dr_part = 15;
        spu_RXX_[512 * spu_core_ + 3 + converted_voice_num] = (spu_RXX_[512 * spu_core_ + 3 + converted_voice_num] & 0xFF0F) | (16 * adsr_dr_part);
      }
      if ( (attr_mask & 0x2000) != 0 )
      {
        adsr_sr_part = arg->sr;
        if ( adsr_sr_part >= 0x80 )
          adsr_sr_part = 127;
        converted_s_mode = 256;
        if ( (attr_mask & 0x200) != 0 )
        {
          attr_s_mode = arg->s_mode;
          if ( attr_s_mode == 5 )
          {
            converted_s_mode = 512;
          }
          else if ( attr_s_mode == 7 )
            converted_s_mode = 768;
          else if ( attr_s_mode == 1 )
          {
            converted_s_mode = 0;
          }
        }
        spu_RXX_[512 * spu_core_ + 4 + converted_voice_num] = (spu_RXX_[512 * spu_core_ + 4 + converted_voice_num] & 0x3F) | (((u16)adsr_sr_part | (u16)converted_s_mode) << 6);
      }
      if ( (attr_mask & 0x4000) != 0 )
      {
        adsr_rr_part = arg->rr;
        if ( adsr_rr_part >= 0x20 )
          adsr_rr_part = 31;
        attr_r_mode_converted = 0;
        if ( (attr_mask & 0x400) != 0 )
        {
          attr_r_mode = arg->r_mode;
          if ( attr_r_mode == 7 )
            attr_r_mode_converted = 32;
        }
        spu_RXX_[512 * spu_core_ + 4 + converted_voice_num] = (spu_RXX_[512 * spu_core_ + 4 + converted_voice_num] & 0xFFC0) | adsr_rr_part | attr_r_mode_converted;
      }
      if ( (attr_mask & 0x8000) != 0 )
      {
        attr_sl = arg->sl;
        if ( attr_sl >= 0x10 )
          attr_sl = 15;
        spu_RXX_[512 * spu_core_ + 3 + converted_voice_num] = (spu_RXX_[512 * spu_core_ + 3 + converted_voice_num] & 0xFFF0) | attr_sl;
      }
    }
  }
  spu_wait__16();
}

// sr_sva.o

//----- (00408050) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__17(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (004080AC) --------------------------------------------------------
int __fastcall SpuRSetVoiceAttr(int min_, int max_, SpuVoiceAttr *arg)
{
  unsigned int mask; // $s0
  int v5; // $s6
  int v8; // $s6
  int i; // $s5
  int v12; // $s7
  int v13; // $a0
  __int16 v14; // $a1
  int left; // $v1
  int v16; // $a0
  __int16 v17; // $a1
  int right; // $v1
  unsigned int ar; // $a1
  __int16 v20; // $a2
  unsigned int dr; // $a1
  unsigned int sr; // $a1
  __int16 v23; // $a2
  int s_mode; // $v1
  unsigned int rr; // $a1
  __int16 v26; // $a2
  int r_mode; // $v1
  unsigned int sl; // $a1

  mask = arg->mask;
  if ( mask == 0 )
  {
    mask = 0xFFFFFFFF;
  }
  v5 = max_;
  if ( min_ < 0 )
    min_ = 0;
  if ( min_ >= 24 )
    return -3;
  if ( max_ >= 24 )
    v5 = 23;
  if ( v5 < 0 )
  {
    return -3;
  }
  v8 = v5 + 1;
  if ( v5 < min_ )
    return -3;
  for ( i = min_; i < v8; ++i )
  {
    if ( (arg->voice & (1 << i)) != 0 )
    {
      int v11; // $s3

      v11 = 8 * i;
      v12 = 2 * (i * 2 + i);
      if ( (mask & 0x10) != 0 )
        spu_RXX_[512 * spu_core_ + 2 + v11] = arg->pitch;
      if ( (mask & 0x40) != 0 )
        spu_voice_centerNote_[spu_core_][i] = arg->sample_note;
      if ( (mask & 0x20) != 0 )
        spu_RXX_[512 * spu_core_ + 2 + v11] = spu_note2pitch_(
                                                (spu_voice_centerNote_[spu_core_][i] >> 8) & 0xFF,
                                                (u8)spu_voice_centerNote_[spu_core_][i],
                                                (arg->note >> 8) & 0xFF,
                                                (u8)arg->note);
      if ( (mask & 1) != 0 )
      {
        v13 = 0;
        v14 = arg->volume.left & 0x7FFF;
        if ( (mask & 4) != 0 )
        {
          switch ( arg->volmode.left )
          {
            case 1:
              v13 = 0x8000;
              break;
            case 2:
              v13 = 36864;
              break;
            case 3:
              v13 = 40960;
              break;
            case 4:
              v13 = 45056;
              break;
            case 5:
              v13 = 49152;
              break;
            case 6:
              v13 = 53248;
              break;
            case 7:
              v13 = 57344;
              break;
            default:
              break;
          }
        }
        if ( v13 )
        {
          left = arg->volume.left;
          if ( left < 128 )
          {
            if ( left < 0 )
              v14 = 0;
          }
          else
          {
            v14 = 127;
          }
        }
        spu_RXX_[512 * spu_core_ + v11] = v14 | v13;
      }
      if ( (mask & 2) != 0 )
      {
        v16 = 0;
        v17 = arg->volume.right & 0x7FFF;
        if ( (mask & 8) != 0 )
        {
          switch ( arg->volmode.right )
          {
            case 1:
              v16 = 0x8000;
              break;
            case 2:
              v16 = 36864;
              break;
            case 3:
              v16 = 40960;
              break;
            case 4:
              v16 = 45056;
              break;
            case 5:
              v16 = 49152;
              break;
            case 6:
              v16 = 53248;
              break;
            case 7:
              v16 = 57344;
              break;
            default:
              break;
          }
        }
        if ( v16 )
        {
          right = arg->volume.right;
          if ( right < 128 )
          {
            if ( right < 0 )
              v17 = 0;
          }
          else
          {
            v17 = 127;
          }
        }
        spu_RXX_[512 * spu_core_ + 1 + v11] = v17 | v16;
      }
      if ( (mask & 0x80) != 0 )
        spu_FsetRXX_(v12 + 224, (arg->addr >> 4) << 4, 1);
      if ( (mask & 0x10000) != 0 )
        spu_FsetRXX_(v12 + 226, (arg->loop_addr >> 4) << 4, 1);
      if ( (mask & 0x20000) != 0 )
        spu_RXX_[512 * spu_core_ + 3 + v11] = arg->adsr1;
      if ( (mask & 0x40000) != 0 )
        spu_RXX_[512 * spu_core_ + 4 + v11] = arg->adsr2;
      if ( (mask & 0x800) != 0 )
      {
        ar = arg->ar;
        if ( ar >= 0x80 )
          ar = 127;
        v20 = 0;
        if ( ((mask & 0x100) != 0) && arg->a_mode == 5 )
          v20 = 128;
        spu_RXX_[512 * spu_core_ + 3 + v11] = (u8)spu_RXX_[512 * spu_core_ + 3 + v11] | (u16)(((u16)ar | (u16)v20) << 8);
      }
      if ( (mask & 0x1000) != 0 )
      {
        dr = arg->dr;
        if ( dr >= 0x10 )
          dr = 15;
        spu_RXX_[512 * spu_core_ + 3 + v11] = (spu_RXX_[512 * spu_core_ + 3 + v11] & 0xFF0F) | (16 * dr);
      }
      if ( (mask & 0x2000) != 0 )
      {
        sr = arg->sr;
        if ( sr >= 0x80 )
          sr = 127;
        v23 = 256;
        if ( (mask & 0x200) != 0 )
        {
          s_mode = arg->s_mode;
          switch (s_mode)
          {
            case 5:
              v23 = 512;
              break;
            case 7:
              v23 = 768;
              break;
            case 1:
              v23 = 0;
              break;
            default:
              break;
          }
        }
        spu_RXX_[512 * spu_core_ + 4 + v11] = (spu_RXX_[512 * spu_core_ + 4 + v11] & 0x3F) | (((u16)sr | (u16)v23) << 6);
      }
      if ( (mask & 0x4000) != 0 )
      {
        rr = arg->rr;
        if ( rr >= 0x20 )
          rr = 31;
        v26 = 0;
        if ( (mask & 0x400) != 0 )
        {
          r_mode = arg->r_mode;
          if ( r_mode == 7 )
            v26 = 32;
        }
        spu_RXX_[512 * spu_core_ + 4 + v11] = (spu_RXX_[512 * spu_core_ + 4 + v11] & 0xFFC0) | rr | v26;
      }
      if ( (mask & 0x8000) != 0 )
      {
        sl = arg->sl;
        if ( sl >= 0x10 )
          sl = 15;
        spu_RXX_[512 * spu_core_ + 3 + v11] = (spu_RXX_[512 * spu_core_ + 3 + v11] & 0xFFF0) | sl;
      }
    }
  }
  spu_wait__17();
  return 0;
}

// sn_sva.o

//----- (004087C0) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__18(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (0040881C) --------------------------------------------------------
void __fastcall SpuNSetVoiceAttr(int v_num, SpuVoiceAttr *arg)
{
  int v3; // $s3
  unsigned int mask; // $s0
  int v5; // $s4

  v3 = 8 * v_num;
  mask = arg->mask;
  if ( mask == 0 )
  {
    mask = 0xFFFFFFFF;
  }
  v5 = 6 * v_num;
  if ( (mask & 0x10) != 0 )
    spu_RXX_[512 * spu_core_ + 2 + v3] = arg->pitch;
  if ( (mask & 0x40) != 0 )
    spu_voice_centerNote_[spu_core_][v_num] = arg->sample_note;
  if ( (mask & 0x20) != 0 )
    spu_RXX_[512 * spu_core_ + 2 + v3] = spu_note2pitch_(
                                           (spu_voice_centerNote_[spu_core_][v_num] >> 8) & 0xFF,
                                           (u8)spu_voice_centerNote_[spu_core_][v_num],
                                           (arg->note >> 8) & 0xFF,
                                           (u8)arg->note);
  if ( (mask & 1) != 0 )
  {
    int v6; // $a0
    __int16 v7; // $a1

    v6 = 0;
    v7 = arg->volume.left & 0x7FFF;
    if ( (mask & 4) != 0 )
    {
      switch ( arg->volmode.left )
      {
        case 1:
          v6 = 0x8000;
          break;
        case 2:
          v6 = 36864;
          break;
        case 3:
          v6 = 40960;
          break;
        case 4:
          v6 = 45056;
          break;
        case 5:
          v6 = 49152;
          break;
        case 6:
          v6 = 53248;
          break;
        case 7:
          v6 = 57344;
          break;
        default:
          break;
      }
    }
    if ( v6 )
    {
      int left; // $v1

      left = arg->volume.left;
      if ( left < 128 )
      {
        if ( left < 0 )
          v7 = 0;
      }
      else
      {
        v7 = 127;
      }
    }
    spu_RXX_[512 * spu_core_ + v3] = v7 | v6;
  }
  if ( (mask & 2) != 0 )
  {
    int v9; // $a0
    __int16 v10; // $a1

    v9 = 0;
    v10 = arg->volume.right & 0x7FFF;
    if ( (mask & 8) != 0 )
    {
      switch ( arg->volmode.right )
      {
        case 1:
          v9 = 0x8000;
          break;
        case 2:
          v9 = 36864;
          break;
        case 3:
          v9 = 40960;
          break;
        case 4:
          v9 = 45056;
          break;
        case 5:
          v9 = 49152;
          break;
        case 6:
          v9 = 53248;
          break;
        case 7:
          v9 = 57344;
          break;
        default:
          break;
      }
    }
    if ( v9 )
    {
      int right; // $v1

      right = arg->volume.right;
      if ( right < 128 )
      {
        if ( right < 0 )
          v10 = 0;
      }
      else
      {
        v10 = 127;
      }
    }
    spu_RXX_[512 * spu_core_ + 1 + v3] = v10 | v9;
  }
  if ( (mask & 0x80) != 0 )
    spu_FsetRXX_(v5 + 224, (arg->addr >> 4) << 4, 1);
  if ( (mask & 0x10000) != 0 )
    spu_FsetRXX_(v5 + 226, (arg->loop_addr >> 4) << 4, 1);
  if ( (mask & 0x20000) != 0 )
    spu_RXX_[512 * spu_core_ + 3 + v3] = arg->adsr1;
  if ( (mask & 0x40000) != 0 )
    spu_RXX_[512 * spu_core_ + 4 + v3] = arg->adsr2;
  if ( (mask & 0x800) != 0 )
  {
    unsigned int ar; // $a1
    __int16 v13; // $a2

    ar = arg->ar;
    if ( ar >= 0x80 )
      ar = 127;
    v13 = 0;
    if ( ((mask & 0x100) != 0) && arg->a_mode == 5 )
      v13 = 128;
    spu_RXX_[512 * spu_core_ + 3 + v3] = (u8)spu_RXX_[512 * spu_core_ + 3 + v3] | (u16)(((u16)ar | (u16)v13) << 8);
  }
  if ( (mask & 0x1000) != 0 )
  {
    unsigned int dr; // $a1

    dr = arg->dr;
    if ( dr >= 0x10 )
      dr = 15;
    spu_RXX_[512 * spu_core_ + 3 + v3] = (spu_RXX_[512 * spu_core_ + 3 + v3] & 0xFF0F) | (16 * dr);
  }
  if ( (mask & 0x2000) != 0 )
  {
    unsigned int sr; // $a1
    __int16 v16; // $a2

    sr = arg->sr;
    if ( sr >= 0x80 )
      sr = 127;
    v16 = 256;
    if ( (mask & 0x200) != 0 )
    {
      switch (arg->s_mode)
      {
        case 1:
          v16 = 0;
          break;
        case 5:
          v16 = 512;
          break;
        case 7:
          v16 = 768;
          break;
        default:
          break;
      }
    }
    spu_RXX_[512 * spu_core_ + 4 + v3] = (spu_RXX_[512 * spu_core_ + 4 + v3] & 0x3F) | (((u16)sr | (u16)v16) << 6);
  }
  if ( (mask & 0x4000) != 0 )
  {
    unsigned int rr; // $a1
    __int16 v19; // $a2

    rr = arg->rr;
    if ( rr >= 0x20 )
      rr = 31;
    v19 = 0;
    if ( (mask & 0x400) != 0 )
    {
      int r_mode; // $v1

      r_mode = arg->r_mode;
      if ( r_mode == 7 )
        v19 = 32;
    }
    spu_RXX_[512 * spu_core_ + 4 + v3] = (spu_RXX_[512 * spu_core_ + 4 + v3] & 0xFFC0) | rr | v19;
  }
  if ( (mask & 0x8000) != 0 )
  {
    unsigned int sl; // $a1

    sl = arg->sl;
    if ( sl >= 0x10 )
      sl = 15;
    spu_RXX_[512 * spu_core_ + 3 + v3] = (spu_RXX_[512 * spu_core_ + 3 + v3] & 0xFFF0) | sl;
  }
  spu_wait__18();
}

// sl_sva.o

//----- (00408EB0) --------------------------------------------------------
static void __attribute__((optimize("no-unroll-loops"))) spu_wait__19(void)
{
  int i; // [sp+0h] [-8h]
  int v1; // [sp+4h] [-4h]

  v1 = 1;
  for ( i = 0; i < 2; ++i )
  {
    v1 *= 13;
    __asm__ __volatile__("" : "+g" (v1) : :);
  }
}

//----- (00408F0C) --------------------------------------------------------
void __fastcall SpuLSetVoiceAttr(int num, SpuLVoiceAttr *arg_list)
{
  int v3; // $s4
  unsigned int v9; // $a1
  int v10; // $a0
  __int16 v11; // $a1
  int v12; // $v1
  int v13; // $a0
  __int16 v14; // $a1
  int v15; // $v1
  unsigned int v16; // $a1
  __int16 v17; // $a2
  unsigned int v18; // $a1
  unsigned int v19; // $a1
  __int16 v20; // $a2
  unsigned int v22; // $a1
  __int16 v23; // $a2
  int r_mode; // $v1
  unsigned int v25; // $a1

  for ( v3 = 0; v3 < num; v3 += 1 )
  {
    int v5; // $s1
    int voiceNum; // $a1
    int v7; // $s3
    int v8; // $s5

    v5 = arg_list[v3].attr.mask;
    if ( v5 == 0 )
    {
      v5 = 0xFFFFFFFF;
    }
    voiceNum = arg_list[v3].voiceNum;
    v7 = 8 * voiceNum;
    v8 = 6 * voiceNum;
    if ( (v5 & 0x10) != 0 )
      spu_RXX_[512 * spu_core_ + 2 + v7] = arg_list[v3].attr.pitch;
    if ( (v5 & 0x40) != 0 )
      spu_voice_centerNote_[spu_core_][voiceNum] = arg_list[v3].attr.sample_note;
    if ( (v5 & 0x20) != 0 )
    {
      v9 = (u16)spu_voice_centerNote_[spu_core_][voiceNum];
      spu_RXX_[512 * spu_core_ + 2 + v7] = spu_note2pitch_(
                                             v9 >> 8,
                                             (u8)v9,
                                             ((arg_list[v3].attr.note >> 8)) & 0xFF,
                                             (u8)arg_list[v3].attr.note);
    }
    if ( (v5 & 1) != 0 )
    {
      v10 = 0;
      v11 = arg_list[v3].attr.volume.left & 0x7FFF;
      if ( (v5 & 4) != 0 )
      {
        switch ( arg_list[v3].attr.volmode.left )
        {
          case 1u:
            v10 = 0x8000;
            break;
          case 2u:
            v10 = 36864;
            break;
          case 3u:
            v10 = 40960;
            break;
          case 4u:
            v10 = 45056;
            break;
          case 5u:
            v10 = 49152;
            break;
          case 6u:
            v10 = 53248;
            break;
          case 7u:
            v10 = 57344;
            break;
          default:
            break;
        }
      }
      if ( v10 )
      {
        v12 = (__int16)arg_list[v3].attr.volume.left;
        if ( v12 < 128 )
        {
          if ( v12 < 0 )
            v11 = 0;
        }
        else
        {
          v11 = 127;
        }
      }
      spu_RXX_[512 * spu_core_ + v7] = v11 | v10;
    }
    if ( (v5 & 2) != 0 )
    {
      v13 = 0;
      v14 = arg_list[v3].attr.volume.right & 0x7FFF;
      if ( (v5 & 8) != 0 )
      {
        switch ( arg_list[v3].attr.volmode.right )
        {
          case 1u:
            v13 = 0x8000;
            break;
          case 2u:
            v13 = 36864;
            break;
          case 3u:
            v13 = 40960;
            break;
          case 4u:
            v13 = 45056;
            break;
          case 5u:
            v13 = 49152;
            break;
          case 6u:
            v13 = 53248;
            break;
          case 7u:
            v13 = 57344;
            break;
          default:
            break;
        }
      }
      if ( v13 )
      {
        v15 = (__int16)arg_list[v3].attr.volume.right;
        if ( v15 < 128 )
        {
          if ( v15 < 0 )
            v14 = 0;
        }
        else
        {
          v14 = 127;
        }
      }
      spu_RXX_[512 * spu_core_ + 1 + v7] = v14 | v13;
    }
    if ( (v5 & 0x80) != 0 )
      spu_FsetRXX_(v8 + 224, (arg_list[v3].attr.addr >> 4) << 4, 1);
    if ( (v5 & 0x10000) != 0 )
      spu_FsetRXX_(v8 + 226, (arg_list[v3].attr.loop_addr >> 4) << 4, 1);
    if ( (v5 & 0x20000) != 0 )
      spu_RXX_[512 * spu_core_ + 3 + v7] = arg_list[v3].attr.adsr1;
    if ( (v5 & 0x40000) != 0 )
      spu_RXX_[512 * spu_core_ + 4 + v7] = arg_list[v3].attr.adsr2;
    if ( (v5 & 0x800) != 0 )
    {
      v16 = arg_list[v3].attr.ar;
      if ( v16 >= 0x80 )
        v16 = 127;
      v17 = 0;
      if ( ((v5 & 0x100) != 0) && arg_list[v3].attr.a_mode == 5 )
        v17 = 128;
      spu_RXX_[512 * spu_core_ + 3 + v7] = (u8)spu_RXX_[512 * spu_core_ + 3 + v7] | (u16)(((u16)v16 | (u16)v17) << 8);
    }
    if ( (v5 & 0x1000) != 0 )
    {
      v18 = arg_list[v3].attr.dr;
      if ( v18 >= 0x10 )
        v18 = 15;
      spu_RXX_[512 * spu_core_ + 3 + v7] = (spu_RXX_[512 * spu_core_ + 3 + v7] & 0xFF0F) | (16 * v18);
    }
    if ( (v5 & 0x2000) != 0 )
    {
      v19 = arg_list[v3].attr.sr;
      if ( v19 >= 0x80 )
        v19 = 127;
      v20 = 256;
      if ( (v5 & 0x200) != 0 )
      {
        switch (arg_list[v3].attr.s_mode)
        {
          case 1:
            v20 = 0;
            break;
          case 5:
            v20 = 512;
            break;
          case 7:
            v20 = 768;
            break;
          default:
            break;
        }
      }
      spu_RXX_[512 * spu_core_ + 4 + v7] = (spu_RXX_[512 * spu_core_ + 4 + v7] & 0x3F) | (((u16)v19 | (u16)v20) << 6);
    }
    if ( (v5 & 0x4000) != 0 )
    {
      v22 = arg_list[v3].attr.rr;
      if ( v22 >= 0x20 )
        v22 = 31;
      v23 = 0;
      if ( (v5 & 0x400) != 0 )
      {
        r_mode = arg_list[v3].attr.r_mode;
        if ( r_mode == 7 )
          v23 = 32;
      }
      spu_RXX_[512 * spu_core_ + 4 + v7] = (spu_RXX_[512 * spu_core_ + 4 + v7] & 0xFFC0) | v22 | v23;
    }
    if ( (v5 & 0x8000) != 0 )
    {
      v25 = arg_list[v3].attr.sl;
      if ( v25 >= 0x10 )
        v25 = 15;
      spu_RXX_[512 * spu_core_ + 3 + v7] = (spu_RXX_[512 * spu_core_ + 3 + v7] & 0xFFF0) | v25;
    }
  }
  spu_wait__19();
}

// s_gvv.o

//----- (004095D0) --------------------------------------------------------
void __fastcall SpuGetVoiceVolume(int v_num, s16 *voll, s16 *volr)
{
  s16 *v3; // $v0
  u16 v4; // $t0
  unsigned int v5; // $a3

  v3 = (s16 *)&spu_RXX_[512 * spu_core_ + 8 * (v_num & 0x1F)];
  v4 = v3[1];
  v5 = (u16)*v3;
  if ( v5 < 0x4000 )
    *voll = *v3;
  else
    *voll = v5 + 0x8000;
  if ( v4 < 0x4000u )
    *volr = v4;
  else
    *volr = v4 + 0x8000;
}

// s_gvva.o

//----- (00409650) --------------------------------------------------------
void __fastcall SpuGetVoiceVolumeAttr(int v_num, s16 *voll, s16 *volr, s16 *voll_mode, s16 *volr_mode)
{
  const vu16 *v5; // $v0
  u16 v6; // $t1
  u16 v7; // $t2
  s16 v8; // $t0
  s16 v10; // $a0

  v5 = &spu_RXX_[512 * spu_core_ + 8 * (v_num & 0x1F)];
  v6 = *v5;
  v7 = v5[1];
  v8 = 0;
  if ( (v6 & 0x8000) != 0 )
  {
    switch (v6 & 0xF000)
    {
      case 0x8000:
        v8 = 1;
        break;
      case 36864:
        v8 = 2;
        break;
      case 40960:
        v8 = 3;
        break;
      case 45056:
        v8 = 4;
        break;
      case 49152:
        v8 = 5;
        break;
      case 53248:
        v8 = 6;
        break;
      case 57344:
      case 61440:
        v8 = 7;
        break;
      default:
        break;
    }
    v6 &= 0xFFFu;
  }
  v10 = 0;
  if ( (v7 & 0x8000) != 0 )
  {
    switch (v7 & 0xF000)
    {
      case 0x8000:
        v10 = 1;
        break;
      case 36864:
        v10 = 2;
        break;
      case 40960:
        v10 = 3;
        break;
      case 45056:
        v10 = 4;
        break;
      case 49152:
        v10 = 5;
        break;
      case 53248:
        v10 = 6;
        break;
      case 57344:
      case 61440:
        v10 = 7;
        break;
      default:
        break;
    }
    v7 &= 0xFFFu;
  }
  *voll_mode = v8;
  *volr_mode = v10;
  if ( v6 < 0x4000u )
    *voll = v6;
  else
    *voll = v6 + 0x8000;
  if ( v7 < 0x4000u )
    *volr = v7;
  else
    *volr = v7 + 0x8000;
}

// s_gvvx.o

//----- (00409870) --------------------------------------------------------
void __fastcall SpuGetVoiceVolumeX(int v_num, s16 *voll_x, s16 *volr_x)
{
  int v3; // $a0

  v3 = 8 * v_num;
  *voll_x = spu_RXX_[512 * spu_core_ + 6 + v3];
  *volr_x = spu_RXX_[512 * spu_core_ + 7 + v3];
}

// s_gvp.o

//----- (004098D0) --------------------------------------------------------
void __fastcall SpuGetVoicePitch(int v_num, u16 *pitch)
{
  *pitch = spu_RXX_[512 * spu_core_ + 2 + 8 * (v_num & 0x1F)];
}

// s_gvn.o

//----- (00409910) --------------------------------------------------------
void __fastcall SpuGetVoiceNote(int v_num, u16 *note)
{
  unsigned int v3; // $a1
  int v4; // $v0

  v3 = (u16)spu_voice_centerNote_[spu_core_][v_num];
  v4 = spu_pitch2note_(v3 >> 8, (u8)v3, spu_RXX_[512 * spu_core_ + 2 + 8 * (v_num & 0x1F)]);
  if ( v4 < 0 )
    *note = 0;
  else
    *note = v4;
}

// s_gvsn.o

//----- (004099A0) --------------------------------------------------------
void __fastcall SpuGetVoiceSampleNote(int v_num, u16 *sample_note)
{
  *sample_note = spu_voice_centerNote_[spu_core_][v_num];
}

// s_gvex.o

//----- (004099D0) --------------------------------------------------------
void __fastcall SpuGetVoiceEnvelope(int v_num, s16 *envx)
{
  *envx = spu_RXX_[512 * spu_core_ + 5 + 8 * (v_num & 0x1F)];
}

// s_gvsa.o

//----- (00409A10) --------------------------------------------------------
void __fastcall SpuGetVoiceStartAddr(int v_num, unsigned int *start_addr)
{
  *start_addr = spu_MGFgetRXX2_(6 * (v_num & 0x1F) + 224);
}

// s_gvlsa.o

//----- (00409A50) --------------------------------------------------------
void __fastcall SpuGetVoiceLoopStartAddr(int v_num, unsigned int *loop_start_addr)
{
  *loop_start_addr = spu_MGFgetRXX2_(6 * (v_num & 0x1F) + 226);
}

// s_gvar.o

//----- (00409A90) --------------------------------------------------------
void __fastcall SpuGetVoiceAR(int v_num, u16 *ar)
{
  *ar = ((spu_RXX_[512 * spu_core_ + 3 + 8 * (v_num & 0x1F)]) >> 8) & 0x3F;
}

// s_gvdr.o

//----- (00409AD0) --------------------------------------------------------
void __fastcall SpuGetVoiceDR(int v_num, u16 *dr)
{
  *dr = (spu_RXX_[512 * spu_core_ + 3 + 8 * (v_num & 0x1F)] & 0xF0u) >> 4;
}

// s_gvsr.o

//----- (00409B10) --------------------------------------------------------
void __fastcall SpuGetVoiceSR(int v_num, u16 *sr)
{
  *sr = (spu_RXX_[512 * spu_core_ + 4 + 8 * (v_num & 0x1F)] >> 6) & 0x7F;
}

// s_gvrr.o

//----- (00409B60) --------------------------------------------------------
void __fastcall SpuGetVoiceRR(int v_num, u16 *rr)
{
  *rr = spu_RXX_[512 * spu_core_ + 4 + 8 * (v_num & 0x1F)] & 0x1F;
}

// s_gvsl.o

//----- (00409BA0) --------------------------------------------------------
void __fastcall SpuGetVoiceSL(int v_num, u16 *sl)
{
  *sl = spu_RXX_[512 * spu_core_ + 3 + 8 * (v_num & 0x1F)] & 0xF;
}

// s_gvara.o

//----- (00409BE0) --------------------------------------------------------
void __fastcall SpuGetVoiceARAttr(int v_num, u16 *ar, int *ar_mode)
{
  u16 v3; // $v1

  v3 = spu_RXX_[512 * spu_core_ + 3 + 8 * (v_num & 0x1F)];
  *ar = (v3 >> 8) & 0x3F;
  *ar_mode = 1;
  if ( (v3 & 0x8000) != 0 )
    *ar_mode = 5;
}

// s_gvsra.o

//----- (00409C40) --------------------------------------------------------
void __fastcall SpuGetVoiceSRAttr(int v_num, u16 *sr, int *sr_mode)
{
  u16 v3; // $v1

  v3 = spu_RXX_[512 * spu_core_ + 4 + 8 * (v_num & 0x1F)];
  *sr = (v3 >> 6) & 0x7F;
  switch ( v3 & 0xE000 )
  {
    case 49152:
      *sr_mode = 7;
      break;
    case 32768:
      *sr_mode = 5;
      break;
    case 16384:
      *sr_mode = 3;
      break;
    default:
      *sr_mode = 1;
      break;
  }
}

// s_gvrra.o

//----- (00409CD0) --------------------------------------------------------
void __fastcall SpuGetVoiceRRAttr(int v_num, u16 *rr, int *rr_mode)
{
  u16 v3; // $v1

  v3 = spu_RXX_[512 * spu_core_ + 4 + 8 * (v_num & 0x1F)];
  *rr = v3 & 0x1F;
  *rr_mode = 3;
  if ( (v3 & 0x20) != 0 )
    *rr_mode = 7;
}

// s_gvad.o

//----- (00409D30) --------------------------------------------------------
void __fastcall SpuGetVoiceADSR(int v_num, u16 *ar, u16 *dr, u16 *sr, u16 *rr, u16 *sl)
{
  const vu16 *v6; // $v0
  u16 v7; // $t0
  unsigned int v8; // $a0

  v6 = &spu_RXX_[512 * spu_core_ + 8 * (v_num & 0x1F)];
  v7 = v6[3];
  v8 = v6[4];
  *ar = (v7 >> 8) & 0x3F;
  *dr = (u8)(v7 & 0xF0) >> 4;
  *sr = (v8 >> 6) & 0x7F;
  *rr = v8 & 0x1F;
  *sl = v7 & 0xF;
}

// s_gvada.o

//----- (00409DA0) --------------------------------------------------------
void __fastcall SpuGetVoiceADSRAttr(
        int v_num,
        u16 *ar,
        u16 *dr,
        u16 *sr,
        u16 *rr,
        u16 *sl,
        int *ar_mode,
        int *sr_mode,
        int *rr_mode)
{
  const vu16 *v9; // $v0
  u16 v10; // $t0
  unsigned int v11; // $a0

  v9 = &spu_RXX_[512 * spu_core_ + 8 * (v_num & 0x1F)];
  v10 = v9[3];
  v11 = v9[4];
  *ar = (v10 >> 8) & 0x3F;
  *ar_mode = 1;
  if ( (v10 & 0x8000) != 0 )
    *ar_mode = 5;
  *dr = (u8)(v10 & 0xF0) >> 4;
  *sr = (v11 >> 6) & 0x7F;
  switch ( v11 & 0xE000 )
  {
    case 49152:
      *sr_mode = 7;
      break;
    case 0x8000:
      *sr_mode = 5;
      break;
    case 0x4000:
      *sr_mode = 3;
      break;
    default:
      *sr_mode = 1;
      break;
  }
  *rr = v11 & 0x1F;
  *rr_mode = 3;
  if ( (v11 & 0x20) != 0 )
    *rr_mode = 7;
  *sl = v10 & 0xF;
}

// s_scmv.o

//----- (00409E90) --------------------------------------------------------
void __fastcall SpuSetCommonMasterVolume(s16 mvol_left, s16 mvol_right)
{
  vu16 *v2; // $v0

  v2 = &spu_RXX_[20 * spu_core_];
  v2[944] = mvol_left & 0x7FFF;
  v2[945] = mvol_right & 0x7FFF;
}

// s_scmva.o

//----- (00409ED0) --------------------------------------------------------
void __fastcall SpuSetCommonMasterVolumeAttr(s16 mvol_left, s16 mvol_right, s16 mvolmode_left, s16 mvolmode_right)
{
  s16 v4; // $v1
  s16 v5; // $t2
  int v6; // $t0
  int v7; // $t1

  v4 = mvol_left;
  v5 = mvol_right;
  v6 = 0;
  v7 = 0;
  switch ( mvolmode_left )
  {
    case 1:
      v6 = 0x8000;
      break;
    case 2:
      v6 = 36864;
      break;
    case 3:
      v6 = 40960;
      break;
    case 4:
      v6 = 45056;
      break;
    case 5:
      v6 = 49152;
      break;
    case 6:
      v6 = 53248;
      break;
    case 7:
      v6 = 57344;
      break;
    default:
      break;
  }
  if ( v6 )
  {
    v4 = 127;
    if ( mvol_left < 128 )
    {
      v4 = mvol_left;
      if ( mvol_left < 0 )
        v4 = 0;
    }
  }
  spu_RXX_[20 * spu_core_ + 944] = (v4 & 0x7FFF) | v6;
  switch ( mvolmode_right )
  {
    case 1:
      v7 = 0x8000;
      break;
    case 2:
      v7 = 36864;
      break;
    case 3:
      v7 = 40960;
      break;
    case 4:
      v7 = 45056;
      break;
    case 5:
      v7 = 49152;
      break;
    case 6:
      v7 = 53248;
      break;
    case 7:
      v7 = 57344;
      break;
    default:
      break;
  }
  if ( v7 )
  {
    v5 = 127;
    if ( mvol_right < 128 )
    {
      v5 = mvol_right;
      if ( mvol_right < 0 )
        v5 = 0;
    }
  }
  spu_RXX_[20 * spu_core_ + 945] = (v5 & 0x7FFF) | v7;
}

// s_sccv.o

//----- (0040A050) --------------------------------------------------------
void __fastcall SpuSetCommonCDVolume(s16 cd_left, s16 cd_right)
{
  vu16 *v2; // $v0

  v2 = &spu_RXX_[20 * spu_core_];
  v2[968] = cd_left;
  v2[969] = cd_right;
}

// s_sccr.o

//----- (0040A080) --------------------------------------------------------
void __fastcall SpuSetCommonCDReverb(int cd_reverb)
{
  vu16 *v1; // $v0
  u16 v2; // $v1

  v1 = &spu_RXX_[512 * spu_core_];
  if ( cd_reverb )
    v2 = v1[205] | 4;
  else
    v2 = v1[205] & 0xFFFB;
  v1[205] = v2;
}

// s_sccm.o

//----- (0040A0E0) --------------------------------------------------------
void __fastcall SpuSetCommonCDMix(int cd_mix)
{
  vu16 *v1; // $v0
  u16 v2; // $v1

  v1 = &spu_RXX_[512 * spu_core_];
  if ( cd_mix )
    v2 = v1[205] | 1;
  else
    v2 = v1[205] & 0xFFFE;
  v1[205] = v2;
}

// s_gcmv.o

//----- (0040A140) --------------------------------------------------------
void __fastcall SpuGetCommonMasterVolume(s16 *mvol_left, s16 *mvol_right)
{
  const vu16 *v2; // $v0
  u16 v3; // $v1
  u16 v4; // $a2

  v2 = &spu_RXX_[20 * spu_core_];
  v3 = v2[944];
  v4 = v2[945];
  if ( (v3 & 0x8000) != 0 )
    v3 &= 0xFFFu;
  if ( (v2[945] & 0x8000) != 0 )
    v4 &= 0xFFFu;
  if ( v3 < 0x4000u )
    *mvol_left = v3;
  else
    *mvol_left = v3 + 0x8000;
  if ( v4 < 0x4000u )
    *mvol_right = v4;
  else
    *mvol_right = v4 + 0x8000;
}

// s_gcmvx.o

//----- (0040A1D0) --------------------------------------------------------
void __fastcall SpuGetCommonMasterVolumeX(s16 *mvolx_left, s16 *mvolx_right)
{
  *mvolx_left = spu_RXX_[20 * spu_core_ + 972];
  *mvolx_right = spu_RXX_[20 * spu_core_ + 973];
}

// s_gcmva.o

//----- (0040A230) --------------------------------------------------------
void __fastcall SpuGetCommonMasterVolumeAttr(s16 *mvol_left, s16 *mvol_right, s16 *mvolmode_left, s16 *mvolmode_right)
{
  s16 v4; // $t1
  const vu16 *v5; // $v0
  u16 v6; // $t2
  u16 v7; // $t3
  s16 v8; // $t0

  v4 = 0;
  v5 = &spu_RXX_[20 * spu_core_];
  v6 = v5[944];
  v7 = v5[945];
  v8 = 0;
  if ( (v6 & 0x8000) != 0 )
  {
    switch (v6 & 0xF000)
    {
      case 0x8000:
        v4 = 1;
        break;
      case 36864:
        v4 = 2;
        break;
      case 40960:
        v4 = 3;
        break;
      case 45056:
        v4 = 4;
        break;
      case 49152:
        v4 = 5;
        break;
      case 53248:
        v4 = 6;
        break;
      case 57344:
      case 61440:
        v4 = 7;
        break;
      default:
        break;
    }
    v6 &= 0xFFFu;
  }
  v8 = 0;
  if ( (v7 & 0x8000) != 0 )
  {
    switch (v7 & 0xF000)
    {
      case 0x8000:
        v8 = 1;
        break;
      case 36864:
        v8 = 2;
        break;
      case 40960:
        v8 = 3;
        break;
      case 45056:
        v8 = 4;
        break;
      case 49152:
        v8 = 5;
        break;
      case 53248:
        v8 = 6;
        break;
      case 57344:
      case 61440:
        v8 = 7;
        break;
      default:
        break;
    }
    v7 &= 0xFFFu;
  }
  *mvolmode_left = v4;
  *mvolmode_right = v8;
  if ( v6 < 0x4000u )
    *mvol_left = v6;
  else
    *mvol_left = v6 + 0x8000;
  if ( v7 < 0x4000u )
    *mvol_right = v7;
  else
    *mvol_right = v7 + 0x8000;
}

// s_gccv.o

//----- (0040A450) --------------------------------------------------------
void __fastcall SpuGetCommonCDVolume(s16 *cd_left, s16 *cd_right)
{
  *cd_left = spu_RXX_[20 * spu_core_ + 968];
  *cd_right = spu_RXX_[20 * spu_core_ + 969];
}

// s_gccr.o

//----- (0040A4B0) --------------------------------------------------------
void __fastcall SpuGetCommonCDReverb(int *cd_reverb)
{
  *cd_reverb = 0;
  if ( (spu_RXX_[512 * spu_core_ + 205] & 4) != 0 )
    *cd_reverb = 1;
}

// s_gccm.o

//----- (0040A4F0) --------------------------------------------------------
void __fastcall SpuGetCommonCDMix(int *cd_mix)
{
  *cd_mix = 0;
  if ( (spu_RXX_[512 * spu_core_ + 205] & 1) != 0 )
    *cd_mix = 1;
}

// s_srmt.o

//----- (0040A55C) --------------------------------------------------------
int __fastcall SpuSetReverbModeType(int mode)
{
  unsigned int v1; // $s0
  int v2; // $s2
  vu16 *v4; // $a0
  int v5; // $s1
  vu16 *v6; // $v0
  libspu2_reverb_param_entry_t v7; // [sp+10h] [-48h] BYREF

  v1 = mode;
  v2 = 0;
  if ( (mode & 0x100) != 0 )
  {
    v1 = mode & 0xFFFFFEFF;
    v2 = 1;
  }
  if ( v1 >= 0xA )
  {
    return -1;
  }
  spu_rev_attr_.mode = v1;
  spu_rev_offsetaddr_ = SpuGetReverbEndAddr() - (8 * spu_rev_workareasize_[v1] - 2);
  memcpy(&v7, &spu_rev_param_[v1], 0x44u);
  v7.flags = 0;
  switch (v1)
  {
    case 7:
      spu_rev_attr_.feedback = 127;
      spu_rev_attr_.delay = 127;
      break;
    case 8:
      spu_rev_attr_.feedback = 0;
      spu_rev_attr_.delay = 127;
      break;
    default:
      spu_rev_attr_.feedback = 0;
      spu_rev_attr_.delay = 0;
      break;
  }
  v4 = &spu_RXX_[512 * spu_core_];
  v5 = (v4[205] >> 7) & 1;
  if ( v5 )
    v4[205] &= ~0x80u;
  v6 = &spu_RXX_[20 * spu_core_];
  v6[946] = 0;
  v6[947] = 0;
  spu_rev_attr_.depth.left = 0;
  spu_rev_attr_.depth.right = 0;
  spu_setReverbAttr_(&v7);
  if ( v2 )
    SpuClearReverbWorkArea(v1);
  spu_FsetRXX_(368, spu_rev_offsetaddr_, 1);
  if ( v5 )
  {
    spu_RXX_[512 * spu_core_ + 205] |= 0x80u;
  }
  return 0;
}

// s_srmd.o

//----- (0040A730) --------------------------------------------------------
void __fastcall SpuSetReverbModeDepth(s16 depth_left, s16 depth_right)
{
  vu16 *v2; // $v0

  v2 = &spu_RXX_[20 * spu_core_];
  v2[946] = depth_left;
  v2[947] = depth_right;
  spu_rev_attr_.depth.left = depth_left;
  spu_rev_attr_.depth.right = depth_right;
}

// s_srmdt.o

//----- (0040A79C) --------------------------------------------------------
void __fastcall SpuSetReverbModeDelayTime(int delay)
{
  libspu2_reverb_param_entry_t v3; // [sp+10h] [-48h] BYREF

  if ( spu_rev_attr_.mode < 9 && spu_rev_attr_.mode >= 7 )
  {
    int v2; // $a1

    memcpy(&v3, &spu_rev_param_[spu_rev_attr_.mode], 0x44u);
    v3.flags = 201399296;
    spu_rev_attr_.delay = delay;
    v3.mLSAME = (__int16)((_WORD)delay << 13) / 127 - v3.dAPF1;
    v2 = (delay << 12) / 127;
    v3.mRSAME = v2 - v3.dAPF2;
    v3.dLSAME = v3.dRSAME + v2;
    v3.mLCOMB1 = v3.mRCOMB1 + v2;
    v3.mRAPF1 = v3.mRAPF2 + v2;
    v3.mLAPF1 = v3.mLAPF2 + v2;
    spu_setReverbAttr_(&v3);
  }
}

// s_srmfb.o

//----- (0040A8DC) --------------------------------------------------------
void __fastcall SpuSetReverbModeFeedback(int feedback)
{
  libspu2_reverb_param_entry_t v2; // [sp+10h] [-48h] BYREF

  if ( spu_rev_attr_.mode < 9 && spu_rev_attr_.mode >= 7 )
  {
    memcpy(&v2, &spu_rev_param_[spu_rev_attr_.mode], 0x44u);
    v2.flags = 128;
    spu_rev_attr_.feedback = feedback;
    v2.vWALL = 33024 * feedback / 127;
    spu_setReverbAttr_(&v2);
  }
}

// s_grmt.o

//----- (0040A990) --------------------------------------------------------
void __fastcall SpuGetReverbModeType(int *mode)
{
  *mode = spu_rev_attr_.mode;
}

// s_grmd.o

//----- (0040A9A0) --------------------------------------------------------
void __fastcall SpuGetReverbModeDepth(s16 *depth_left, s16 *depth_right)
{
  *depth_left = spu_rev_attr_.depth.left;
  *depth_right = spu_rev_attr_.depth.right;
}

// s_grmdt.o

//----- (0040A9C0) --------------------------------------------------------
void __fastcall SpuGetReverbModeDelayTime(int *delay)
{
  *delay = spu_rev_attr_.delay;
}

// s_grmfb.o

//----- (0040A9D0) --------------------------------------------------------
void __fastcall SpuGetReverbModeFeedback(int *feedback)
{
  *feedback = spu_rev_attr_.feedback;
}

// s_gva.o

//----- (0040A9E0) --------------------------------------------------------
void __fastcall SpuGetVoiceAttr(SpuVoiceAttr *arg)
{
  int v2; // $s1
  int v3; // $v1
  unsigned int voice; // $a0
  int v6; // $s2
  const vu16 *v7; // $v0
  u16 v8; // $a0
  u16 v9; // $a3
  s16 v10; // $a2
  s16 v12; // $a1
  SpuVolume *v16; // $v0
  const vu16 *v21; // $v1

  v2 = -1;
  voice = arg->voice;
  for ( v3 = 0; v3 < 24; v3 += 1 )
  {
    if ( (voice & (1 << v3)) != 0 )
    {
      v2 = v3;
      break;
    }
  }
  v6 = 8 * v2;
  if ( v2 != -1 )
  {
    int v17; // $v0
    int v18; // $v1
    int v19; // $v0
    unsigned int v22; // $a1
    unsigned int v23; // $a0
    int v24; // $v0
    int v26; // $v0
    int v27; // $v0

    v7 = &spu_RXX_[512 * spu_core_ + v6];
    v8 = *v7;
    v9 = v7[1];
    v10 = 0;
    if ( (v8 & 0x8000) != 0 )
    {
      switch (v8 & 0xF000)
      {
        case 0x8000:
          v10 = 1;
          break;
        case 36864:
          v10 = 2;
          break;
        case 40960:
          v10 = 3;
          break;
        case 45056:
          v10 = 4;
          break;
        case 49152:
          v10 = 5;
          break;
        case 53248:
          v10 = 6;
          break;
        case 57344:
        case 61440:
          v10 = 7;
          break;
        default:
          break;
      }
      v8 &= 0xFFFu;
    }
    v12 = 0;
    if ( (v9 & 0x8000) != 0 )
    {
      switch (v9 & 0xF000)
      {
        case 0x8000:
          v12 = 1;
          break;
        case 36864:
          v12 = 2;
          break;
        case 40960:
          v12 = 3;
          break;
        case 45056:
          v12 = 4;
          break;
        case 49152:
          v12 = 5;
          break;
        case 53248:
          v12 = 6;
          break;
        case 57344:
        case 61440:
          v12 = 7;
          break;
        default:
          break;
      }
      v9 &= 0xFFFu;
    }
    if ( v8 < 0x4000u )
      arg->volume.left = v8;
    else
      arg->volume.left = v8 + 0x8000;
    if ( v9 < 0x4000u )
      arg->volume.right = v9;
    else
      arg->volume.right = v9 + 0x8000;
    arg->volmode.left = v10;
    arg->volmode.right = v12;
    v16 = (SpuVolume *)&spu_RXX_[512 * spu_core_ + v6];
    arg->volumex = v16[3];
    arg->pitch = v16[1].left;
    v17 = spu_pitch2note_(
            (spu_voice_centerNote_[spu_core_][v2] >> 8) & 0xFF,
            (u8)spu_voice_centerNote_[spu_core_][v2],
            arg->pitch);
    if ( v17 < 0 )
      arg->note = 0;
    else
      arg->note = v17;
    v18 = (spu_core_ << 9) + v6;
    arg->sample_note = spu_voice_centerNote_[spu_core_][v2];
    arg->envx = spu_RXX_[v18 + 5];
    arg->addr = spu_MGFgetRXX2_(224);
    v19 = spu_MGFgetRXX2_(226);
    arg->loop_addr = v19;
    v21 = &spu_RXX_[512 * spu_core_ + v6];
    v22 = v21[3];
    v23 = v21[4];
    v24 = 5;
    if ( (v22 & 0x8000) == 0 )
      v24 = 1;
    arg->a_mode = v24;
    switch ( v23 & 0xE000 )
    {
      case 49152:
        v26 = 7;
        break;
      case 0x8000:
        v26 = 5;
        break;
      case 0x4000:
        v26 = 3;
        break;
      default:
        v26 = 1;
        break;
    }
    arg->s_mode = v26;
    v27 = 7;
    if ( (v23 & 0x20) == 0 )
      v27 = 3;
    arg->r_mode = v27;
    arg->ar = (v22 >> 8) & 0x3F;
    arg->dr = (u8)(v22 & 0xF0) >> 4;
    arg->sr = (v23 >> 6) & 0x7F;
    arg->rr = v23 & 0x1F;
    arg->sl = v22 & 0xF;
    arg->adsr1 = v22;
    arg->adsr2 = v23;
  }
}

// sn_gva.o

//----- (0040AE10) --------------------------------------------------------
void __fastcall SpuNGetVoiceAttr(int v_num, SpuVoiceAttr *arg)
{
  s16 v3; // $a2
  int v4; // $s1
  const vu16 *v5; // $v0
  u16 v6; // $a0
  u16 v7; // $a3
  s16 v10; // $a1
  SpuVolume *v14; // $v0
  int v15; // $v0
  int v16; // $v1
  int v17; // $v0
  const vu16 *v19; // $v1
  unsigned int v20; // $a1
  unsigned int v21; // $a0
  int v22; // $v0
  int v24; // $v0
  int v25; // $v0

  v3 = 0;
  v4 = 8 * v_num;
  v5 = &spu_RXX_[512 * spu_core_ + 8 * v_num];
  v6 = *v5;
  v7 = v5[1];
  if ( (v6 & 0x8000) != 0 )
  {
    switch (v6 & 0xF000)
    {
      case 0x8000:
        v3 = 1;
        break;
      case 36864:
        v3 = 2;
        break;
      case 40960:
        v3 = 3;
        break;
      case 45056:
        v3 = 4;
        break;
      case 49152:
        v3 = 5;
        break;
      case 53248:
        v3 = 6;
        break;
      case 57344:
      case 61440:
        v3 = 7;
        break;
      default:
        break;
    }
    v6 &= 0xFFFu;
  }
  v10 = 0;
  if ( (v7 & 0x8000) != 0 )
  {
    switch (v7 & 0xF000)
    {
      case 0x8000:
        v10 = 1;
        break;
      case 36864:
        v10 = 2;
        break;
      case 40960:
        v10 = 3;
        break;
      case 45056:
        v10 = 4;
        break;
      case 49152:
        v10 = 5;
        break;
      case 53248:
        v10 = 6;
        break;
      case 57344:
      case 61440:
        v10 = 7;
        break;
      default:
        break;
    }
    v7 &= 0xFFFu;
  }
  if ( v6 < 0x4000u )
    arg->volume.left = v6;
  else
    arg->volume.left = v6 + 0x8000;
  if ( v7 < 0x4000u )
    arg->volume.right = v7;
  else
    arg->volume.right = v7 + 0x8000;
  arg->volmode.left = v3;
  arg->volmode.right = v10;
  v14 = (SpuVolume *)&spu_RXX_[512 * spu_core_ + v4];
  arg->volumex = v14[3];
  arg->pitch = v14[1].left;
  v15 = spu_pitch2note_(
          (spu_voice_centerNote_[spu_core_][v_num] >> 8) & 0xFF,
          (u8)spu_voice_centerNote_[spu_core_][v_num],
          arg->pitch);
  if ( v15 < 0 )
    arg->note = 0;
  else
    arg->note = v15;
  v16 = (spu_core_ << 9) + v4;
  arg->sample_note = spu_voice_centerNote_[spu_core_][v_num];
  arg->envx = spu_RXX_[v16 + 5];
  arg->addr = spu_MGFgetRXX2_(224);
  v17 = spu_MGFgetRXX2_(226);
  arg->loop_addr = v17;
  v19 = &spu_RXX_[512 * spu_core_ + v4];
  v20 = v19[3];
  v21 = v19[4];
  v22 = 5;
  if ( (v20 & 0x8000) == 0 )
    v22 = 1;
  arg->a_mode = v22;
  switch ( v21 & 0xE000 )
  {
    case 49152:
      v24 = 7;
      break;
    case 0x8000:
      v24 = 5;
      break;
    case 0x4000:
      v24 = 3;
      break;
    default:
      v24 = 1;
      break;
  }
  arg->s_mode = v24;
  v25 = 7;
  if ( (v21 & 0x20) == 0 )
    v25 = 3;
  arg->r_mode = v25;
  arg->ar = (v20 >> 8) & 0x3F;
  arg->dr = (u8)(v20 & 0xF0) >> 4;
  arg->sr = (v21 >> 6) & 0x7F;
  arg->rr = v21 & 0x1F;
  arg->sl = v20 & 0xF;
  arg->adsr1 = v20;
  arg->adsr2 = v21;
}

// s_sesa.o

//----- (0040B210) --------------------------------------------------------
void __fastcall SpuSetESA(int rev_addr)
{
  spu_FsetRXX_(0xBF801DA2, rev_addr >> 3, 0);
}

// s_sada.o

//----- (0040B240) --------------------------------------------------------
void __fastcall SpuSetAutoDMAAttr(s16 vol_l, s16 vol_r, s16 dry_on, s16 effect_on)
{
  *((vu16 *)0xBF90076C) = vol_l;
  *((vu16 *)0xBF90076E) = vol_r;
  if ( dry_on == 1 )
    *((vu16 *)0xBF900198) = *((vu16 *)0xBF900198) | 0xC0;
  else
    *((vu16 *)0xBF900198) = *((vu16 *)0xBF900198) & 0xFF3F;
  if ( effect_on == 1 )
    *((vu16 *)0xBF900198) |= 0x30u;
  else
    *((vu16 *)0xBF900198) &= 0xFFCFu;
}

//----- (0040B2D4) --------------------------------------------------------
void __fastcall SpuSetSerialInAttr(s16 dry_on, s16 effect_on)
{
  if ( dry_on == 1 )
    *((vu16 *)0xBF900598) = *((vu16 *)0xBF900598) | 0xC;
  else
    *((vu16 *)0xBF900598) = *((vu16 *)0xBF900598) & 0xFFF3;
  if ( effect_on == 1 )
    *((vu16 *)0xBF900598) |= 3u;
  else
    *((vu16 *)0xBF900598) &= 0xFFFCu;
}

// ccadsr.o

//----- (0040B350) --------------------------------------------------------
void __fastcall SsUtResolveADSR_(u16 adsr1, u16 adsr2, u16 *adsr_buf)
{
  adsr_buf[5] = adsr1 & 0x8000;
  adsr_buf[6] = adsr2 & 0x8000;
  adsr_buf[8] = adsr2 & 0x4000;
  adsr_buf[7] = adsr2 & 0x20;
  *adsr_buf = (adsr1 >> 8) & 0x7F;
  adsr_buf[1] = (u8)adsr1 >> 4;
  adsr_buf[2] = adsr1 & 0xF;
  adsr_buf[3] = (adsr2 >> 6) & 0x7F;
  adsr_buf[4] = adsr2 & 0x1F;
}

//----- (0040B3AC) --------------------------------------------------------
void __fastcall SsUtBuildADSR_(const u16 *adsr_buf, u16 *adsr1, u16 *adsr2)
{
  unsigned int v5; // $a1
  __int16 v6; // $t0
  unsigned int v7; // $a0
  u16 v8; // $v0

  v5 = adsr_buf[6] != 0 ? 0xFFFF8000 : 0;
  v6 = v5;
  v7 = adsr_buf[5] != 0 ? 0xFFFF8000 : 0;
  if ( adsr_buf[8] )
    v6 = v5 | 0x4000;
  if ( adsr_buf[7] )
    v6 |= 0x20u;
  v8 = v6 | ((adsr_buf[3] << 6) & 0x1FC0) | (adsr_buf[4] & 0x1F);
  *adsr1 = v7 | ((*adsr_buf << 8) & 0x7F00) | ((16 * adsr_buf[1]) & 0xF0) | (adsr_buf[2] & 0xF);
  *adsr2 = v8;
}

// cc_0.o

//----- (0040B450) --------------------------------------------------------
void __fastcall SsContBankChange_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0

  (void)control_value;

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_vab_id = *score_struct->m_seq_ptr;
  score_struct->m_seq_ptr += 1;
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// cc_6.o

//----- (0040B4D0) --------------------------------------------------------
void __fastcall SsContDataEntry_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0
  int m_channel_idx; // $s3
  ProgAtr prog_attr; // [sp+38h] [-38h] BYREF
  VagAtr old_vag_attr; // [sp+48h] [-28h] BYREF

  score_struct = &ss_score_[sep_no][seq_no];
  m_channel_idx = score_struct->m_channel_idx;
  SsUtGetProgAtr((char)score_struct->m_vab_id, (u8)score_struct->m_programs[m_channel_idx], &prog_attr);
  if ( score_struct->m_unk1C == 1 )
  {
    if ( !score_struct->m_unk15 )
    {
      score_struct->m_unk1D = control_value;
      score_struct->m_unk1C = 0;
      score_struct->m_unk15 = 1;
      score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
      return;
    }
  }
  if ( score_struct->m_unk1E == 2 )
  {
    int tone_idx_cur; // $s2

    for ( tone_idx_cur = 0; tone_idx_cur < prog_attr.tones; tone_idx_cur += 1 )
    {
      SsUtGetVagAtr((char)score_struct->m_vab_id, (u8)score_struct->m_programs[m_channel_idx], tone_idx_cur, &old_vag_attr);
      if ( (u8)score_struct->m_unk18 == 0 )
      {
        old_vag_attr.pbmax = control_value & 0x7F;
        old_vag_attr.pbmin = control_value & 0x7F;
      }
      SsUtSetVagAtr((char)score_struct->m_vab_id, (u8)score_struct->m_programs[m_channel_idx], tone_idx_cur, &old_vag_attr);
    }
    if ( score_struct->m_unk19 )
    {
      score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
      score_struct->m_unk1E = 0;
      return;
    }
  }
  if ( score_struct->m_unk1F != 2 )
  {
    score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
    return;
  }
  if ( score_struct->m_unk1B == 16 )
    SsFCALL.ccentry[(u8)score_struct->m_fn_idx](
      (char)score_struct->m_vab_id,
      (u8)score_struct->m_programs[m_channel_idx],
      0,
      old_vag_attr,
      score_struct->m_fn_idx,
      control_value);
  else
    SsFCALL.ccentry[(u8)score_struct->m_fn_idx](
      (char)score_struct->m_vab_id,
      (u8)score_struct->m_programs[m_channel_idx],
      score_struct->m_unk1B,
      old_vag_attr,
      score_struct->m_fn_idx,
      control_value);
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
  score_struct->m_unk1F = 0;
}

// cc_7.o

//----- (0040B870) --------------------------------------------------------
void __fastcall SsContMainVol_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s1
  int m_channel_idx; // $s2

  score_struct = &ss_score_[sep_no][seq_no];
  m_channel_idx = score_struct->m_channel_idx;
  SsVmSetVol_(
    sep_no | (seq_no << 8),
    (char)score_struct->m_vab_id,
    (u8)score_struct->m_programs[m_channel_idx],
    control_value,
    (u8)score_struct->m_panpot[m_channel_idx]);
  score_struct->m_vol[m_channel_idx] = control_value;
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// cc_10.o

//----- (0040B940) --------------------------------------------------------
void __fastcall SsContPanpot_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0
  int m_channel_idx; // $v0

  score_struct = &ss_score_[sep_no][seq_no];
  m_channel_idx = score_struct->m_channel_idx;
  SsVmSetVol_(
    sep_no | (seq_no << 8),
    (char)score_struct->m_vab_id,
    (u8)score_struct->m_programs[m_channel_idx],
    score_struct->m_vol[m_channel_idx],
    control_value);
  score_struct->m_panpot[m_channel_idx] = control_value;
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// cc_11.o

//----- (0040BA10) --------------------------------------------------------
void __fastcall SsContExpression_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0
  int m_channel_idx; // $s1

  score_struct = &ss_score_[sep_no][seq_no];
  m_channel_idx = score_struct->m_channel_idx;
  SsVmSetProgVol_((char)score_struct->m_vab_id, (u8)score_struct->m_programs[m_channel_idx], control_value);
  SsVmSetVol_(
    sep_no | (seq_no << 8),
    (char)score_struct->m_vab_id,
    (u8)score_struct->m_programs[m_channel_idx],
    score_struct->m_vol[m_channel_idx],
    (u8)score_struct->m_panpot[m_channel_idx]);
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// cc_64.o

//----- (0040BB00) --------------------------------------------------------
void __fastcall SsContDamper_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0

  score_struct = &ss_score_[sep_no][seq_no];
  if ( control_value >= 0x40u )
    SsVmDamperOn_();
  else
    SsVmDamperOff_();
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// cc_91.o

//----- (0040BBB0) --------------------------------------------------------
void __fastcall SsContExternal_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0

  score_struct = &ss_score_[sep_no][seq_no];
  SsUtSetReverbDepth(control_value, control_value);
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// cc_98.o

//----- (0040BC40) --------------------------------------------------------
void __fastcall SsContNrpn1_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0
  int m_unk1B; // $v1

  score_struct = &ss_score_[sep_no][seq_no];
  m_unk1B = score_struct->m_unk1B;
  if ( m_unk1B == 40 )
  {
    libsnd2_ss_mark_callback_proc pFunc; // $v0

    pFunc = SsMarkCallback_[sep_no].m_entries[seq_no];
    if ( pFunc )
      pFunc(sep_no, seq_no, control_value);
    m_unk1B = score_struct->m_unk1B;
  }
  if ( !(m_unk1B == 30 || m_unk1B == 20) && (m_unk1B != 40) )
  {
    score_struct->m_fn_idx = control_value;
    score_struct->m_unk1C = 0;
    score_struct->m_unk1F += 1;
  }
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// cc_99.o

//----- (0040BD40) --------------------------------------------------------
void __fastcall SsContNrpn2_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0

  score_struct = &ss_score_[sep_no][seq_no];
  if ( control_value == 20 )
  {
    score_struct->m_unk1B = control_value;
    score_struct->m_unk1C = 1;
    score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
    score_struct->m_unk08 = score_struct->m_seq_ptr;
    return;
  }
  if ( control_value != 30 )
  {
    score_struct->m_unk1B = control_value;
    score_struct->m_unk1F += 1;
    score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
    return;
  }
  score_struct->m_unk1B = control_value;
  if ( score_struct->m_unk1D == 0 )
  {
    score_struct->m_unk15 = 0;
    score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
    return;
  }
  if ( score_struct->m_unk1D >= 0x7Fu )
  {
    SsReadDeltaValue_(sep_no, seq_no);
    score_struct->m_delta_value = 0;
    score_struct->m_seq_ptr = score_struct->m_unk08;
  }
  else
  {
    score_struct->m_unk1D -= 1;
    score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
    if ( score_struct->m_unk1D )
      score_struct->m_seq_ptr = score_struct->m_unk08;
    else
      score_struct->m_unk15 = 0;
  }
}

// cc_100.o

//----- (0040BE80) --------------------------------------------------------
void __fastcall SsContRpn1_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_unk18 = control_value;
  score_struct->m_unk1E += 1;
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// cc_101.o

//----- (0040BEF0) --------------------------------------------------------
void __fastcall SsContRpn2_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_unk19 = control_value;
  score_struct->m_unk1E += 1;
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// cc_121.o

//----- (0040BF60) --------------------------------------------------------
void __fastcall SsContResetAll_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0

  (void)control_value;

  score_struct = &ss_score_[sep_no][seq_no];
  SsUtReverbOff();
  SsVmDamperOff_();
  score_struct->m_programs[score_struct->m_channel_idx] = score_struct->m_channel_idx;
  score_struct->m_unk18 = 0;
  score_struct->m_unk19 = 0;
  score_struct->m_vol[score_struct->m_channel_idx] = 127;
  score_struct->m_panpot[score_struct->m_channel_idx] = 64;
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// de_0.o

//----- (0040C020) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr0_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  vag_attr.prior = attribute_value;
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_1.o

//----- (0040C0B0) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr1_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  vag_attr.mode = attribute_value;
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
  switch (attribute_value)
  {
    case 0:
      SsUtReverbOff();
      break;
    case 4:
      SsUtReverbOn();
      break;
    default:
      break;
  }
}

// de_2.o

//----- (0040C170) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr2_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  vag_attr.min = attribute_value;
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_3.o

//----- (0040C200) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr3_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  vag_attr.max = attribute_value;
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_4.o

//----- (0040C290) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr4_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  SsUtResolveADSR_(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
  resolved_adsr[5] = 0;
  resolved_adsr[0] = attribute_value;
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_5.o

//----- (0040C350) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr5_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  SsUtResolveADSR_(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
  resolved_adsr[5] = 1;
  resolved_adsr[0] = attribute_value;
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_6.o

//----- (0040C410) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr6_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  SsUtResolveADSR_(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
  resolved_adsr[1] = attribute_value;
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_7.o

//----- (0040C4C0) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr7_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  SsUtResolveADSR_(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
  resolved_adsr[2] = attribute_value;
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_8.o

//----- (0040C570) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr8_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  SsUtResolveADSR_(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
  resolved_adsr[6] = 0;
  resolved_adsr[3] = attribute_value;
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_9.o

//----- (0040C630) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr9_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  SsUtResolveADSR_(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
  resolved_adsr[6] = 1;
  resolved_adsr[3] = attribute_value;
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_10.o

//----- (0040C6F0) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr10_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  SsUtResolveADSR_(vag_attr.adsr1, vag_attr.adsr2, resolved_adsr);
  resolved_adsr[7] = 0;
  resolved_adsr[4] = attribute_value;
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_11.o

//----- (0040C7B0) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr11_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  memset(&resolved_adsr, 0, sizeof(resolved_adsr));
  resolved_adsr[7] = 1;
  resolved_adsr[4] = attribute_value;
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_12.o

//----- (0040C860) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr12_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  memset(&resolved_adsr, 0, sizeof(resolved_adsr));
  if ( (u8)(attribute_value - 1) >= 0x3Fu )
  {
    if ( (u8)(attribute_value - 64) < 0x40u )
      resolved_adsr[8] = 1;
  }
  else
  {
    resolved_adsr[8] = 0;
  }
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_13.o

//----- (0040C940) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr13_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  vag_attr.vibT = attribute_value;
  memset(&resolved_adsr, 0, sizeof(resolved_adsr));
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_14.o

//----- (0040C9E0) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr14_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  u16 resolved_adsr[12]; // [sp+10h] [-18h] BYREF

  (void)fn_idx;

  SsUtGetVagAtr(vab_id, prog, tone, &vag_attr);
  vag_attr.porW = attribute_value;
  memset(&resolved_adsr, 0, sizeof(resolved_adsr));
  SsUtBuildADSR_(resolved_adsr, &vag_attr.adsr1, &vag_attr.adsr2);
  SsUtSetVagAtr(vab_id, prog, tone, &vag_attr);
}

// de_15.o

//----- (0040CA80) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr15_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  SsUtSetReverbType(attribute_value);
}

// de_16.o

//----- (0040CAB0) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr16_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  SsUtSetReverbDepth(attribute_value, attribute_value);
}

// de_17.o

//----- (0040CAE0) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr17_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  SsUtSetReverbFeedback(attribute_value);
}

// de_18.o

//----- (0040CB10) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr18_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  SsUtSetReverbDelay(attribute_value);
}

// de_19.o

//----- (0040CB40) --------------------------------------------------------
void __fastcall SsSetNrpnVabAttr19_(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  SsUtSetReverbDelay(attribute_value);
}

// cres.o

//----- (0040CB70) --------------------------------------------------------
void __fastcall SsSndCrescendo_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $s2

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_unkA0 += 1;
  if ( score_struct->m_unk9C >= score_struct->m_unkA0 )
  {
    int mulfield_tmp; // $t0
    int new_field_4a; // $lo
    int vol_inc_by; // $s0

    mulfield_tmp = score_struct->m_unk48 * score_struct->m_unkA0;
    new_field_4a = mulfield_tmp / score_struct->m_unk9C;
    if ( score_struct->m_unk9C == -1 && (unsigned int)mulfield_tmp == 0x80000000 )
      __builtin_trap();
    vol_inc_by = new_field_4a - score_struct->m_unk4A;
    if ( new_field_4a != score_struct->m_unk4A )
    {
      int voll_clamped; // $s1
      int volr_clamped; // $s0
      __int16 seq_left_vol; // [sp+10h] [-8h] BYREF
      __int16 seq_right_vol; // [sp+12h] [-6h] BYREF

      score_struct->m_unk4A = new_field_4a;
      SsVmGetSeqVol_(sep_no | (seq_no << 8), &seq_left_vol, &seq_right_vol);
      voll_clamped = (u16)seq_left_vol + vol_inc_by;
      if ( voll_clamped >= 128 )
        voll_clamped = 127;
      if ( voll_clamped < 0 )
        voll_clamped = 0;
      volr_clamped = (u16)seq_right_vol + vol_inc_by;
      if ( volr_clamped >= 128 )
        volr_clamped = 127;
      if ( volr_clamped < 0 )
        volr_clamped = 0;
      SsVmSetSeqVol_(sep_no | (seq_no << 8), voll_clamped, volr_clamped);
      if ( (voll_clamped == 127 && volr_clamped == 127) || (voll_clamped == 0 && volr_clamped == 0) )
      {
        score_struct->m_flags &= ~0x10u;
      }
    }
  }
  else
  {
    score_struct->m_flags &= ~0x10u;
  }
  SsVmGetSeqVol_(sep_no | (seq_no << 8), &score_struct->m_unk5C, &score_struct->m_unk5E);
}
// 40CC0C: conditional instruction was optimized away because $v1.4!=0

// midibend.o

//----- (0040CD80) --------------------------------------------------------
void __fastcall SsSetPitchBend_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $s0
  int m_vab_id; // $a1
  u8 midi_byte; // $a3

  score_struct = &ss_score_[sep_no][seq_no];
  m_vab_id = (char)score_struct->m_vab_id;
  midi_byte = *score_struct->m_seq_ptr;
  score_struct->m_seq_ptr += 1;
  SsVmPitchBend_(sep_no | (seq_no << 8), m_vab_id, (u8)score_struct->m_programs[score_struct->m_channel_idx], midi_byte);
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// midicc.o

//----- (0040CE40) --------------------------------------------------------
void __fastcall SsSetControlChange_(s16 sep_no, s16 seq_no, u8 control_value)
{
  libsnd2_sequence_struct_t *score_struct; // $s0
  u8 control_value_tmp; // $v1

  score_struct = &ss_score_[sep_no][seq_no];
  control_value_tmp = *score_struct->m_seq_ptr;
  score_struct->m_seq_ptr += 1;
  switch (control_value)
  {
    case 0:
    {
      score_struct->m_vab_id = control_value_tmp;
      break;
    }
    case 6:
    {
      SsFCALL.control[2](sep_no, seq_no, control_value_tmp);
      return;
    }
    case 7:
    {
      SsFCALL.control[3](sep_no, seq_no, control_value_tmp);
      return;
    }
    case 10:
    {
      SsFCALL.control[4](sep_no, seq_no, control_value_tmp);
      return;
    }
    case 11:
    {
      SsFCALL.control[5](sep_no, seq_no, control_value_tmp);
      return;
    }
    case 64:
    {
      SsFCALL.control[6](sep_no, seq_no, control_value_tmp);
      return;
    }
    case 91:
    {
      SsFCALL.control[11](sep_no, seq_no, control_value_tmp);
      return;
    }
    case 98:
    {
      SsFCALL.control[7](sep_no, seq_no, control_value_tmp);
      return;
    }
    case 99:
    {
      SsFCALL.control[8](sep_no, seq_no, control_value_tmp);
      return;
    }
    case 100:
    {
      SsFCALL.control[9](sep_no, seq_no, control_value_tmp);
      return;
    }
    case 101:
    {
      SsFCALL.control[10](sep_no, seq_no, control_value_tmp);
      return;
    }
    case 121:
    {
      SsFCALL.control[12](sep_no, seq_no, control_value_tmp);
      return;
    }
    default:
    {
      break;
    }
  }
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}
// 41C170: using guessed type int (__fastcall *)(_DWORD, _DWORD);

// midimeta.o

//----- (0040D070) --------------------------------------------------------
void __fastcall SsGetMetaEvent_(s16 sep_no, s16 seq_no, u8 meta_event)
{
  libsnd2_sequence_struct_t *score_struct; // $s0
  u8 v4; // $v1
  u8 v6; // $a3
  int v7; // $t0
  unsigned int v8; // $lo
  int v9; // $a2
  int v10; // $v1
  unsigned int v11; // $a3

  (void)meta_event;

  score_struct = &ss_score_[sep_no][seq_no];
  v4 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  v6 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  v7 = 60000000 / ((v4 << 16) | (v6 << 8) | *(score_struct->m_seq_ptr));
  score_struct->m_seq_ptr += 1;
  v8 = score_struct->m_resolution_of_quarter_note * v7;
  v9 = VBLANK_MINUS;
  v10 = 16 * VBLANK_MINUS;
  score_struct->m_unk94 = v7;
  v11 = 4 * (v10 - v9);
  if ( 10 * v8 < v11 )
  {
    unsigned int v13; // $lo

    if ( !v8 )
      __builtin_trap();
    v13 = 600 * v9 / v8;
    score_struct->m_unk52 = v13;
    score_struct->m_unk54 = v13;
  }
  else
  {
    unsigned int v15; // $lo
    unsigned int v16; // $hi

    v15 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_unk94 / v11;
    v16 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_unk94 % v11;
    score_struct->m_unk52 = -1;
    score_struct->m_unk54 = v15;
    if ( (unsigned int)(2 * (v10 - v9)) < v16 )
    {
      score_struct->m_unk54 = v15 + 1;
    }
  }
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}
// 40D0F4: conditional instruction was optimized away because $v1.4!=0
// 40D1B0: conditional instruction was optimized away because $a3.4!=0
// 40D1E0: conditional instruction was optimized away because $a3.4!=0

// midinote.o

//----- (0040D240) --------------------------------------------------------
void __fastcall SsNoteOn_(s16 sep_no, s16 seq_no, u8 note, u8 vollr)
{
  libsnd2_sequence_struct_t *score_struct; // $v1
  int m_channel_idx; // $a0

  score_struct = &ss_score_[sep_no][seq_no];
  m_channel_idx = score_struct->m_channel_idx;
  if ( vollr )
  {
    if ( ((score_struct->m_channel_mute >> m_channel_idx) & 1) == 0 )
      SsVmKeyOn_(
        sep_no | (u16)(seq_no << 8),
        (char)score_struct->m_vab_id,
        (u8)score_struct->m_programs[m_channel_idx],
        note,
        vollr,
        (u8)score_struct->m_panpot[m_channel_idx]);
  }
  else
  {
    SsVmKeyOff_(sep_no | (u16)(seq_no << 8), (char)score_struct->m_vab_id, (u8)score_struct->m_programs[m_channel_idx], note);
  }
}

// midiprog.o

//----- (0040D320) --------------------------------------------------------
void __fastcall SsSetProgramChange_(s16 sep_no, s16 seq_no, u8 prog)
{
  libsnd2_sequence_struct_t *score_struct; // $s0

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_programs[score_struct->m_channel_idx] = prog;
  score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
}

// midiread.o

//----- (0040D390) --------------------------------------------------------
void __fastcall SsSeqPlay_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $s1
  int m_unk54; // $v0
  int m_delta_value; // $v1
  int diff1; // $a2

  score_struct = &ss_score_[sep_no][seq_no];
  m_unk54 = score_struct->m_unk54;
  m_delta_value = score_struct->m_delta_value;
  diff1 = m_delta_value - m_unk54;
  if ( diff1 <= 0 )
  {
    int v10; // $v0
    int v11; // $s0
    int v15; // $v1

    v11 = score_struct->m_delta_value;
    if ( m_unk54 < m_delta_value )
      return;
    do
    {
      int v14; // $v0

      do
      {
        SsGetSeqData_(sep_no, seq_no);
        v14 = score_struct->m_delta_value;
      }
      while ( !v14 );
      v15 = score_struct->m_unk54;
      v11 += v14;
      v10 = v11 - v15;
    }
    while ( v11 < v15 );
    score_struct->m_delta_value = v10;
  }
  else
  {
    if ( score_struct->m_unk52 > 0 )
    {
      --score_struct->m_unk52;
      return;
    }
    if ( score_struct->m_unk52 )
    {
      score_struct->m_delta_value = diff1;
      return;
    }
    score_struct->m_unk52 = score_struct->m_unk54;
    score_struct->m_delta_value -= 1;
  }
}

//----- (0040D48C) --------------------------------------------------------
void __fastcall SsSeqGetEof_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $s0
  int m_l_count; // $v1
  u8 *m_unk04; // $v0

  score_struct = &ss_score_[sep_no][seq_no];
  m_l_count = score_struct->m_l_count;
  score_struct->m_unk21 += 1;
  if ( m_l_count )
  {
    if ( score_struct->m_unk21 >= m_l_count )
    {
      score_struct->m_flags &= ~1u;
      score_struct->m_flags &= ~8u;
      score_struct->m_flags &= ~2u;
      score_struct->m_flags |= 0x200u;
      score_struct->m_flags |= 4u;
      score_struct->m_play_mode = 0;
      if ( (score_struct->m_flags & 0x400) != 0 )
        score_struct->m_unk08 = score_struct->m_unk0C;
      else
        score_struct->m_unk08 = score_struct->m_unk04;
      if ( score_struct->m_next_sep != -1 )
      {
        score_struct->m_play_mode = 0;
        SsSndNextSep_(score_struct->m_next_sep, score_struct->m_next_seq);
        SsVmSeqKeyOff_(sep_no | (seq_no << 8));
      }
      SsVmSeqKeyOff_(sep_no | (seq_no << 8));
      score_struct->m_delta_value = score_struct->m_unk54;
    }
    else
    {
      score_struct->m_unk88 = 0;
      score_struct->m_unk1C = 0;
      score_struct->m_delta_value = 0;
      if ( (score_struct->m_flags & 0x400) != 0 )
        m_unk04 = score_struct->m_unk0C;
      else
        m_unk04 = score_struct->m_unk04;
      score_struct->m_seq_ptr = m_unk04;
      score_struct->m_unk08 = m_unk04;
    }
  }
  else
  {
    score_struct->m_unk88 = 0;
    score_struct->m_unk1C = 0;
    score_struct->m_delta_value = 0;
    if ( (score_struct->m_flags & 0x400) != 0 )
      score_struct->m_seq_ptr = score_struct->m_unk0C;
    else
      score_struct->m_seq_ptr = score_struct->m_unk04;
  }
}

//----- (0040D70C) --------------------------------------------------------
int __fastcall SsGetSeqData_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $s3
  u8 midi_byte; // $s2
  u8 midi_byte_1; // $s4
  u8 midi_byte_2; // $a2

  score_struct = &ss_score_[sep_no][seq_no];
  midi_byte = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  if ( (score_struct->m_flags & 0x401) == 0x401 )
  {
    if ( score_struct->m_seq_ptr == score_struct->m_unk10 + 1 )
    {
      SsSeqGetEof_(sep_no, seq_no);
      return -1;
    }
  }
  if ( (midi_byte & 0x80) != 0 )
  {
    score_struct->m_channel_idx = midi_byte & 0xF;
    switch (midi_byte & 0xF0)
    {
      case 0x90:
      {
        unsigned __int8 midi_byte_next_1; // $s2

        score_struct->m_running_status = 0x90;
        midi_byte_next_1 = *(score_struct->m_seq_ptr);
        score_struct->m_seq_ptr += 1;
        midi_byte_1 = *(score_struct->m_seq_ptr);
        score_struct->m_seq_ptr += 1;
        score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
        SsFCALL.noteon(sep_no, seq_no, midi_byte_next_1, midi_byte_1);
        break;
      }
      case 0xB0:
        score_struct->m_running_status = 0xB0;
        score_struct->m_seq_ptr += 1;
        SsFCALL.control[0](sep_no, seq_no, midi_byte);
        break;
      case 0xC0:
        score_struct->m_running_status = 0xC0;
        score_struct->m_seq_ptr += 1;
        SsFCALL.programchange(sep_no, seq_no, midi_byte);
        break;
      case 0xE0:
        score_struct->m_running_status = 0xE0;
        score_struct->m_seq_ptr += 1;
        SsFCALL.pitchbend(sep_no, seq_no);
        break;
      case 0xF0:
        score_struct->m_running_status = -1;
        midi_byte_2 = *(score_struct->m_seq_ptr);
        score_struct->m_seq_ptr += 1;
        if ( midi_byte_2 == 0x2F )
        {
          SsSeqGetEof_(sep_no, seq_no);
          return 1;
        }
        SsFCALL.metaevent(sep_no, seq_no, midi_byte);
        break;
      default:
        break;
    }
  }
  else
  {
    switch (score_struct->m_running_status)
    {
      case 0x90:
      {
        unsigned __int8 midi_byte_3; // $s4

        midi_byte_3 = *(score_struct->m_seq_ptr);
        score_struct->m_seq_ptr += 1;
        score_struct->m_delta_value = SsReadDeltaValue_(sep_no, seq_no);
        SsFCALL.noteon(sep_no, seq_no, midi_byte, midi_byte_3);
        break;
      }
      case 0xB0:
        SsFCALL.control[0](sep_no, seq_no, midi_byte);
        break;
      case 0xC0:
        SsFCALL.programchange(sep_no, seq_no, midi_byte);
        break;
      case 0xE0:
        SsFCALL.pitchbend(sep_no, seq_no);
        break;
      case 0xFF:
        if ( midi_byte == 0x2F )
        {
          SsSeqGetEof_(sep_no, seq_no);
          return 1;
        }
        SsFCALL.metaevent(sep_no, seq_no, midi_byte);
        break;
      default:
        break;
    }
  }
  return 0;
}
// 41C138: using guessed type int (__fastcall *)(_DWORD, _DWORD);

// miditime.o

//----- (0040DAC0) --------------------------------------------------------
s32 __fastcall SsReadDeltaValue_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $a1
  int delta_value; // $a0
  s32 result; // $v0
  int dv_mul4; // $v0

  score_struct = &ss_score_[sep_no][seq_no];
  delta_value = *score_struct->m_seq_ptr;
  score_struct->m_seq_ptr += 1;
  if ( !delta_value )
    return 0;
  if ( (delta_value & 0x80) != 0 )
  {
    char next_byte; // $v1

    delta_value &= 0x7Fu;
    do
    {
      next_byte = *score_struct->m_seq_ptr;
      score_struct->m_seq_ptr += 1;
      delta_value = (delta_value << 7) + (next_byte & 0x7F);
    }
    while ( (next_byte & 0x80) != 0 );
  }
  dv_mul4 = 4 * delta_value;
  result = 2 * (dv_mul4 + delta_value);
  score_struct->m_unk88 += result;
  return result;
}

// next.o

//----- (0040DB70) --------------------------------------------------------
void __fastcall SsSndNextSep_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $a3

  score_struct = &ss_score_[sep_no][seq_no];
  *(_WORD *)&score_struct->m_l_count = 1;
  score_struct->m_flags &= ~0x100u;
  score_struct->m_flags &= ~8u;
  score_struct->m_flags &= ~2u;
  score_struct->m_flags &= ~4u;
  score_struct->m_flags &= ~0x200u;
  score_struct->m_play_mode = 1;
  score_struct->m_seq_ptr = score_struct->m_unk04;
  score_struct->m_flags |= 1u;
}

// npause.o

//----- (0040DCA0) --------------------------------------------------------
void __fastcall SsSndNextPause_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_play_mode = 0;
  score_struct->m_flags &= ~0x100u;
}

// pause.o

//----- (0040DD00) --------------------------------------------------------
void __fastcall SsSndPause_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $s1

  score_struct = &ss_score_[sep_no][seq_no];
  SsVmSeqKeyOff_(sep_no | (seq_no << 8));
  score_struct->m_play_mode = 0;
  score_struct->m_flags &= ~2u;
}

// play.o

//----- (0040DDA0) --------------------------------------------------------
void __fastcall SsSndPlay_(s16 sep_no, s16 seq_no)
{
  SsSeqPlay_(sep_no, seq_no);
}

// replay.o

//----- (0040DDD0) --------------------------------------------------------
void __fastcall SsSndReplay_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_play_mode = 1;
  score_struct->m_flags &= ~8u;
}

// sepinit.o

//----- (0040DE40) --------------------------------------------------------
int __fastcall SsInitSoundSep_(s16 sep_no, int seq_no, u8 vab_id, u8 *addr)
{
  int v5; // $s1
  int v6; // $t0
  libsnd2_sequence_struct_t *score_struct; // $s0
  u8 v13; // $t2
  u8 v15; // $t0
  u8 v16; // $t1
  u8 v17; // $a3
  int tempo; // $lo
  char v20; // $v1
  char v21; // $a1
  int v22; // $t2
  u8 v23; // $t0
  u8 v24; // $t1
  u8 v25; // $a3
  s32 delta_value; // $v0
  int v27; // $s2
  unsigned int v28; // $lo
  int tmp1; // $a0
  unsigned int tmp2; // $a1
  int v33; // $s1

  v5 = 0;
  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_l_count = 1;
  score_struct->m_unk15 = 0;
  score_struct->m_running_status = 0;
  score_struct->m_channel_idx = 0;
  score_struct->m_unk18 = 0;
  score_struct->m_unk19 = 0;
  score_struct->m_fn_idx = 0;
  score_struct->m_unk1B = 0;
  score_struct->m_unk1C = 0;
  score_struct->m_unk1D = 0;
  score_struct->m_unk1E = 0;
  score_struct->m_unk1F = 0;
  score_struct->m_play_mode = 0;
  score_struct->m_unk21 = 0;
  score_struct->m_unk52 = 1;
  score_struct->m_resolution_of_quarter_note = 0;
  score_struct->m_vab_id = vab_id;
  score_struct->m_unk56 = 0;
  score_struct->m_unk84 = 0;
  score_struct->m_unk88 = 0;
  score_struct->m_tempo = 0;
  score_struct->m_delta_value = 0;
  score_struct->m_channel_mute = 0;
  score_struct->m_rhythm_n = 0;
  score_struct->m_rhythm_d = 0;
  for ( v6 = 0; v6 < 16; v6 += 1 )
  {
    score_struct->m_panpot[v6] = 64;
    score_struct->m_programs[v6] = v6;
    score_struct->m_vol[v6] = 127;
  }
  score_struct->m_seq_ptr = addr;
  if ( (seq_no << 16) != 0 )
  {
    score_struct->m_seq_ptr += 2;
    v5 = 2;
  }
  else
  {
    int v10; // $v1

    v10 = *addr;
    if ( v10 == 0x53 || v10 == 0x70 )
    {
      int v11; // $v0

      score_struct->m_seq_ptr += 5;
      v11 = *(score_struct->m_seq_ptr);
      score_struct->m_seq_ptr += 1;
      if ( v11 )
      {
        printf("This is not SEP Data.\n");
        return -1;
      }
      score_struct->m_seq_ptr += 2;
      v5 = 8;
    }
  }
  v13 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  v15 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  score_struct->m_resolution_of_quarter_note = v15 | (v13 << 8);
  v16 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  v17 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  tempo = 60000000 / ((v16 << 16) | (v17 << 8) | *(score_struct->m_seq_ptr));
  score_struct->m_seq_ptr += 1;
  score_struct->m_tempo = tempo;
  score_struct->m_unk94 = score_struct->m_tempo;
  v20 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  score_struct->m_rhythm_n = v20;
  v21 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  score_struct->m_rhythm_d = v21;
  v22 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  v23 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  v24 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  v25 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  v27 = (v22 << 24) + (v23 << 16) + (v24 << 8) + v25;
  delta_value = SsReadDeltaValue_(sep_no, seq_no);
  v28 = score_struct->m_resolution_of_quarter_note * score_struct->m_tempo;
  score_struct->m_unk84 = delta_value;
  score_struct->m_delta_value = delta_value;
  score_struct->m_unk10 = 0;
  score_struct->m_unk08 = score_struct->m_seq_ptr;
  score_struct->m_unk04 = score_struct->m_seq_ptr;
  score_struct->m_unk0C = score_struct->m_seq_ptr;
  tmp1 = VBLANK_MINUS;
  tmp2 = 60 * tmp1;
  v33 = v5 + 11;
  if ( 10 * v28 < (unsigned int)(60 * tmp1) )
  {
    unsigned int v34; // $lo

    if ( !v28 )
      __builtin_trap();
    v34 = 600 * tmp1 / v28;
    score_struct->m_unk52 = v34;
    score_struct->m_unk54 = v34;
  }
  else
  {
    unsigned int v36; // $lo
    unsigned int v37; // $hi

    v36 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_tempo / tmp2;
    v37 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_tempo % tmp2;
    score_struct->m_unk52 = -1;
    score_struct->m_unk54 = v36;
    if ( (unsigned int)(30 * tmp1) < v37 )
    {
      score_struct->m_unk54 = v36 + 1;
    }
  }
  score_struct->m_unk56 = score_struct->m_unk54;
  return v33 + v27;
}
// 40E014: conditional instruction was optimized away because $v0.4!=0
// 40E1B0: conditional instruction was optimized away because $a1.4!=0
// 40E1E0: conditional instruction was optimized away because $a1.4!=0

// seqinit.o

//----- (0040E240) --------------------------------------------------------
s16 __fastcall SsInitSoundSeq_(s16 seq_no, s16 vab_id, u8 *addr)
{
  int v4; // $v1
  libsnd2_sequence_struct_t *score_struct; // $s0
  int v8; // $v1
  u8 v9; // $v1
  u8 v11; // $a1
  u8 v12; // $v1
  u8 v13; // $v0
  u8 v14; // $a1
  int tempo; // $lo
  int delta_value; // $v0
  unsigned int v20; // $lo
  int tmp1; // $a0
  unsigned int tmp2; // $a1

  score_struct = &ss_score_[seq_no][0];
  score_struct->m_vab_id = vab_id;
  score_struct->m_resolution_of_quarter_note = 0;
  score_struct->m_unk18 = 0;
  score_struct->m_unk19 = 0;
  score_struct->m_unk1E = 0;
  score_struct->m_fn_idx = 0;
  score_struct->m_unk1B = 0;
  score_struct->m_unk1F = 0;
  score_struct->m_channel_idx = 0;
  score_struct->m_unk84 = 0;
  score_struct->m_unk88 = 0;
  score_struct->m_tempo = 0;
  score_struct->m_unk56 = 0;
  *(_WORD *)&score_struct->m_l_count = 1;
  score_struct->m_play_mode = 0;
  score_struct->m_delta_value = 0;
  score_struct->m_unk1C = 0;
  score_struct->m_unk1D = 0;
  score_struct->m_unk15 = 0;
  score_struct->m_running_status = 0;
  score_struct->m_channel_mute = 0;
  score_struct->m_rhythm_n = 0;
  score_struct->m_rhythm_d = 0;
  for ( v4 = 0; v4 < 16; v4 += 1 )
  {
    score_struct->m_programs[v4] = v4;
    score_struct->m_panpot[v4] = 64;
    score_struct->m_vol[v4] = 127;
  }
  score_struct->m_unk52 = 1;
  score_struct->m_seq_ptr = addr;
  v8 = *addr;
  score_struct->m_seq_ptr += 7;
  if ( v8 != 83 && v8 != 112 )
  {
    printf("This is an old SEQ Data Format.\n");
    return 0;
  }
  v9 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  if ( v9 != 1 )
  {
    printf("This is not SEQ Data.\n");
    return -1;
  }
  v11 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  v12 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  score_struct->m_resolution_of_quarter_note = v12 | (v11 << 8);
  v13 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  v14 = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  tempo = 60000000 / ((v13 << 16) | (v14 << 8) | *(score_struct->m_seq_ptr));
  score_struct->m_seq_ptr += 1;
  score_struct->m_tempo = tempo;
  score_struct->m_unk94 = score_struct->m_tempo;
  score_struct->m_rhythm_n = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  score_struct->m_rhythm_d = *(score_struct->m_seq_ptr);
  score_struct->m_seq_ptr += 1;
  delta_value = SsReadDeltaValue_(seq_no, 0);
  v20 = score_struct->m_resolution_of_quarter_note * score_struct->m_tempo;
  score_struct->m_unk84 = delta_value;
  score_struct->m_delta_value = delta_value;
  score_struct->m_unk10 = 0;
  score_struct->m_unk08 = score_struct->m_seq_ptr;
  score_struct->m_unk04 = score_struct->m_seq_ptr;
  score_struct->m_unk0C = score_struct->m_seq_ptr;
  tmp1 = VBLANK_MINUS;
  tmp2 = 60 * tmp1;
  if ( 10 * v20 < (unsigned int)(60 * tmp1) )
  {
    unsigned int v25; // $lo

    if ( !v20 )
      __builtin_trap();
    v25 = 600 * tmp1 / v20;
    score_struct->m_unk52 = v25;
    score_struct->m_unk54 = v25;
  }
  else
  {
    unsigned int v27; // $lo
    unsigned int v28; // $hi

    v27 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_tempo / tmp2;
    v28 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_tempo % tmp2;
    score_struct->m_unk52 = -1;
    score_struct->m_unk54 = v27;
    if ( (unsigned int)(30 * tmp1) < v28 )
    {
      score_struct->m_unk54 = v27 + 1;
    }
  }
  score_struct->m_unk56 = score_struct->m_unk54;
  return 0;
}
// 40E3D8: conditional instruction was optimized away because $v0.4!=0
// 40E514: conditional instruction was optimized away because $a1.4!=0
// 40E544: conditional instruction was optimized away because $a1.4!=0

// ssaccele.o

//----- (0040E590) --------------------------------------------------------
void __fastcall SsSndSetAccele_(s16 sep_no, s16 seq_no, int tempo, int v_time)
{
  libsnd2_sequence_struct_t *score_struct; // $t0
  unsigned int m_flags; // $v1

  score_struct = &ss_score_[sep_no][seq_no];
  m_flags = score_struct->m_flags;
  if ( (m_flags & 1) != 0 && (m_flags & 2) == 0 )
  {
    int m_unk94; // $a0

    m_unk94 = score_struct->m_unk94;
    if ( tempo != m_unk94 )
    {
      score_struct->m_unkA8 = v_time;
      score_struct->m_unkA4 = v_time;
      score_struct->m_unkAC = tempo;
      if ( ((tempo - m_unk94 >= 0) && (tempo - m_unk94 < v_time)) || ((tempo - m_unk94 < 0) && (m_unk94 - tempo < v_time)) )
      {
        int v9; // $v0
        int m_unkA8; // $v1
        int v11; // $a0
        int v13; // $v0

        v9 = score_struct->m_unk94;
        m_unkA8 = score_struct->m_unkA8;
        v11 = tempo - v9;
        v13 = v9 - tempo;
        if ( v11 < 0 )
        {
          if ( v13 == -1 && (unsigned int)m_unkA8 == 0x80000000 )
            __builtin_trap();
          score_struct->m_unk4E = m_unkA8 / v13;
        }
        else if ( v11 > 0 )
        {
          score_struct->m_unk4E = m_unkA8 / v11;
        }
        else
        {
          __builtin_trap();
        }
      }
      else
      {
        int v14; // $v1
        int v15; // $a0
        int v16; // $v0

        v14 = score_struct->m_unk94;
        v15 = score_struct->m_unkA8;
        v16 = tempo - v14;
        if ( tempo - v14 < 0 )
          v16 = v14 - tempo;
        if ( v15 == -1 && (unsigned int)v16 == 0x80000000 )
          __builtin_trap();
        score_struct->m_unk4E = ~(u16)(v16 / v15);
      }
      score_struct->m_flags |= 0x40u;
      score_struct->m_flags &= ~0x80u;
    }
  }
}
// 40E648: conditional instruction was optimized away because $a0.4!=0
// 40E678: conditional instruction was optimized away because $v0.4!=0
// 40E6C0: conditional instruction was optimized away because $a0.4!=0

//----- (0040E760) --------------------------------------------------------
void __fastcall SsSeqSetAccelerando(s16 seq_no, int tempo, int v_time)
{
  SsSndSetAccele_(seq_no, 0, tempo, v_time);
}

//----- (0040E794) --------------------------------------------------------
void __fastcall SsSepSetAccelerando(s16 seq_no, s16 sep_no, int tempo, int v_time)
{
  SsSndSetAccele_(seq_no, sep_no, tempo, v_time);
}

// sscall.o

//----- (0040E7C0) --------------------------------------------------------
void SsSeqCalledTbyT(void)
{
  if ( snd_ev_flag_ != 1 )
  {
    int sep_no; // $s2

    snd_ev_flag_ = 1;
    
    SsVmFlush_();
    for ( sep_no = 0; sep_no < snd_seq_s_max_; sep_no += 1 )
    {
      if ( (snd_openflag_ & (1 << sep_no)) != 0 )
      {
        int seq_no; // $s0

        for ( seq_no = 0; seq_no < snd_seq_t_max_; seq_no += 1 )
        {
          libsnd2_sequence_struct_t *score_struct;

          score_struct = &ss_score_[sep_no][seq_no];
          if ( (score_struct->m_flags & 1) != 0 )
          {
            SsSndPlay_(sep_no, seq_no);
            if ( (score_struct->m_flags & 0x10) != 0 )
            {
              SsSndCrescendo_(sep_no, seq_no);
#ifdef LIB_1300
              printf("--- _SsSndCrescendo ---\n");
#endif
            }
            if ( (score_struct->m_flags & 0x20) != 0 )
            {
              SsSndCrescendo_(sep_no, seq_no);
#ifdef LIB_1300
              printf("--- _SsSndCrescendo(DE) ---\n");
#endif
            }
            if ( (score_struct->m_flags & 0x40) != 0 )
            {
              SsSndTempo_(sep_no, seq_no);
#ifdef LIB_1300
              printf("--- _SsSndTempo(ACE) ---\n");
#endif
            }
            if ( (score_struct->m_flags & 0x80) != 0 )
            {
              SsSndTempo_(sep_no, seq_no);
#ifdef LIB_1300
              printf("--- _SsSndTempo(RIT) ---\n");
#endif
            }
          }
          if ( (score_struct->m_flags & 2) != 0 )
          {
            SsSndPause_(sep_no, seq_no);
#ifdef LIB_1300
            printf("--- _SsSndPause ---\n");
#endif
          }
          if ( (score_struct->m_flags & 8) != 0 )
          {
            SsSndReplay_(sep_no, seq_no);
#ifdef LIB_1300
            printf("--- _SsSndReplay ---\n");
#endif
          }
          if ( (score_struct->m_flags & 4) != 0 )
          {
            SsSndStop_(sep_no, seq_no);
            score_struct->m_flags = 0;
#ifdef LIB_1300
            printf("--- _SsSndStop ---\n");
#endif
          }
        }
      }
    }
    snd_ev_flag_ = 0;
  }
}

// ssclose.o

//----- (0040EA70) --------------------------------------------------------
static void __fastcall SsClose_(s16 seq_sep_no)
{
  int sep_no; // $a0
  int seq_no; // $a1

  SsVmSetSeqVol_(seq_sep_no, 0, 0);
  SsVmSeqKeyOff_(seq_sep_no);
  snd_openflag_ &= ~(1 << seq_sep_no);
  sep_no = seq_sep_no;
  for ( seq_no = 0; seq_no < snd_seq_t_max_; seq_no += 1 )
  {
    libsnd2_sequence_struct_t *score_struct;

    score_struct = &ss_score_[sep_no][seq_no];
    score_struct->m_flags = 0;
    *(_WORD *)&score_struct->m_next_sep = 255;
    score_struct->m_unk48 = 0;
    score_struct->m_unk4A = 0;
    score_struct->m_unk9C = 0;
    score_struct->m_unkA0 = 0;
    score_struct->m_unk4C = 0;
    score_struct->m_unkAC = 0;
    score_struct->m_unkA8 = 0;
    score_struct->m_unkA4 = 0;
    score_struct->m_unk4E = 0;
    score_struct->m_voll = 127;
    score_struct->m_volr = 127;
  }
}

//----- (0040EC50) --------------------------------------------------------
void __fastcall SsSeqClose(s16 seq_sep_no)
{
  SsClose_(seq_sep_no);
}

//----- (0040EC74) --------------------------------------------------------
void __fastcall SsSepClose(s16 seq_sep_no)
{
  SsClose_(seq_sep_no);
}

// sscmute.o

//----- (0040ECA0) --------------------------------------------------------
void __fastcall SsChannelMute(s16 sep_no, s16 seq_no, int channels)
{
  libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_channel_mute = channels;
}

//----- (0040ECDC) --------------------------------------------------------
int __fastcall SsGetChannelMute(s16 sep_no, s16 seq_no)
{
  const libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[sep_no][seq_no];
  return score_struct->m_channel_mute;
}

// sscres.o

//----- (0040ED20) --------------------------------------------------------
void __fastcall SsSndSetCres_(s16 sep_no, s16 seq_no, s16 vol, int v_time)
{
  libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[sep_no][seq_no];
  SsSndSetVolData_(sep_no, seq_no, vol, v_time);
  score_struct->m_flags |= 0x10u;
  score_struct->m_flags &= ~0x20u;
}

//----- (0040EDC4) --------------------------------------------------------
void __fastcall SsSeqSetCrescendo(s16 sep_no, s16 vol, int v_time)
{
  SsSndSetCres_(sep_no, 0, vol, v_time);
}

//----- (0040EDF8) --------------------------------------------------------
void __fastcall SsSepSetCrescendo(s16 sep_no, s16 seq_no, s16 vol, int v_time)
{
  SsSndSetCres_(sep_no, seq_no, vol, v_time);
}

// ssdecres.o

//----- (0040EE30) --------------------------------------------------------
void __fastcall SsSndSetDecres_(s16 sep_no, s16 seq_no, s16 vol, int v_time)
{
  libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[sep_no][seq_no];
  SsSndSetVolData_(sep_no, seq_no, -vol, v_time);
  score_struct->m_flags |= 0x20u;
  score_struct->m_flags &= ~0x10u;
}

//----- (0040EED8) --------------------------------------------------------
void __fastcall SsSeqSetDecrescendo(s16 sep_no, s16 vol, int v_time)
{
  SsSndSetDecres_(sep_no, 0, vol, v_time);
}

//----- (0040EF0C) --------------------------------------------------------
void __fastcall SsSepSetDecrescendo(s16 sep_no, s16 seq_no, s16 vol, int v_time)
{
  SsSndSetDecres_(sep_no, seq_no, vol, v_time);
}

// ssend.o

//----- (0040EF40) --------------------------------------------------------
void SsEnd(void)
{
#ifndef LIB_1300
  if ( !snd_seq_tick_env_.m_manual_tick )
  {
    snd_seq_tick_env_.m_unk11 = 0;
    if ( snd_seq_tick_env_.m_alarm_tick != 127 )
    {
      CpuDisableIntr();
      if ( snd_seq_tick_env_.m_vsync_tick )
      {
        ReleaseVblankHandler(0, SsTrapIntrProcIOP_);
        snd_seq_tick_env_.m_vsync_tick = 0;
      }
      else if ( snd_seq_tick_env_.m_alarm_tick )
      {
        CancelAlarm((unsigned int (__fastcall *)(void *))SsTrapIntrProcIOP_, &snd_seq_interval_);
      }
      else
      {
        ReleaseVblankHandler(0, SsTrapIntrProcIOP_);
        snd_seq_tick_env_.m_vsync_callback = 0;
      }
      CpuEnableIntr();
      snd_seq_tick_env_.m_alarm_tick = 127;
    }
  }
#endif
}

// ssgm.o

//----- (0040F010) --------------------------------------------------------
char SsGetMute(void)
{
  return SpuGetMute() != 0;
}

// ssgmv.o

//----- (0040F030) --------------------------------------------------------
void __fastcall SsGetMVol(SndVolume *m_vol)
{
  SpuCommonAttr spu_attr; // [sp+10h] [-28h] BYREF

  SpuGetCommonAttr(&spu_attr);
  m_vol->left = spu_attr.mvol.left / 129;
  m_vol->right = spu_attr.mvol.right / 129;
}

// ssgnc.o

//----- (0040F0B0) --------------------------------------------------------
s16 SsGetNck(void)
{
  return SpuGetNoiseClock();
}

// ssgrv.o

//----- (0040F0E0) --------------------------------------------------------
void __fastcall SsGetRVol(SndVolume *r_vol)
{
  SpuReverbAttr reverb_attr; // [sp+10h] [-18h] BYREF

  SpuGetReverbModeParam(&reverb_attr);
  r_vol->left = (__int16)(127 * reverb_attr.depth.left) / 0x7FFF;
  r_vol->right = 127 * reverb_attr.depth.right / 0x7FFF;
}

// ssgsattr.o

//----- (0040F170) --------------------------------------------------------
char __fastcall SsGetSerialAttr(char s_num, char attr)
{
  SpuCommonAttr spu_attr; // [sp+10h] [-28h] BYREF

  SpuGetCommonAttr(&spu_attr);
  switch (s_num)
  {
    case 0:
      switch(attr)
      {
        case 0:
          return spu_attr.cd.mix;
        case 1:
          return spu_attr.cd.reverb;
        default:
          break;
      }
      break;
    case 1:
      switch(attr)
      {
        case 0:
          return spu_attr.ext.mix;
        case 1:
          return spu_attr.ext.reverb;
        default:
          break;
      }
      break;
    default:
      break;
  }
  return -1;
}

// ssgsv.o

//----- (0040F220) --------------------------------------------------------
void __fastcall SsGetSerialVol(char s_num, SndVolume *s_vol)
{
  SpuCommonAttr spu_attr; // [sp+10h] [-28h] BYREF

  SpuGetCommonAttr(&spu_attr);
  switch (s_num)
  {
    case 0:
      s_vol->left = spu_attr.cd.volume.left / 258;
      s_vol->right = (u16)spu_attr.cd.volume.right / 258;
      break;
    case 1:
      s_vol->left = spu_attr.ext.volume.left / 258;
      s_vol->right = (u16)spu_attr.ext.volume.right / 258;
      break;
    default:
      break;
  }
}

// ssinit.o

//----- (0040F300) --------------------------------------------------------
void SsInit_(void)
{
  s16 *reg_set_ptr; // $a0
  int i; // $v1
  int j; // $a0

  reg_set_ptr = (s16 *)0xBF900760;
  for ( i = 0; i < 16; i += 1 )
  {
    reg_set_ptr[i] = volume_dat_2[i];
  }
  SsVmInit_(24);
  for ( j = 0; j < 32; j += 1 )
  {
    for ( i = 0; i < 16; i += 1 )
    {
      SsMarkCallback_[j].m_entries[i] = 0;
    }
  }
  VBLANK_MINUS = 60;
  snd_openflag_ = 0;
  snd_ev_flag_ = 0;
}

// ssinit_c.o

//----- (0040F3A0) --------------------------------------------------------
void SsInit(void)
{
  SpuInit();
  SsInit_();
}

//----- (0040F3C8) --------------------------------------------------------
void __fastcall SsPitchCorrect(s16 pitch_correct)
{
  gPitchCorrect = pitch_correct;
}

// ssinit_h.o

//----- (0040F3E0) --------------------------------------------------------
void SsInitHot(void)
{
  SpuInitHot();
  SsInit_();
}

// ssloop.o

//----- (0040F410) --------------------------------------------------------
void __fastcall SsSetLoop(s16 sep_no, s16 seq_no, s16 l_count)
{
  libsnd2_sequence_struct_t *score_struct; // $v1

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_l_count = l_count;
  score_struct->m_unk21 = 0;
}

//----- (0040F450) --------------------------------------------------------
s16 __fastcall SsIsEos(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[sep_no][seq_no];
  return (u8)score_struct->m_play_mode;
}

// ssmark.o

//----- (0040F490) --------------------------------------------------------
void __fastcall SsSetMarkCallback(s16 sep_no, s16 seq_no, SsMarkCallbackProc proc)
{
  SsMarkCallback_[sep_no].m_entries[seq_no] = proc;
}

// ssnext.o

//----- (0040F4C0) --------------------------------------------------------
void __fastcall SsSetNext(s16 sep_no1, s16 seq_no1, s16 sep_no2, s16 seq_no2)
{
  libsnd2_sequence_struct_t *score_struct_1;
  libsnd2_sequence_struct_t *score_struct_2;

  score_struct_1 = &ss_score_[sep_no1][seq_no1];
  score_struct_1->m_next_seq = seq_no2;
  score_struct_1->m_next_sep = sep_no2;
  score_struct_2 = &ss_score_[sep_no2][seq_no2];
  score_struct_2->m_flags |= 0x100u;
  score_struct_2->m_play_mode = 0;
}

//----- (0040F554) --------------------------------------------------------
void __fastcall SsSeqSetNext(s16 sep_no1, s16 sep_no2)
{
  libsnd2_sequence_struct_t *score_struct_1;
  libsnd2_sequence_struct_t *score_struct_2;

  score_struct_1 = &ss_score_[sep_no1][0];
  score_struct_1->m_next_sep = sep_no2;
  score_struct_1->m_next_seq = 0;
  score_struct_2 = &ss_score_[sep_no2][0];
  score_struct_2->m_flags |= 0x100u;
  score_struct_2->m_play_mode = 0;
}

// ssnoff.o

//----- (0040F5B0) --------------------------------------------------------
void SsSetNoiseOff(void)
{
  SsVmNoiseOff_();
}

// ssnon.o

//----- (0040F5D0) --------------------------------------------------------
void __fastcall SsSetNoiseOn(s16 voll, s16 volr)
{
  SsVmNoiseOn_(voll, volr);
}

// ssopenp.o

//----- (0040F600) --------------------------------------------------------
s16 __fastcall SsSepOpen(unsigned int *addr, s16 vab_id, s16 seq_cnt)
{
  s16 v4; // $s6
  unsigned int v6; // $a0
  __int16 v8; // $s0

  v4 = 0;
  if ( snd_openflag_ == (u32)-1 )
  {
    printf("Can't Open Sequence data any more\n\n");
    return -1;
  }
  SsFCALL.noteon = SsNoteOn_;
  SsFCALL.programchange = SsSetProgramChange_;
  SsFCALL.metaevent = SsGetMetaEvent_;
  SsFCALL.pitchbend = SsSetPitchBend_;
  SsFCALL.control[0] = SsSetControlChange_;
  SsFCALL.control[1] = SsContBankChange_;
  SsFCALL.control[3] = SsContMainVol_;
  SsFCALL.control[4] = SsContPanpot_;
  SsFCALL.control[5] = SsContExpression_;
  SsFCALL.control[6] = SsContDamper_;
  SsFCALL.control[7] = SsContNrpn1_;
  SsFCALL.control[8] = SsContNrpn2_;
  SsFCALL.control[9] = SsContRpn1_;
  SsFCALL.control[10] = SsContRpn2_;
  SsFCALL.control[11] = SsContExternal_;
  SsFCALL.control[12] = SsContResetAll_;
  SsFCALL.control[2] = SsContDataEntry_;
  SsFCALL.ccentry[0] = SsSetNrpnVabAttr0_;
  SsFCALL.ccentry[1] = SsSetNrpnVabAttr1_;
  SsFCALL.ccentry[2] = SsSetNrpnVabAttr2_;
  SsFCALL.ccentry[3] = SsSetNrpnVabAttr3_;
  SsFCALL.ccentry[4] = SsSetNrpnVabAttr4_;
  SsFCALL.ccentry[5] = SsSetNrpnVabAttr5_;
  SsFCALL.ccentry[6] = SsSetNrpnVabAttr6_;
  SsFCALL.ccentry[7] = SsSetNrpnVabAttr7_;
  SsFCALL.ccentry[8] = SsSetNrpnVabAttr8_;
  SsFCALL.ccentry[9] = SsSetNrpnVabAttr9_;
  SsFCALL.ccentry[10] = SsSetNrpnVabAttr10_;
  SsFCALL.ccentry[11] = SsSetNrpnVabAttr11_;
  SsFCALL.ccentry[12] = SsSetNrpnVabAttr12_;
  SsFCALL.ccentry[13] = SsSetNrpnVabAttr13_;
  SsFCALL.ccentry[14] = SsSetNrpnVabAttr14_;
  SsFCALL.ccentry[15] = SsSetNrpnVabAttr15_;
  SsFCALL.ccentry[16] = SsSetNrpnVabAttr16_;
  SsFCALL.ccentry[17] = SsSetNrpnVabAttr17_;
  SsFCALL.ccentry[18] = SsSetNrpnVabAttr18_;
  SsFCALL.ccentry[19] = SsSetNrpnVabAttr19_;
  for ( v6 = 0; v6 < 32; v6 += 1 )
  {
    if ( (snd_openflag_ & ((u32)1 << v6)) == 0 )
    {
      v4 = v6;
      break;
    }
  }
  snd_openflag_ |= 1 << v4;
  for ( v8 = 0; v8 < seq_cnt; v8 += 1 )
  {
    int inited; // $v0

    inited = SsInitSoundSep_(v4, v8, vab_id, (u8 *)addr);
    addr = (unsigned int *)((char *)addr + inited);
    if ( inited == -1 )
      return -1;
  }    
  return v4;
}
// 41C138: using guessed type int (__fastcall *)(_DWORD, _DWORD);
// 41C170: using guessed type int (__fastcall *)(_DWORD, _DWORD);

// ssopenq.o

//----- (0040F900) --------------------------------------------------------
s16 __fastcall SsSeqOpen(unsigned int *addr, s16 vab_id)
{
  s16 open_counter_2; // $t0
  unsigned int open_counter_1; // $v1
  int seq_init; // $a1

  open_counter_2 = 0;
  if ( snd_openflag_ == (u32)-1 )
  {
    printf("Can't Open Sequence data any more\n\n");
    return -1;
  }
  for ( open_counter_1 = 0; open_counter_1 < 32; open_counter_1 += 1 )
  {
    if ( (snd_openflag_ & ((u32)1 << open_counter_1)) == 0 )
    {
      open_counter_2 = open_counter_1;
      break;
    }
  }
  snd_openflag_ |= 1 << open_counter_2;
  seq_init = SsInitSoundSeq_(open_counter_2, vab_id, (u8 *)addr);
  SsFCALL.noteon = SsNoteOn_;
  SsFCALL.programchange = SsSetProgramChange_;
  SsFCALL.metaevent = SsGetMetaEvent_;
  SsFCALL.pitchbend = SsSetPitchBend_;
  SsFCALL.control[0] = SsSetControlChange_;
  SsFCALL.control[1] = SsContBankChange_;
  SsFCALL.control[3] = SsContMainVol_;
  SsFCALL.control[4] = SsContPanpot_;
  SsFCALL.control[5] = SsContExpression_;
  SsFCALL.control[6] = SsContDamper_;
  SsFCALL.control[7] = SsContNrpn1_;
  SsFCALL.control[8] = SsContNrpn2_;
  SsFCALL.control[9] = SsContRpn1_;
  SsFCALL.control[10] = SsContRpn2_;
  SsFCALL.control[11] = SsContExternal_;
  SsFCALL.control[12] = SsContResetAll_;
  SsFCALL.control[2] = SsContDataEntry_;
  SsFCALL.ccentry[0] = SsSetNrpnVabAttr0_;
  SsFCALL.ccentry[1] = SsSetNrpnVabAttr1_;
  SsFCALL.ccentry[2] = SsSetNrpnVabAttr2_;
  SsFCALL.ccentry[3] = SsSetNrpnVabAttr3_;
  SsFCALL.ccentry[4] = SsSetNrpnVabAttr4_;
  SsFCALL.ccentry[5] = SsSetNrpnVabAttr5_;
  SsFCALL.ccentry[6] = SsSetNrpnVabAttr6_;
  SsFCALL.ccentry[7] = SsSetNrpnVabAttr7_;
  SsFCALL.ccentry[8] = SsSetNrpnVabAttr8_;
  SsFCALL.ccentry[9] = SsSetNrpnVabAttr9_;
  SsFCALL.ccentry[10] = SsSetNrpnVabAttr10_;
  SsFCALL.ccentry[11] = SsSetNrpnVabAttr11_;
  SsFCALL.ccentry[12] = SsSetNrpnVabAttr12_;
  SsFCALL.ccentry[13] = SsSetNrpnVabAttr13_;
  SsFCALL.ccentry[14] = SsSetNrpnVabAttr14_;
  SsFCALL.ccentry[15] = SsSetNrpnVabAttr15_;
  SsFCALL.ccentry[16] = SsSetNrpnVabAttr16_;
  SsFCALL.ccentry[17] = SsSetNrpnVabAttr17_;
  SsFCALL.ccentry[18] = SsSetNrpnVabAttr18_;
  SsFCALL.ccentry[19] = SsSetNrpnVabAttr19_;
  if ( seq_init == -1 )
    return -1;
  return open_counter_2;
}
// 41C138: using guessed type int (__fastcall *)(_DWORD, _DWORD);
// 41C170: using guessed type int (__fastcall *)(_DWORD, _DWORD);

// ssopenpj.o

//----- (0040FB90) --------------------------------------------------------
s16 __fastcall SsSepOpenJ(unsigned int *addr, s16 vab_id, s16 seq_cnt)
{
  s16 v4; // $s3
  unsigned int v6; // $v1
  __int16 v8; // $s0

  v4 = 0;
  if ( snd_openflag_ == (u32)-1 )
  {
    printf("Can't Open Sequence data any more\n\n");
    return -1;
  }
  for ( v6 = 0; v6 < 32; v6 += 1 )
  {
    if ( (snd_openflag_ & ((u32)1 << v6)) == 0 )
    {
      v4 = v6;
      break;
    }
  }
  snd_openflag_ |= 1 << v4;
  for ( v8 = 0; v8 < seq_cnt; v8 += 1 )
  {
    int inited; // $v0

    inited = SsInitSoundSep_(v4, v8, vab_id, (u8 *)addr);
    addr = (unsigned int *)((char *)addr + inited);
    if ( inited == -1 )
      return -1;
  }
  return v4;
}

// ssopenqj.o

//----- (0040FCC0) --------------------------------------------------------
s16 __fastcall SsSeqOpenJ(unsigned int *addr, s16 vab_id)
{
  s16 v2; // $t0
  unsigned int v4; // $v1

  v2 = 0;
  if ( snd_openflag_ == (u32)-1 )
  {
    printf("Can't Open Sequence data any more\n\n");
    return -1;
  }
  for ( v4 = 0; v4 < 32; v4 += 1 )
  {
    if ( (snd_openflag_ & ((u32)1 << v4)) == 0 )
    {
      v2 = v4;
      break;
    }
  }
  snd_openflag_ |= 1 << v2;
  if ( SsInitSoundSeq_(v2, vab_id, (u8 *)addr) == -1 )
    return -1;
  return v2;
}

// sspause.o

//----- (0040FD90) --------------------------------------------------------
void __fastcall SsSndSetPauseMode_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[sep_no][seq_no];
  SsVmGetSeqVol_(
    sep_no | (seq_no << 8),
    &score_struct->m_unk5C,
    &score_struct->m_unk5E);
  score_struct->m_flags &= ~1u;
  score_struct->m_flags &= ~8u;
  score_struct->m_flags |= 2u;
}

//----- (0040FE70) --------------------------------------------------------
void __fastcall SsSeqPause(s16 sep_no)
{
  SsSndSetPauseMode_(sep_no, 0);
}

//----- (0040FE98) --------------------------------------------------------
void __fastcall SsSepPause(s16 sep_no, s16 seq_no)
{
  SsSndSetPauseMode_(sep_no, seq_no);
}

// ssplay.o

//----- (0040FED0) --------------------------------------------------------
void __fastcall SsSeqPlay(s16 sep_no, char play_mode, s16 l_count)
{
  Snd_SetPlayMode(sep_no, 0, play_mode, l_count);
}

//----- (0040FF08) --------------------------------------------------------
void __fastcall SsSepPlay(s16 sep_no, s16 seq_no, char play_mode, s16 l_count)
{
  Snd_SetPlayMode(sep_no, seq_no, play_mode, l_count);
}

// ssplayb.o

//----- (0040FF50) --------------------------------------------------------
void __fastcall SsPlayBack(s16 sep_no, s16 seq_no, s16 l_count)
{
  libsnd2_sequence_struct_t *score_struct; // $t1

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_flags &= ~0x200u;
  score_struct->m_flags &= ~4u;
  score_struct->m_flags |= 1u;
  score_struct->m_l_count = l_count;
  score_struct->m_unk21 = 0;
  score_struct->m_seq_ptr = score_struct->m_unk04;
  SsVmSetSeqVol_((sep_no | (seq_no << 8)), score_struct->m_voll, score_struct->m_volr);
}

// ssquit.o

//----- (00410020) --------------------------------------------------------
void SsQuit(void)
{
  SpuQuit();
}

// ssreplay.o

//----- (00410040) --------------------------------------------------------
void __fastcall SsSndSetReplayMode_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $v1
  unsigned int m_flags; // $a1

  score_struct = &ss_score_[sep_no][seq_no];
  m_flags = score_struct->m_flags;
  if ( (m_flags & 0x204) == 0 && (m_flags & 0x100) == 0 )
  {
    score_struct->m_flags = m_flags & 0xFFFFFFFD;
    score_struct->m_flags |= 8u;
    score_struct->m_flags |= 1u;
  }
}

//----- (004100E8) --------------------------------------------------------
void __fastcall SsSeqReplay(s16 sep_no)
{
  SsSndSetReplayMode_(sep_no, 0);
}

//----- (00410110) --------------------------------------------------------
void __fastcall SsSepReplay(s16 sep_no, s16 seq_no)
{
  SsSndSetReplayMode_(sep_no, seq_no);
}

// playmode.o

//----- (00410140) --------------------------------------------------------
void __fastcall Snd_SetPlayMode(s16 sep_no, s16 seq_no, char play_mode, char l_count)
{
  libsnd2_sequence_struct_t *score_struct; // $t0
  u8 *m_unk04; // $a0

  score_struct = &ss_score_[sep_no][seq_no];
  m_unk04 = score_struct->m_unk04;
  score_struct->m_seq_ptr = m_unk04;
  score_struct->m_unk08 = m_unk04;
  score_struct->m_unk0C = m_unk04;
  score_struct->m_flags &= ~0x200u;
  score_struct->m_flags &= ~4u;
  score_struct->m_l_count = l_count;
  switch (play_mode)
  {
    case 0:
      score_struct->m_flags |= 2u;
      break;
    case 1:
      score_struct->m_flags |= 1u;
      score_struct->m_play_mode = play_mode;
      score_struct->m_unk21 = 0;
      SsVmSetSeqVol_((sep_no | (seq_no << 8)), score_struct->m_voll, score_struct->m_volr);
      break;
    default:
      break;
  }
}

// ssrit.o

//----- (00410280) --------------------------------------------------------
void __fastcall SsSndSetRit_(s16 sep_no, s16 seq_no, int tempo, int v_time)
{
  libsnd2_sequence_struct_t *score_struct; // $t0
  unsigned int m_flags; // $v1

  score_struct = &ss_score_[sep_no][seq_no];
  m_flags = score_struct->m_flags;
  if ( (m_flags & 1) != 0 && (m_flags & 2) == 0 )
  {
    int m_unk94; // $v1

    m_unk94 = score_struct->m_unk94;
    if ( tempo != m_unk94 )
    {
      score_struct->m_unkA4 = v_time;
      score_struct->m_unkAC = tempo;
      score_struct->m_unkA8 = v_time;
      if ( ((tempo - m_unk94 >= 0) && (tempo - m_unk94 < v_time)) || ((tempo - m_unk94 < 0) && (m_unk94 - tempo < v_time)) )
      {
        int v9; // $v0
        int m_unkA8; // $v1
        int v11; // $a0
        int v13; // $v0

        v9 = score_struct->m_unk94;
        m_unkA8 = score_struct->m_unkA8;
        v11 = tempo - v9;
        v13 = v9 - tempo;
        if ( v11 < 0 )
        {
          if ( v13 == -1 && (unsigned int)m_unkA8 == 0x80000000 )
            __builtin_trap();
          score_struct->m_unk4E = m_unkA8 / v13;
        }
        else if ( v11 > 0 )
        {
          score_struct->m_unk4E = m_unkA8 / v11;
        }
        else
          __builtin_trap();
      }
      else
      {
        int v14; // $v1
        int v15; // $a0
        int v16; // $v0

        v14 = score_struct->m_unk94;
        v15 = score_struct->m_unkA8;
        v16 = tempo - v14;
        if ( tempo - v14 < 0 )
          v16 = v14 - tempo;
        if ( v15 == -1 && (unsigned int)v16 == 0x80000000 )
          __builtin_trap();
        score_struct->m_unk4E = ~(u16)(v16 / v15);
      }
      score_struct->m_flags |= 0x80u;
      score_struct->m_flags &= ~0x40u;
    }
  }
}
// 410334: conditional instruction was optimized away because $a0.4!=0
// 410364: conditional instruction was optimized away because $v0.4!=0
// 4103AC: conditional instruction was optimized away because $a0.4!=0

//----- (0041044C) --------------------------------------------------------
void __fastcall SsSeqSetRitardando(s16 sep_no, int tempo, int v_time)
{
  SsSndSetRit_(sep_no, 0, tempo, v_time);
}

//----- (00410480) --------------------------------------------------------
void __fastcall SsSepSetRitardando(s16 sep_no, s16 seq_no, int tempo, int v_time)
{
  SsSndSetRit_(sep_no, seq_no, tempo, v_time);
}

// ssp.o

//----- (004104B0) --------------------------------------------------------
int __fastcall SsSeqSkip(s16 sep_no, s16 seq_no, char unit, s16 count)
{
  int m_unk54; // $s1
  int v5; // $s5
  libsnd2_sequence_struct_t *score_struct; // $s0
  void (__fastcall *noteon)(s16, s16, u8, u8); // $s6
  u8 *m_unk04; // $v0
  int m_unk84; // $v0
  u8 *v19; // $v1

  m_unk54 = 0;
  v5 = 0;
  score_struct = &ss_score_[sep_no][seq_no];
  if ( count < 0 )
    return -1;
  if ( !count )
    return 0;
  noteon = SsFCALL.noteon;
  m_unk04 = score_struct->m_unk04;
  snd_ev_flag_ = 1;
  score_struct->m_seq_ptr = m_unk04;
  SsFCALL.noteon = dmy_nothing1;
  switch (unit)
  {
    case 0:
      m_unk54 = score_struct->m_unk54 * count;
      break;
    case 1:
      m_unk54 = count * 10 * score_struct->m_resolution_of_quarter_note;
      break;
    case 2:
      m_unk54 = count * 5 * score_struct->m_resolution_of_quarter_note;
      break;
    case 3:
    {
      int m_rhythm_d; // $a0

      m_rhythm_d = score_struct->m_rhythm_d;
      if ( m_rhythm_d == 2 )
      {
        m_unk54 = score_struct->m_rhythm_n * count * 10 * score_struct->m_resolution_of_quarter_note;
      }
      else
      {
        int v15; // $v1

        v15 = count * 10 * score_struct->m_resolution_of_quarter_note;
        if ( (1 << m_rhythm_d) == 0 )
          __builtin_trap();
        if ( 1 << m_rhythm_d == -1 && (unsigned int)v15 == 0x80000000 )
          __builtin_trap();
        m_unk54 = v15 / (1 << m_rhythm_d) * score_struct->m_rhythm_n;
      }
      break;
    }
    default:
      break;
  }
  do
  {
    do
    {
      if ( SsGetSeqData_(sep_no, seq_no) == 1 )
      {
        m_unk54 = score_struct->m_unk54;
        m_unk84 = score_struct->m_unk84;
        v19 = score_struct->m_unk04;
        v5 = -1;
        score_struct->m_unk10 = 0;
        score_struct->m_delta_value = m_unk84;
        score_struct->m_seq_ptr = v19;
        score_struct->m_unk0C = v19;
        break;
      }
    }
    while ( !score_struct->m_delta_value );
    m_unk54 -= score_struct->m_delta_value;
  }
  while ( score_struct->m_unk54 < m_unk54 );
  SsFCALL.noteon = noteon;
  snd_ev_flag_ = 0;
  return v5;
}
// 4106D0: variable 'm_unk54' is possibly undefined

// sssp.o

//----- (00410720) --------------------------------------------------------
int __fastcall SsSetCurrentPoint(s16 sep_no, s16 seq_no, u8 *point)
{
  libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[sep_no][seq_no];
  if ( point == NULL )
  {
    return -1;
  }
  score_struct->m_seq_ptr = point;
  return 0;
}

// sspptp.o

//----- (00410770) --------------------------------------------------------
void __fastcall SsSeqPlayPtoP(s16 sep_no, s16 seq_no, u8 *start_point, u8 *end_point, char play_mode, s16 l_count)
{
  libsnd2_sequence_struct_t *score_struct; // $t0

  score_struct = &ss_score_[sep_no][seq_no];
  if ( start_point == end_point || end_point < start_point )
  {
    printf("bad address setting!!\n");
    return;
  }
  score_struct->m_seq_ptr = start_point;
  score_struct->m_unk08 = start_point;
  score_struct->m_unk0C = start_point;
  score_struct->m_unk10 = end_point;
  score_struct->m_flags &= ~0x200u;
  score_struct->m_flags &= ~4u;
  score_struct->m_l_count = l_count;
  switch (play_mode)
  {
    case 0:
      score_struct->m_flags |= 2u;
      break;
    case 1:
      score_struct->m_flags |= 1u;
      score_struct->m_flags |= 0x400u;
      score_struct->m_play_mode = 1;
      score_struct->m_unk21 = 0;
      SsVmSetSeqVol_((sep_no | (seq_no << 8)), score_struct->m_voll, score_struct->m_volr);
      break;
    default:
      break;
  }
}

// sssattr.o

//----- (004108F0) --------------------------------------------------------
void __fastcall SsSetSerialAttr(char s_num, char attr, char mode)
{
  SpuCommonAttr spu_attr; // [sp+10h] [-28h] BYREF

  switch (s_num)
  {
    case 0:
      switch (attr)
      {
        case 0:
          spu_attr.mask = 512;
          spu_attr.cd.mix = mode;
          break;
        case 1:
          spu_attr.mask = 256;
          spu_attr.cd.reverb = mode;
          break;
        default:
          break;
      }
      break;
    case 1:
      switch (attr)
      {
        case 0:
          spu_attr.mask = 0x2000;
          spu_attr.ext.mix = mode;
          break;
        case 1:
          spu_attr.mask = 4096;
          spu_attr.ext.reverb = mode;
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
  SpuSetCommonAttr(&spu_attr);
}

// sssm.o

//----- (004109B0) --------------------------------------------------------
void __fastcall SsSetMute(char mode)
{
  int mute_val; // $a0

  switch (mode)
  {
    case 0:
      mute_val = 0;
      break;
    case 1:
      mute_val = 1;
      break;
    default:
      return;
  }
  SpuSetMute(mute_val);
}

// sssmv.o

//----- (00410A00) --------------------------------------------------------
void __fastcall SsSetMVol(s16 voll, s16 volr)
{
  SpuCommonAttr spu_attr; // [sp+10h] [-28h] BYREF

  spu_attr.mask = 3;
  spu_attr.mvol.left = 129 * voll;
  spu_attr.mvol.right = 129 * volr;
  SpuSetCommonAttr(&spu_attr);
}

// sssnc.o

//----- (00410A50) --------------------------------------------------------
void __fastcall SsSetNck(s16 n_clock)
{
  SpuSetNoiseClock(n_clock);
}

// sssrv.o

//----- (00410A80) --------------------------------------------------------
void __fastcall SsSetRVol(s16 voll, s16 volr)
{
  SpuReverbAttr reverb_attr; // [sp+10h] [-18h] BYREF

  reverb_attr.mask = 6;
  reverb_attr.depth.left = (__int16)(0x7FFF * voll) / 127;
  reverb_attr.depth.right = 0x7FFF * volr / 127;
  SpuSetReverbDepth(&reverb_attr);
}

// ssstart.o

#ifdef LIB_1300
void SsTrapIntrVSync_(void)
{
  if ( snd_seq_tick_env_.m_vsync_callback )
    snd_seq_tick_env_.m_vsync_callback();
  snd_seq_tick_env_.m_tick_callback();
}
#endif

#ifdef LIB_1300
void SsSeqCalledTbyT_1per2_(void)
{
  static int n_4 = 0;

  if ( n_4 )
  {
    n_4 = 0;
    snd_seq_tick_env_.m_tick_callback();
  }
  else
  {
    n_4 = 1;
  }
}
#endif

//----- (00410B10) --------------------------------------------------------
int __fastcall SsTrapIntrProcIOP_(void *userdata)
{
  snd_seq_tick_env_.m_tick_callback();
  return *(_DWORD *)userdata;
}

//----- (00410B40) --------------------------------------------------------
static void __fastcall SsStart_(int start_param)
{
  int wait_tmp; // $v0
#ifndef LIB_1300
  u32 rcount_target; // $s0
  iop_sys_clock_t iop_clock; // [sp+10h] [-8h] BYREF
#endif

#ifndef LIB_1300
  rcount_target = 4166;
#endif
  for ( wait_tmp = 0; wait_tmp < 999; wait_tmp += 1 )
  {
    __asm__ __volatile__("" : "+g" (wait_tmp) : :);
  }
  snd_seq_tick_env_.m_alarm_tick = 6;
  snd_seq_tick_env_.m_vsync_tick = 0;
  snd_seq_tick_env_.m_unk11 = 0;
  snd_seq_tick_env_.m_vsync_callback = 0;
  switch (snd_seq_tick_env_.m_tick_mode)
  {
    case 0:
      snd_seq_tick_env_.m_alarm_tick = 127;
      return;
    case 2:
      break;
    case 3:
#ifndef LIB_1300
      rcount_target = 8332;
#endif
      break;
    case 5:
      snd_seq_tick_env_.m_alarm_tick = 0;
      if ( !start_param )
        snd_seq_tick_env_.m_vsync_tick = 1;
#ifndef LIB_1300
      else
        rcount_target = 1;
#endif
      break;
    case 1:
    case 4:
    default:
      if ( snd_seq_tick_env_.m_manual_tick )
        return;
#ifdef LIB_1300
      if ( snd_seq_tick_env_.m_tick_mode < 70 )
      {
        snd_seq_tick_env_.m_unk11 += 1;
        return;
      }
#endif
#ifndef LIB_1300
      if ( snd_seq_tick_env_.m_tick_mode == 0 )
        __builtin_trap();
      rcount_target = -1000000;
#endif
      break;
  }
#ifndef LIB_1300
  CpuDisableIntr();
  if ( snd_seq_tick_env_.m_vsync_tick )
  {
    RegisterVblankHandler(0, 64, SsTrapIntrProcIOP_, &snd_seq_interval_);
    EnableIntr(0);
  }
  else if ( snd_seq_tick_env_.m_alarm_tick )
  {
    USec2SysClock(rcount_target, &iop_clock);
    snd_seq_interval_ = iop_clock.lo;
    SetAlarm(&iop_clock, (unsigned int (__fastcall *)(void *))SsTrapIntrProcIOP_, &snd_seq_interval_);
  }
  else
  {
    EnableIntr(0);
    RegisterVblankHandler(0, 64, SsTrapIntrProcIOP_, &snd_seq_interval_);
  }
  CpuEnableIntr();
#endif
}

//----- (00410CF8) --------------------------------------------------------
void SsStart(void)
{
  SsStart_(1);
}

//----- (00410D18) --------------------------------------------------------
void SsStart2(void)
{
  SsStart_(0);
}

// ssstop.o

//----- (00410D40) --------------------------------------------------------
void __fastcall SsSndStop_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $s0
  int i_tmp; // $a3
  u8 *m_unk04; // $a1

  score_struct = &ss_score_[sep_no][seq_no];
  score_struct->m_flags &= ~1u;
  score_struct->m_flags &= ~2u;
  score_struct->m_flags &= ~8u;
  score_struct->m_flags &= ~0x400u;
  score_struct->m_flags |= 4u;
  SsVmSeqKeyOff_(sep_no | (seq_no << 8));
  SsVmDamperOff_();
  m_unk04 = score_struct->m_unk04;
  score_struct->m_play_mode = 0;
  score_struct->m_unk88 = 0;
  score_struct->m_unk1C = 0;
  score_struct->m_unk18 = 0;
  score_struct->m_unk19 = 0;
  score_struct->m_unk1E = 0;
  score_struct->m_fn_idx = 0;
  score_struct->m_unk1B = 0;
  score_struct->m_unk1F = 0;
  score_struct->m_channel_idx = 0;
  score_struct->m_unk21 = 0;
  score_struct->m_unk1C = 0;
  score_struct->m_unk1D = 0;
  score_struct->m_unk15 = 0;
  score_struct->m_running_status = 0;
  score_struct->m_delta_value = score_struct->m_unk84;
  score_struct->m_unk94 = score_struct->m_tempo;
  score_struct->m_unk54 = score_struct->m_unk56;
  score_struct->m_seq_ptr = m_unk04;
  score_struct->m_unk08 = m_unk04;
  for ( i_tmp = 0; i_tmp < 16; i_tmp += 1 )
  {
    score_struct->m_programs[i_tmp] = i_tmp;
    score_struct->m_panpot[i_tmp] = 64;
    score_struct->m_vol[i_tmp] = 127;
  }
  score_struct->m_unk5C = 127;
  score_struct->m_unk5E = 127;
}

//----- (00410EDC) --------------------------------------------------------
void __fastcall SsSeqStop(s16 sep_no)
{
  SsSndStop_(sep_no, 0);
}

//----- (00410F04) --------------------------------------------------------
void __fastcall SsSepStop(s16 sep_no, s16 seq_no)
{
  SsSndStop_(sep_no, seq_no);
}

// sssv.o

//----- (00410F30) --------------------------------------------------------
void __fastcall SsSetSerialVol(char s_num, s16 voll, s16 volr)
{
  s16 voll_tmp; // $a3
  s16 volr_tmp; // $t0
  SpuCommonAttr spu_attr; // [sp+10h] [-28h] BYREF

  voll_tmp = voll;
  volr_tmp = volr;
  switch (s_num)
  {
    case 0:
      spu_attr.mask = 192;
      if ( voll >= 128 )
        voll_tmp = 127;
      if ( volr >= 128 )
        volr_tmp = 127;
      spu_attr.cd.volume.left = 258 * voll_tmp;
      spu_attr.cd.volume.right = 258 * volr_tmp;
      break;
    case 1:
      spu_attr.mask = 3072;
      if ( voll_tmp >= 128 )
        voll_tmp = 127;
      if ( volr_tmp >= 128 )
        volr_tmp = 127;
      spu_attr.ext.volume.left = 258 * voll_tmp;
      spu_attr.ext.volume.right = 258 * volr_tmp;
      break;
  }
  SpuSetCommonAttr(&spu_attr);
}

// sstable.o

//----- (00411040) --------------------------------------------------------
void __fastcall SsSetTableSize(char *table, s16 s_max, s16 t_max)
{
  int typed_table_i; // $a3
  unsigned int openflag_i; // $a3
  int i; // $a3

  snd_seq_s_max_ = s_max;
  snd_seq_t_max_ = t_max;
  for ( typed_table_i = 0; typed_table_i < s_max; typed_table_i += 1 )
  {
    ss_score_[typed_table_i] = (libsnd2_sequence_struct_t *)&table[176 * (t_max * typed_table_i)];
  }
  for ( openflag_i = s_max; openflag_i < 32; openflag_i += 1 )
  {
    snd_openflag_ |= (u32)1 << openflag_i;
  }
  for ( i = 0; i < snd_seq_s_max_; i += 1 )
  {
    int j; // $a2

    j = 0;
    for ( j = 0; j < snd_seq_t_max_; j += 1 )
    {
      libsnd2_sequence_struct_t *score_struct;

      score_struct = &ss_score_[i][j];
      score_struct->m_flags = 0;
      *(_WORD *)&score_struct->m_next_sep = 255;
      score_struct->m_unk48 = 0;
      score_struct->m_unk4A = 0;
      score_struct->m_unk9C = 0;
      score_struct->m_unkA0 = 0;
      score_struct->m_unk4C = 0;
      score_struct->m_unkAC = 0;
      score_struct->m_unkA8 = 0;
      score_struct->m_unkA4 = 0;
      score_struct->m_unk4E = 0;
      score_struct->m_voll = 127;
      score_struct->m_volr = 127;
      score_struct->m_unk5C = 127;
      score_struct->m_unk5E = 127;
    }
  }
}

// sstempo.o

//----- (004112D0) --------------------------------------------------------
void __fastcall SsSetTempo(s16 sep_no, s16 seq_no, s16 tempo)
{
  libsnd2_sequence_struct_t *score_struct; // $a1
  unsigned int v4; // $lo
  int v5; // $a0
  int v6; // $t0
  unsigned int v7; // $a2

  score_struct = &ss_score_[sep_no][seq_no];
  v4 = score_struct->m_resolution_of_quarter_note * tempo;
  v5 = VBLANK_MINUS;
  v6 = 15 * VBLANK_MINUS;
  score_struct->m_unk94 = tempo;
  v7 = 4 * v6;
  if ( 10 * v4 < (unsigned int)(4 * v6) )
  {
    unsigned int v9; // $lo

    if ( !v4 )
      __builtin_trap();
    v9 = 600 * v5 / v4;
    score_struct->m_unk52 = v9;
    score_struct->m_unk54 = v9;
  }
  else
  {
    unsigned int v11; // $lo
    unsigned int v12; // $hi

    v11 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_unk94 / v7;
    v12 = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_unk94 % v7;
    score_struct->m_unk52 = -1;
    score_struct->m_unk54 = v11;
    if ( (unsigned int)(2 * v6) < v12 )
    {
      score_struct->m_unk54 = v11 + 1;
    }
  }
  score_struct->m_unk56 = score_struct->m_unk54;
}
// 411394: conditional instruction was optimized away because $a2.4!=0
// 4113C4: conditional instruction was optimized away because $a2.4!=0

// sstick.o

//----- (00411400) --------------------------------------------------------
void __fastcall SsSetTickMode(int tick_mode)
{
  if ( (tick_mode & 0x1000) != 0 )
  {
    snd_seq_tick_env_.m_manual_tick = 1;
    snd_seq_tick_env_.m_tick_mode = tick_mode & 0xFFF;
  }
  else
  {
    snd_seq_tick_env_.m_manual_tick = 0;
    snd_seq_tick_env_.m_tick_mode = tick_mode;
  }
  switch ( snd_seq_tick_env_.m_tick_mode )
  {
    case 0:
    case 5:
      VBLANK_MINUS = 60;
      break;
    case 1:
      VBLANK_MINUS = 60;
      snd_seq_tick_env_.m_tick_mode = 5;
      break;
    case 2:
      VBLANK_MINUS = 240;
      break;
    case 3:
      VBLANK_MINUS = 120;
      break;
    case 4:
      VBLANK_MINUS = 50;
      snd_seq_tick_env_.m_tick_mode = 50;
      break;
    default:
      VBLANK_MINUS = snd_seq_tick_env_.m_tick_mode;
      break;
  }
}

// sstickcb.o

//----- (00411540) --------------------------------------------------------
void *__fastcall SsSetTickCallback(void (*cb)(void))
{
  void *result; // $v0

  result = snd_seq_tick_env_.m_tick_callback;
  if ( cb != snd_seq_tick_env_.m_tick_callback )
    snd_seq_tick_env_.m_tick_callback = cb;
  return result;
}

// ssvkoff.o

//----- (00411570) --------------------------------------------------------
int __fastcall SsVoKeyOff(int vab_pro, int pitch)
{
  return SsVmSeKeyOff_(vab_pro >> 8, (u8)vab_pro, (unsigned int)pitch >> 8);
}

// ssvkon.o

//----- (004115B0) --------------------------------------------------------
int __fastcall SsVoKeyOn(int vab_pro, int pitch, u16 voll, u16 volr)
{
  return SsVmSeKeyOn_(
           vab_pro >> 8,
           (u8)vab_pro,
           (unsigned int)pitch >> 8,
           (u8)pitch,
           voll,
           volr);
}

// ssvol.o

//----- (00411600) --------------------------------------------------------
void __fastcall SsSndSetVol_(s16 sep_no, s16 seq_no, u16 voll, u16 volr)
{
  libsnd2_sequence_struct_t *score_struct; // $a0

  score_struct = &ss_score_[sep_no][seq_no];
  if ( score_struct->m_flags == 1 )
  {
    SsVmSetSeqVol_(sep_no | (seq_no << 8), voll, volr);
  }
  else
  {
    score_struct->m_voll = voll;
    score_struct->m_volr = volr;
  }
}

//----- (00411690) --------------------------------------------------------
void __fastcall SsSeqSetVol(s16 sep_no, s16 voll, s16 volr)
{
  SsSndSetVol_(sep_no, 0, voll, volr);
}

//----- (004116C8) --------------------------------------------------------
void __fastcall SsSepSetVol(s16 sep_no, s16 seq_no, s16 voll, s16 volr)
{
  SsSndSetVol_(sep_no, seq_no, voll, volr);
}

//----- (00411704) --------------------------------------------------------
void __fastcall SsSeqGetVol(s16 sep_no, s16 seq_no, s16 *voll, s16 *volr)
{
  SsVmGetSeqVol_(sep_no | (seq_no << 8), voll, volr);
}

// tempo.o

//----- (00411740) --------------------------------------------------------
void __fastcall SsSndTempo_(s16 sep_no, s16 seq_no)
{
  libsnd2_sequence_struct_t *score_struct; // $a3
  int unk_a8_dec; // $v0
  int m_unk4E; // $a0
  unsigned int calc; // $lo

  score_struct = &ss_score_[sep_no][seq_no];
  unk_a8_dec = score_struct->m_unkA8 - 1;
  score_struct->m_unkA8 = unk_a8_dec;
  if ( unk_a8_dec < 0 )
  {
    score_struct->m_flags &= ~0x40u;
    score_struct->m_flags &= ~0x80u;
    return;
  }
  m_unk4E = score_struct->m_unk4E;
  if ( m_unk4E <= 0 )
  {
    unsigned int m_unk94; // $v1
    unsigned int m_unkAC; // $t0
    unsigned int v14; // $v0

    m_unk94 = score_struct->m_unk94;
    m_unkAC = score_struct->m_unkAC;
    v14 = m_unk94 + m_unk4E;
    if ( m_unkAC >= m_unk94 )
    {
      if ( m_unk94 < m_unkAC )
      {
        unsigned int v16; // $v0

        v16 = m_unk94 - m_unk4E;
        m_unkAC = score_struct->m_unkAC;
        score_struct->m_unk94 = v16;
        if ( m_unkAC < v16 )
          score_struct->m_unk94 = m_unkAC;
      }
    }
    else
    {
      score_struct->m_unk94 = v14;
      if ( v14 < m_unkAC )
        score_struct->m_unk94 = m_unkAC;
    }
  }
  else
  {
    unsigned int v9; // $v1
    unsigned int v10; // $a0

    if ( !score_struct->m_unk4E )
      __builtin_trap();
    if ( unk_a8_dec % m_unk4E )
      return;
    v9 = score_struct->m_unk94;
    v10 = score_struct->m_unkAC;
    if ( v10 < v9 )
      score_struct->m_unk94 = v9 - 1;
    else if ( v9 < v10 )
      score_struct->m_unk94 = v9 + 1;
  }
  calc = 10 * score_struct->m_resolution_of_quarter_note * score_struct->m_unk94 / (unsigned int)(60 * VBLANK_MINUS);
  if ( (60 * VBLANK_MINUS) == 0 )
    __builtin_trap();
  score_struct->m_unk54 = calc;
  if ( (int)(calc << 16) <= 0 )
    score_struct->m_unk54 = 1;
  if ( !score_struct->m_unkA8 || score_struct->m_unk94 == score_struct->m_unkAC )
  {
    score_struct->m_flags &= ~0x40u;
    score_struct->m_flags &= ~0x80u;
  }
}
// 4117E0: conditional instruction was optimized away because $a0.4 is in (1..7FFF)

// vol.o

//----- (00411960) --------------------------------------------------------
void __fastcall SsSndSetVolData_(s16 sep_no, s16 seq_no, int vol, int v_time)
{
  libsnd2_sequence_struct_t *score_struct; // $v1
  unsigned int m_flags; // $a0

  score_struct = &ss_score_[sep_no][seq_no];
  m_flags = score_struct->m_flags;
  if ( (m_flags & 4) == 0 && (m_flags & 0x100) == 0 && (vol << 16) != 0 )
  {
    score_struct->m_unk48 = vol;
    score_struct->m_unk9C = v_time;
    score_struct->m_unkA0 = 0;
    score_struct->m_unk4A = 0;
  }
}

// dmyprint.o

//----- (004119D0) --------------------------------------------------------
void __fastcall dmy_nothing1(s16 seq_no, s16 sep_no, u8 note, u8 vollr)
{
  (void)sep_no;
  (void)seq_no;
  (void)note;
  (void)vollr;
}

//----- (004119D8) --------------------------------------------------------
void __fastcall dmy_SsNoteOn(s16 sep_no, s16 seq_no, u8 note, u8 vollr)
{
  (void)sep_no;
  (void)seq_no;
  (void)note;
  (void)vollr;
  if ( !is_first_dmy_SsNoteOn )
  {
    printf("_SsNoteOn\n");
    is_first_dmy_SsNoteOn = 1;
  }
}

//----- (00411A14) --------------------------------------------------------
void __fastcall dmy_SsSetProgramChange(s16 sep_no, s16 seq_no, u8 prog)
{
  (void)sep_no;
  (void)seq_no;
  (void)prog;
  if ( !is_first_dmy_SsSetProgramChange )
  {
    printf("_SsSetProgramChange\n");
    is_first_dmy_SsSetProgramChange = 1;
  }
}

//----- (00411A50) --------------------------------------------------------
void __fastcall dmy_SsGetMetaEvent(s16 sep_no, s16 seq_no, u8 meta_event)
{
  (void)sep_no;
  (void)seq_no;
  (void)meta_event;
  if ( !is_first_dmy_SsGetMetaEvent )
  {
    printf("_SsGetMetaEvent\n");
    is_first_dmy_SsGetMetaEvent = 1;
  }
}

//----- (00411A8C) --------------------------------------------------------
void __fastcall dmy_SsSetPitchBend(s16 sep_no, s16 seq_no)
{
  (void)sep_no;
  (void)seq_no;
  if ( !is_first_dmy_SsSetPitchBend )
  {
    printf("_SsSetPitchBend\n");
    is_first_dmy_SsSetPitchBend = 1;
  }
}

//----- (00411AC8) --------------------------------------------------------
void __fastcall dmy_SsSetControlChange(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsSetControlChange )
  {
    printf("_SsSetControlChange\n");
    is_first_dmy_SsSetControlChange = 1;
  }
}

//----- (00411B04) --------------------------------------------------------
void __fastcall dmy_SsContBankChange(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContBankChange )
  {
    printf("_SsContBankChange\n");
    is_first_dmy_SsContBankChange = 1;
  }
}

//----- (00411B40) --------------------------------------------------------
void __fastcall dmy_SsContDataEntry(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContDataEntry )
  {
    printf("_SsContDataEntry\n");
    is_first_dmy_SsContDataEntry = 1;
  }
}

//----- (00411B7C) --------------------------------------------------------
void __fastcall dmy_SsContMainVol(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContMainVol )
  {
    printf("_SsContMainVol\n");
    is_first_dmy_SsContMainVol = 1;
  }
}

//----- (00411BB8) --------------------------------------------------------
void __fastcall dmy_SsContPanpot(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContPanpot )
  {
    printf("_SsContPanpot\n");
    is_first_dmy_SsContPanpot = 1;
  }
}

//----- (00411BF4) --------------------------------------------------------
void __fastcall dmy_SsContExpression(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContExpression )
  {
    printf("_SsContExpression\n");
    is_first_dmy_SsContExpression = 1;
  }
}

//----- (00411C30) --------------------------------------------------------
void __fastcall dmy_SsContDamper(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContDamper )
  {
    printf("_SsContDamper\n");
    is_first_dmy_SsContDamper = 1;
  }
}

//----- (00411C6C) --------------------------------------------------------
void __fastcall dmy_SsContExternal(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContExternal )
  {
    printf("_SsContExternal\n");
    is_first_dmy_SsContExternal = 1;
  }
}

//----- (00411CA8) --------------------------------------------------------
void __fastcall dmy_SsContNrpn1(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContNrpn1 )
  {
    printf("_SsContNrpn1\n");
    is_first_dmy_SsContNrpn1 = 1;
  }
}

//----- (00411CE4) --------------------------------------------------------
void __fastcall dmy_SsContNrpn2(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContNrpn2 )
  {
    printf("_SsContNrpn2\n");
    is_first_dmy_SsContNrpn2 = 1;
  }
}

//----- (00411D20) --------------------------------------------------------
void __fastcall dmy_SsContRpn1(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContRpn1 )
  {
    printf("_SsContRpn1\n");
    is_first_dmy_SsContRpn1 = 1;
  }
}

//----- (00411D5C) --------------------------------------------------------
void __fastcall dmy_SsContRpn2(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContRpn2 )
  {
    printf("_SsContRpn2\n");
    is_first_dmy_SsContRpn2 = 1;
  }
}

//----- (00411D98) --------------------------------------------------------
void __fastcall dmy_SsContResetAll(s16 sep_no, s16 seq_no, u8 control_value)
{
  (void)sep_no;
  (void)seq_no;
  (void)control_value;
  if ( !is_first_dmy_SsContResetAll )
  {
    printf("_SsContResetAll\n");
    is_first_dmy_SsContResetAll = 1;
  }
}

//----- (00411DD4) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr0(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr0 )
  {
    printf("_SsSetNrpnVabAttr0\n");
    is_first_dmy_SsSetNrpnVabAttr0 = 1;
  }
}

//----- (00411E14) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr1(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr1 )
  {
    printf("_SsSetNrpnVabAttr1\n");
    is_first_dmy_SsSetNrpnVabAttr1 = 1;
  }
}

//----- (00411E54) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr2(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr2 )
  {
    printf("_SsSetNrpnVabAttr2\n");
    is_first_dmy_SsSetNrpnVabAttr2 = 1;
  }
}

//----- (00411E94) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr3(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr3 )
  {
    printf("_SsSetNrpnVabAttr3\n");
    is_first_dmy_SsSetNrpnVabAttr3 = 1;
  }
}

//----- (00411ED4) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr4(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr4 )
  {
    printf("_SsSetNrpnVabAttr4\n");
    is_first_dmy_SsSetNrpnVabAttr4 = 1;
  }
}

//----- (00411F14) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr5(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr5 )
  {
    printf("_SsSetNrpnVabAttr5\n");
    is_first_dmy_SsSetNrpnVabAttr5 = 1;
  }
}

//----- (00411F54) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr6(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr6 )
  {
    printf("_SsSetNrpnVabAttr6\n");
    is_first_dmy_SsSetNrpnVabAttr6 = 1;
  }
}

//----- (00411F94) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr7(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr7 )
  {
    printf("_SsSetNrpnVabAttr7\n");
    is_first_dmy_SsSetNrpnVabAttr7 = 1;
  }
}

//----- (00411FD4) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr8(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr8 )
  {
    printf("_SsSetNrpnVabAttr8\n");
    is_first_dmy_SsSetNrpnVabAttr8 = 1;
  }
}

//----- (00412014) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr9(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr9 )
  {
    printf("_SsSetNrpnVabAttr9\n");
    is_first_dmy_SsSetNrpnVabAttr9 = 1;
  }
}

//----- (00412054) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr10(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr10 )
  {
    printf("_SsSetNrpnVabAttr10\n");
    is_first_dmy_SsSetNrpnVabAttr10 = 1;
  }
}

//----- (00412094) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr11(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr11 )
  {
    printf("_SsSetNrpnVabAttr11\n");
    is_first_dmy_SsSetNrpnVabAttr11 = 1;
  }
}

//----- (004120D4) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr12(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr12 )
  {
    printf("_SsSetNrpnVabAttr12\n");
    is_first_dmy_SsSetNrpnVabAttr12 = 1;
  }
}

//----- (00412114) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr13(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr13 )
  {
    printf("_SsSetNrpnVabAttr13\n");
    is_first_dmy_SsSetNrpnVabAttr13 = 1;
  }
}

//----- (00412154) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr14(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr14 )
  {
    printf("_SsSetNrpnVabAttr14\n");
    is_first_dmy_SsSetNrpnVabAttr14 = 1;
  }
}

//----- (00412194) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr15(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr15 )
  {
    printf("_SsSetNrpnVabAttr15\n");
    is_first_dmy_SsSetNrpnVabAttr15 = 1;
  }
}

//----- (004121D4) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr16(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr16 )
  {
    printf("_SsSetNrpnVabAttr16\n");
    is_first_dmy_SsSetNrpnVabAttr16 = 1;
  }
}

//----- (00412214) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr17(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr17 )
  {
    printf("_SsSetNrpnVabAttr17\n");
    is_first_dmy_SsSetNrpnVabAttr17 = 1;
  }
}

//----- (00412254) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr18(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr18 )
  {
    printf("_SsSetNrpnVabAttr18\n");
    is_first_dmy_SsSetNrpnVabAttr18 = 1;
  }
}

//----- (00412294) --------------------------------------------------------
void __fastcall dmy_SsSetNrpnVabAttr19(s16 vab_id, s16 prog, s16 tone, VagAtr vag_attr, s16 fn_idx, u8 attribute_value)
{
  (void)vab_id;
  (void)prog;
  (void)tone;
  (void)vag_attr;
  (void)fn_idx;
  (void)attribute_value;
  if ( !is_first_dmy_SsSetNrpnVabAttr19 )
  {
    printf("_SsSetNrpnVabAttr19\n");
    is_first_dmy_SsSetNrpnVabAttr19 = 1;
  }
}

// ssgcp.o

//----- (004122E0) --------------------------------------------------------
u8 *__fastcall SsGetCurrentPoint(s16 sep_no, s16 seq_no)
{
  const libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[sep_no][seq_no];
  return score_struct->m_seq_ptr;
}

// ssvm.o

//----- (00412320) --------------------------------------------------------
void __fastcall SsSetVoiceMask(unsigned int s_voice)
{
  snd_vmask_ = s_voice;
}

//----- (00412330) --------------------------------------------------------
unsigned int SsGetVoiceMask(void)
{
  return snd_vmask_;
}

// ut_ako.o

//----- (00412340) --------------------------------------------------------
void __fastcall SsUtAllKeyOff(s16 mode)
{
  int vc_index; // $v0
  SpuVoiceAttr voice_attr; // [sp+10h] [-40h] BYREF

  (void)mode;

  voice_attr.mask = 393363;
  voice_attr.pitch = 4096;
  voice_attr.addr = 20480;
  voice_attr.adsr1 = -32513;
  voice_attr.volume.left = 0;
  voice_attr.volume.right = 0;
  voice_attr.adsr2 = 0x4000;
  for ( vc_index = 0; vc_index < SsVmMaxVoice_; vc_index += 1 )
  {
    if ( (snd_vmask_ & (1 << vc_index)) == 0 )
    {
      svm_voice_[vc_index].m_unk02 = 24;
      svm_voice_[vc_index].m_key_stat = 0;
      svm_voice_[vc_index].m_seq_sep_no = 255;
      svm_voice_[vc_index].m_fake_program = 0;
      svm_voice_[vc_index].m_prog = 0;
      svm_voice_[vc_index].m_tone = 255;
      svm_voice_[vc_index].m_voll2 = 0;
      voice_attr.voice = 1 << vc_index;
      SpuSetVoiceAttr(&voice_attr);
      svm_cur_.m_voice_idx = vc_index;
      SsVmKeyOffNow_();
    }
  }
}

// ut_autop.o

//----- (00412490) --------------------------------------------------------
s16 __fastcall SsUtAutoPan(s16 vc, s16 start_pan, s16 end_pan, s16 delta_time)
{
  autopan_ = (libsnd2_auto_vol_pan_callback)SetAutoPan;
  if ( (u16)vc >= 0x18u )
    return -1;
  SeAutoPan(vc, start_pan, end_pan, delta_time);
  return 0;
}

// ut_autov.o

//----- (00412500) --------------------------------------------------------
s16 __fastcall SsUtAutoVol(s16 vc, s16 start_vol, s16 end_vol, s16 delta_time)
{
  autovol_ = (libsnd2_auto_vol_pan_callback)SetAutoVol;
  if ( (u16)vc >= 0x18u )
    return -1;
  SeAutoVol(vc, start_vol, end_vol, delta_time);
  return 0;
}

// ut_cadsr.o

//----- (00412570) --------------------------------------------------------
s16 __fastcall SsUtChangeADSR(s16 vc, s16 vab_id, s16 prog, s16 old_note, u16 adsr1, u16 adsr2)
{
  if ( (u16)vc >= 24u )
    return -1;
  if ( svm_voice_[vc].m_vab_id != vab_id
    || svm_voice_[vc].m_prog != prog
    || svm_voice_[vc].m_note != old_note )
  {
    return -1;
  }
  svm_sreg_buf_[vc].m_adsr1 = adsr1;
  svm_sreg_buf_[vc].m_adsr2 = adsr2;
  svm_sreg_dirty_[vc] |= 0x30;
  return 0;
}

// ut_cp.o

//----- (00412640) --------------------------------------------------------
s16 __fastcall SsUtChangePitch(s16 vc, s16 vab_id, s16 prog, s16 old_note, s16 old_fine, s16 new_note, s16 new_fine)
{
  int m_vab_id; // $a0
  int m_prog; // $a1

  (void)old_fine;

  if ( (u16)vc >= 0x18u )
    return -1;
  m_vab_id = svm_voice_[vc].m_vab_id;
  if ( m_vab_id != vab_id )
  {
    return -1;
  }
  m_prog = svm_voice_[vc].m_prog;
  if ( m_prog != prog )
  {
    return -1;
  }
  if ( svm_voice_[vc].m_note != old_note )
  {
    return -1;
  }
  SsVmVSetUp_(m_vab_id, m_prog);
  svm_cur_.m_seq_sep_no = 33;
  svm_cur_.m_voice_idx = vc;
  svm_cur_.m_tone = svm_voice_[vc].m_tone;
  svm_sreg_buf_[vc].m_pitch = note2pitch2(new_note, new_fine);
  svm_sreg_dirty_[vc] |= 4u;
  return 0;
}

// ut_f.o

//----- (00412780) --------------------------------------------------------
void SsUtFlush(void)
{
  if ( snd_ev_flag_ != 1 )
  {
    snd_ev_flag_ = 1;
    SsVmFlush_();
    snd_ev_flag_ = 0;
  }
}

// ut_gpa.o

//----- (004127C0) --------------------------------------------------------
s16 __fastcall SsUtGetProgAtr(s16 vab_id, s16 prog, ProgAtr *prog_attr_ptr)
{
  const ProgAtr *pProg; // $s0

  if ( svm_vab_used_[vab_id] != 1 )
    return -1;
  SsVmVSetUp_(vab_id, prog);
  pProg = &svm_pg_[prog];
  prog_attr_ptr->tones = pProg->tones;
  prog_attr_ptr->mvol = pProg->mvol;
  prog_attr_ptr->prior = pProg->prior;
  prog_attr_ptr->mode = pProg->mode;
  prog_attr_ptr->mpan = pProg->mpan;
  prog_attr_ptr->attr = pProg->attr;
  return 0;
}

// ut_gva.o

//----- (004128D0) --------------------------------------------------------
s16 __fastcall SsUtGetVagAtr(s16 vab_id, s16 prog, s16 tone, VagAtr *vag_attr_ptr)
{
  const VagAtr *pVag; // $v1

  if ( svm_vab_used_[vab_id] != 1 )
    return -1;
  SsVmVSetUp_(vab_id, prog);
  pVag = &svm_tn_[16 * svm_cur_.m_fake_program + tone];
  vag_attr_ptr->prior = pVag->prior;
  vag_attr_ptr->mode = pVag->mode;
  vag_attr_ptr->vol = pVag->vol;
  vag_attr_ptr->pan = pVag->pan;
  vag_attr_ptr->center = pVag->center;
  vag_attr_ptr->shift = pVag->shift;
  vag_attr_ptr->max = pVag->max;
  vag_attr_ptr->min = pVag->min;
  vag_attr_ptr->vibW = pVag->vibW;
  vag_attr_ptr->vibT = pVag->vibT;
  vag_attr_ptr->porW = pVag->porW;
  vag_attr_ptr->porT = pVag->porT;
  vag_attr_ptr->pbmin = pVag->pbmin;
  vag_attr_ptr->pbmax = pVag->pbmax;
  vag_attr_ptr->adsr1 = pVag->adsr1;
  vag_attr_ptr->adsr2 = pVag->adsr2;
  vag_attr_ptr->prog = pVag->prog;
  vag_attr_ptr->vag = pVag->vag;
  return 0;
}

// ut_gvad.o

//----- (00412B10) --------------------------------------------------------
int __fastcall SsUtGetVagAddr(s16 vab_id, s16 vag_id)
{
  int m_vag_spu_addr; // $a0

  if ( SsVmVSetUp_(vab_id, 0) == -1 )
    return -1;
  if ( (vag_id & 1) != 0 )
  {
    m_vag_spu_addr = svm_pg_[(vag_id - 1) / 2].m_vag_spu_addr_hi;
  }
  else
  {
    m_vag_spu_addr = svm_pg_[(vag_id - 1) / 2].m_vag_spu_addr_lo;
  }
  return (m_vag_spu_addr << 4) | (gVabOffet[svm_cur_.m_vab_id] << 20);
}

// ut_gvaft.o

//----- (00412BF0) --------------------------------------------------------
unsigned int __fastcall SsUtGetVagAddrFromTone(s16 vab_id, s16 prog, s16 tone)
{
  s16 vag; // $v1
  int m_vag_spu_addr; // $a0

  if ( SsVmVSetUp_(vab_id, prog) == -1 )
    return -1;
  vag = svm_tn_[16 * svm_cur_.m_fake_program + tone].vag;
  if ( (vag & 1) != 0 )
  {
    m_vag_spu_addr = svm_pg_[(vag - 1) / 2].m_vag_spu_addr_hi;
  }
  else
  {
    m_vag_spu_addr = svm_pg_[(vag - 1) / 2].m_vag_spu_addr_lo;
  }
  return (m_vag_spu_addr << 4) | (gVabOffet[svm_cur_.m_vab_id] << 20);
}

// ut_gvba.o

//----- (00412D00) --------------------------------------------------------
unsigned int __fastcall SsUtGetVBaddrInSB(s16 vab_id)
{
  if ( (u16)vab_id >= 0x11u )
    return -1;
  if ( svm_vab_used_[vab_id] != 1 )
    return -1;
  return svm_vab_start_[vab_id];
}

// ut_gvh.o

//----- (00412D50) --------------------------------------------------------
s16 __fastcall SsUtGetVabHdr(s16 vab_id, VabHdr *vab_hdr_ptr)
{
  VabHdr *vab_hdr_temp; // $v1

  if ( svm_vab_used_[vab_id] != 1 )
    return -1;
  vab_hdr_temp = svm_vab_vh_[vab_id];
  vab_hdr_ptr->form = vab_hdr_temp->form;
  vab_hdr_ptr->id = vab_hdr_temp->id;
  vab_hdr_ptr->ver = vab_hdr_temp->ver;
  vab_hdr_ptr->ps = vab_hdr_temp->ps;
  vab_hdr_ptr->ts = vab_hdr_temp->ts;
  vab_hdr_ptr->vs = vab_hdr_temp->vs;
  vab_hdr_ptr->mvol = vab_hdr_temp->mvol;
  vab_hdr_ptr->pan = vab_hdr_temp->pan;
  vab_hdr_ptr->attr1 = vab_hdr_temp->attr1;
  vab_hdr_ptr->attr2 = vab_hdr_temp->attr2;
  svm_vh_ = vab_hdr_temp;
  return 0;
}

// ut_key.o

//----- (00412E30) --------------------------------------------------------
s16 __fastcall SsUtKeyOn(s16 vab_id, s16 prog, s16 tone, s16 note, s16 fine, s16 voll, s16 volr)
{
  const ProgAtr *pProg; // $s0
  const VagAtr *pVag; // $v1
  int voice; // $s1

  if ( snd_ev_flag_ == 1 )
    return -1;
  snd_ev_flag_ = 1;
  if ( SsVmVSetUp_(vab_id, prog) )
  {
    snd_ev_flag_ = 0;
    return -1;
  }
  svm_cur_.m_seq_sep_no = 33;
  svm_cur_.m_note = note;
  svm_cur_.m_fine = fine;
  svm_cur_.m_tone = tone;
  if ( voll == volr )
  {
    svm_cur_.m_unk05 = 64;
    svm_cur_.m_voll = voll;
  }
  else
  {
    int volr_lshift_6; // $v0

    volr_lshift_6 = volr << 6;
    if ( volr >= voll )
    {
      int voll_lshift_6; // $v1

      voll_lshift_6 = voll << 6;
      if ( !volr )
        __builtin_trap();
      if ( volr == -1 && (unsigned int)voll_lshift_6 == 0x80000000 )
        __builtin_trap();
      svm_cur_.m_voll = volr;
      svm_cur_.m_unk05 = 127 - voll_lshift_6 / volr;
    }
    else
    {
      if ( !voll )
        __builtin_trap();
      if ( voll == -1 && (unsigned int)volr_lshift_6 == 0x80000000 )
        __builtin_trap();
      svm_cur_.m_unk05 = volr_lshift_6 / voll;
      svm_cur_.m_voll = voll;
    }
  }
  pProg = &svm_pg_[prog];
  svm_cur_.m_mvol = pProg->mvol;
  svm_cur_.m_mpan = pProg->mpan;
  svm_cur_.m_sep_sep_no_tonecount = pProg->tones;
  pVag = &svm_tn_[16 * svm_cur_.m_fake_program + svm_cur_.m_tone];
  svm_cur_.m_prior = pVag->prior;
  svm_cur_.m_vag_idx2 = pVag->vag;
  svm_cur_.m_vol = pVag->vol;
  svm_cur_.m_pan = pVag->pan;
  svm_cur_.m_centre = pVag->center;
  svm_cur_.m_shift = pVag->shift;
  svm_cur_.m_mode = pVag->mode;
  if ( !svm_cur_.m_vag_idx2 || (voice = (u8)SsVmAlloc_(), voice == SsVmMaxVoice_) )
  {
    snd_ev_flag_ = 0;
    return -1;
  }
  svm_cur_.m_voice_idx = voice;
  svm_voice_[voice].m_seq_sep_no = 33;
  svm_voice_[voice].m_vab_id = vab_id;
  svm_voice_[voice].m_prog = prog;
  svm_voice_[voice].m_fake_program = svm_cur_.m_fake_program;
  svm_voice_[voice].m_vag_idx = svm_cur_.m_vag_idx2;
  svm_voice_[voice].m_note = note;
  svm_voice_[voice].m_tone = svm_cur_.m_tone;
  svm_voice_[voice].m_unk1d = 1;
  svm_voice_[voice].m_unk02 = 0;
  svm_voice_[voice].m_voll2 = svm_cur_.m_voll;
  SsVmDoAllocate_();
  if ( svm_cur_.m_vag_idx2 == 255 )
  {
    vmNoiseOn(voice);
  }
  else
  {
    SsVmKeyOnNow_(1, note2pitch2(note, fine));
  }
  snd_ev_flag_ = 0;
  return voice;
}

//----- (00413184) --------------------------------------------------------
s16 __fastcall SsUtKeyOff(s16 vc, s16 vab_id, s16 prog, s16 tone, s16 note)
{
  if ( snd_ev_flag_ == 1 )
    return -1;
  snd_ev_flag_ = 1;
  if ( (u16)vc >= 0x18u )
  {
    snd_ev_flag_ = 0;
    return -1;
  }
  if ( svm_voice_[vc].m_vab_id == vab_id
    && svm_voice_[vc].m_prog == prog
    && svm_voice_[vc].m_tone == tone
    && svm_voice_[vc].m_note == note
    && svm_voice_[vc].m_vag_idx == 255 )
  {
    vmNoiseOff(vc);
  }
  else
  {
    svm_cur_.m_voice_idx = vc;
    SsVmKeyOffNow_();
  }
  svm_voice_[vc].m_b_auto_pan = 0;
  svm_voice_[vc].m_b_auto_vol = 0;
  snd_ev_flag_ = 0;
  return 0;
}

// ut_keyv.o

//----- (004132D0) --------------------------------------------------------
s16 __fastcall SsUtKeyOnV(s16 vc, s16 vab_id, s16 prog, s16 tone, s16 note, s16 fine, s16 voll, s16 volr)
{
  const ProgAtr *pProg; // $s0
  const VagAtr *pVag; // $v1

  if ( snd_ev_flag_ == 1 )
    return -1;
  snd_ev_flag_ = 1;
  if ( (u16)vc >= 0x18u || SsVmVSetUp_(vab_id, prog) )
  {
    snd_ev_flag_ = 0;
    return -1;
  }
  svm_cur_.m_seq_sep_no = 33;
  svm_cur_.m_note = note;
  svm_cur_.m_fine = fine;
  svm_cur_.m_tone = tone;
  if ( voll == volr )
  {
    svm_cur_.m_unk05 = 64;
    svm_cur_.m_voll = voll;
  }
  else
  {
    int volr_lshift_6; // $v0

    volr_lshift_6 = volr << 6;
    if ( volr >= voll )
    {
      int voll_lshift_6; // $v1

      voll_lshift_6 = voll << 6;
      if ( !volr )
        __builtin_trap();
      if ( volr == -1 && (unsigned int)voll_lshift_6 == 0x80000000 )
        __builtin_trap();
      svm_cur_.m_voll = volr;
      svm_cur_.m_unk05 = 127 - voll_lshift_6 / volr;
    }
    else
    {
      if ( !voll )
        __builtin_trap();
      if ( voll == -1 && (unsigned int)volr_lshift_6 == 0x80000000 )
        __builtin_trap();
      svm_cur_.m_voll = voll;
      svm_cur_.m_unk05 = volr_lshift_6 / voll;
    }
  }
  pProg = &svm_pg_[prog];
  svm_cur_.m_mvol = pProg->mvol;
  svm_cur_.m_mpan = pProg->mpan;
  svm_cur_.m_sep_sep_no_tonecount = pProg->tones;
  pVag = &svm_tn_[16 * svm_cur_.m_fake_program + tone];
  svm_cur_.m_prior = pVag->prior;
  svm_cur_.m_vag_idx2 = pVag->vag;
  svm_cur_.m_vol = pVag->vol;
  svm_cur_.m_pan = pVag->pan;
  svm_cur_.m_centre = pVag->center;
  svm_cur_.m_shift = pVag->shift;
  svm_cur_.m_mode = pVag->mode;
  if ( ((u16)svm_cur_.m_vag_idx2 << 16) == 0 )
  {
    snd_ev_flag_ = 0;
    return -1;
  }
  svm_cur_.m_voice_idx = vc;
  svm_voice_[vc].m_seq_sep_no = 33;
  svm_voice_[vc].m_vab_id = vab_id;
  svm_voice_[vc].m_prog = prog;
  svm_voice_[vc].m_fake_program = svm_cur_.m_fake_program;
  svm_voice_[vc].m_vag_idx = svm_cur_.m_vag_idx2;
  svm_voice_[vc].m_note = note;
  svm_voice_[vc].m_unk1d = 1;
  svm_voice_[vc].m_unk02 = 0;
  svm_voice_[vc].m_tone = svm_cur_.m_tone;
  svm_voice_[vc].m_voll2 = svm_cur_.m_voll;
  SsVmDoAllocate_();
  if ( svm_cur_.m_vag_idx2 == 255 )
  {
    vmNoiseOn(vc);
  }
  else
  {
    SsVmKeyOnNow_(1, note2pitch2(note, fine));
  }
  snd_ev_flag_ = 0;
  return vc;
}

//----- (0041362C) --------------------------------------------------------
s16 __fastcall SsUtKeyOffV(s16 vc)
{
  if ( snd_ev_flag_ == 1 )
    return -1;
  snd_ev_flag_ = 1;
  if ( (u16)vc >= 0x18u )
  {
    snd_ev_flag_ = 0;
    return -1;
  }
  svm_cur_.m_voice_idx = vc;
  SsVmKeyOffNow_();
  return 0;
}

// ut_pb.o

//----- (004136B0) --------------------------------------------------------
s16 __fastcall SsUtPitchBend(s16 vc, s16 vab_id, s16 prog, s16 note, s16 pbend)
{
  (void)note;

  SsVmVSetUp_(vab_id, prog);
  svm_cur_.m_seq_sep_no = 33;
  if ( SsVmPBVoice_(vc, 33, vab_id, prog, pbend) << 16 == 0 )
    return -1;
  return 0;
}

// ut_rdel.o

//----- (00413750) --------------------------------------------------------
void __fastcall SsUtSetReverbDelay(s16 delay)
{
  svm_rattr_.delay = delay;
  svm_rattr_.mask = 8;
  SpuSetReverbModeParam(&svm_rattr_);
}

// ut_rdep.o

//----- (00413790) --------------------------------------------------------
void __fastcall SsUtSetReverbDepth(s16 ldepth, s16 rdepth)
{
  svm_rattr_.mask = 6;
  svm_rattr_.depth.left = (__int16)(0x7FFF * ldepth) / 127;
  svm_rattr_.depth.right = (__int16)(0x7FFF * rdepth) / 127;
  SpuSetReverbModeParam(&svm_rattr_);
}

// ut_rev.o

//----- (00413820) --------------------------------------------------------
s16 __fastcall SsUtSetReverbType(s16 type)
{
  int flag_tmp; // $a1
  int type_tmp1; // $v1
  int type_mode_flag_tmp; // $v0
  s16 type_tmp2; // $s0

  flag_tmp = 0;
  type_tmp1 = type;
  if ( (type & 0x8000) != 0 )
  {
    flag_tmp = 1;
    type_tmp1 = -type;
  }
  if ( (u16)type_tmp1 >= 0xAu )
    return -1;
  svm_rattr_.mask = 1;
  if ( flag_tmp )
    type_mode_flag_tmp = (type_tmp1 | 0x100);
  else
    type_mode_flag_tmp = type_tmp1;
  svm_rattr_.mode = type_mode_flag_tmp;
  type_tmp2 = type_tmp1;
  if ( !(_WORD)type_tmp1 )
    SpuSetReverb(0);
  SpuSetReverbModeParam(&svm_rattr_);
  return type_tmp2;
}

//----- (004138C0) --------------------------------------------------------
s16 SsUtGetReverbType(void)
{
  return svm_rattr_.mode;
}

// ut_rfb.o

//----- (004138D0) --------------------------------------------------------
void __fastcall SsUtSetReverbFeedback(s16 feedback)
{
  svm_rattr_.feedback = feedback;
  svm_rattr_.mask = 16;
  SpuSetReverbModeParam(&svm_rattr_);
}

// ut_roff.o

//----- (00413910) --------------------------------------------------------
void SsUtReverbOff(void)
{
  SpuSetReverb(0);
}

// ut_ron.o

//----- (00413930) --------------------------------------------------------
void SsUtReverbOn(void)
{
  SpuSetReverb(1);
}

// ut_spa.o

//----- (00413950) --------------------------------------------------------
s16 __fastcall SsUtSetProgAtr(s16 vab_id, s16 prog, const ProgAtr *prog_attr_ptr)
{
  ProgAtr *pProg; // $s0

  if ( svm_vab_used_[vab_id] != 1 )
    return -1;
  SsVmVSetUp_(vab_id, prog);
  pProg = &svm_pg_[prog];
  pProg->mvol = prog_attr_ptr->mvol;
  pProg->prior = prog_attr_ptr->prior;
  pProg->mode = prog_attr_ptr->mode;
  pProg->mpan = prog_attr_ptr->mpan;
  pProg->attr = prog_attr_ptr->attr;
  return 0;
}

// ut_sva.o

//----- (00413A20) --------------------------------------------------------
s16 __fastcall SsUtSetVagAtr(s16 vab_id, s16 prog, s16 tone, const VagAtr *vag_attr_ptr)
{
  VagAtr *pVag; // $v1

  if ( svm_vab_used_[vab_id] != 1 )
    return -1;
  SsVmVSetUp_(vab_id, prog);
  pVag = &svm_tn_[16 * svm_cur_.m_fake_program + tone];
  pVag->prior = vag_attr_ptr->prior;
  pVag->mode = vag_attr_ptr->mode;
  pVag->vol = vag_attr_ptr->vol;
  pVag->pan = vag_attr_ptr->pan;
  pVag->center = vag_attr_ptr->center;
  pVag->shift = vag_attr_ptr->shift;
  pVag->max = vag_attr_ptr->max;
  pVag->min = vag_attr_ptr->min;
  pVag->vibW = vag_attr_ptr->vibW;
  pVag->vibT = vag_attr_ptr->vibT;
  pVag->porW = vag_attr_ptr->porW;
  pVag->porT = vag_attr_ptr->porT;
  pVag->pbmin = vag_attr_ptr->pbmin;
  pVag->pbmax = vag_attr_ptr->pbmax;
  pVag->adsr1 = vag_attr_ptr->adsr1;
  pVag->adsr2 = vag_attr_ptr->adsr2;
  pVag->prog = vag_attr_ptr->prog;
  pVag->vag = vag_attr_ptr->vag;
  return 0;
}

// ut_svh.o

//----- (00413BF0) --------------------------------------------------------
s16 __fastcall SsUtSetVabHdr(s16 vab_id, const VabHdr *vab_hdr_ptr)
{
  if ( svm_vab_used_[vab_id] != 1 )
    return -1;
  svm_vh_ = svm_vab_vh_[vab_id];
  svm_vh_->mvol = vab_hdr_ptr->mvol;
  svm_vh_->pan = vab_hdr_ptr->pan;
  svm_vh_->attr1 = vab_hdr_ptr->attr2;
  svm_vh_->attr2 = vab_hdr_ptr->attr2;
  return 0;
}

// ut_vvol.o

//----- (00413C80) --------------------------------------------------------
s16 __fastcall SsUtGetDetVVol(s16 vc, s16 *detvoll, s16 *detvolr)
{
  if ( (u16)vc >= 0x18u )
    return -1;
  SpuGetVoiceVolume(vc, detvoll, detvolr);
  return 0;
}

//----- (00413CBC) --------------------------------------------------------
s16 __fastcall SsUtSetDetVVol(s16 vc, s16 detvoll, s16 detvolr)
{
  if ( (u16)vc >= 0x18u )
    return -1;
  svm_sreg_buf_[vc].m_vol_left = detvoll;
  svm_sreg_buf_[vc].m_vol_right = detvolr;
  svm_sreg_dirty_[vc] |= 3;
  return 0;
}

//----- (00413D20) --------------------------------------------------------
s16 __fastcall SsUtGetVVol(s16 vc, s16 *voll, s16 *volr)
{
  s16 voll_tmp; // [sp+10h] [-8h] BYREF
  s16 volr_tmp; // [sp+12h] [-6h] BYREF

  if ( (u16)vc >= 0x18u )
    return -1;
  SpuGetVoiceVolume(vc, &voll_tmp, &volr_tmp);
  *voll = voll_tmp / 129;
  *volr = volr_tmp / 129;
  return 0;
}

//----- (00413DCC) --------------------------------------------------------
s16 __fastcall SsUtSetVVol(s16 vc, s16 voll, s16 volr)
{
  if ( (u16)vc >= 0x18u )
    return -1;
  svm_sreg_buf_[vc].m_vol_left = 129 * voll;
  svm_sreg_buf_[vc].m_vol_right = 129 * volr;
  svm_sreg_dirty_[vc] |= 3;
  return 0;
}

// vm_aloc1.o

//----- (00413E60) --------------------------------------------------------
s16 SsVmAlloc_(void)
{
  u8 voice_to_alloc_idx; // $t3
  u16 lowest_key_stat; // $t4
  char match_counter; // $t2
  int lowest_unk02; // $t0
  char lowest_match; // $t1
  u8 i_cur_1; // $a3
  u16 lowest_prior; // $t5
  int m_priority; // $a2
  unsigned int m_key_stat; // $a1
  int m_unk02; // $v0

  voice_to_alloc_idx = 99;
  lowest_key_stat = -1;
  match_counter = 0;
  lowest_unk02 = 0;
  lowest_match = 99;
  lowest_prior = svm_cur_.m_prior;
  for ( i_cur_1 = 0; i_cur_1 < SsVmMaxVoice_; i_cur_1 += 1 )
  {
    if ( (snd_vmask_ & (1 << i_cur_1)) == 0 )
    {
      if ( !svm_voice_[i_cur_1].m_unk1d )
      {
        if ( !svm_voice_[i_cur_1].m_key_stat )
        {
          voice_to_alloc_idx = i_cur_1;
          break;
        }
      }
      m_priority = svm_voice_[i_cur_1].m_priority;
      if ( m_priority >= lowest_prior )
      {
        if ( m_priority == lowest_prior )
        {
          m_key_stat = (u16)svm_voice_[i_cur_1].m_key_stat;
          ++match_counter;
          if ( m_key_stat >= lowest_key_stat )
          {
            if ( m_key_stat == lowest_key_stat )
            {
              m_unk02 = svm_voice_[i_cur_1].m_unk02;
              if ( lowest_unk02 < m_unk02 )
              {
                lowest_unk02 = (u16)svm_voice_[i_cur_1].m_unk02;
                lowest_match = i_cur_1;
              }
            }
          }
          else
          {
            lowest_unk02 = (u16)svm_voice_[i_cur_1].m_unk02;
            lowest_key_stat = svm_voice_[i_cur_1].m_key_stat;
            lowest_match = i_cur_1;
          }
        }
      }
      else
      {
        lowest_prior = svm_voice_[i_cur_1].m_priority;
        lowest_match = i_cur_1;
        lowest_key_stat = svm_voice_[i_cur_1].m_key_stat;
        lowest_unk02 = (u16)svm_voice_[i_cur_1].m_unk02;
        match_counter = 1;
      }
    }
  }
  if ( voice_to_alloc_idx == 99 )
  {
    voice_to_alloc_idx = lowest_match;
    if ( !match_counter )
      voice_to_alloc_idx = SsVmMaxVoice_;
  }
  if ( voice_to_alloc_idx < SsVmMaxVoice_ )
  {
    int v16; // $a3

    for ( v16 = 0; (u8)v16 < SsVmMaxVoice_; v16 += 1 )
    {
      if ( (snd_vmask_ & (1 << (u8)v16)) == 0 )
        svm_voice_[(u8)v16].m_unk02 += 1;
    }
    svm_voice_[voice_to_alloc_idx].m_unk02 = 0;
    svm_voice_[voice_to_alloc_idx].m_b_auto_pan = 0;
    svm_voice_[voice_to_alloc_idx].m_b_auto_vol = 0;
    svm_voice_[voice_to_alloc_idx].m_priority = svm_cur_.m_prior;
  }
  return voice_to_alloc_idx;
}

// vm_aloc2.o

//----- (004140D0) --------------------------------------------------------
void SsVmDoAllocate_(void)
{
  int v0; // $a1
  u16 vag_spu_addr; // $v0
  const VagAtr *v6; // $v0
  __int16 damper; // $v1

  svm_voice_[svm_cur_.m_voice_idx].m_key_stat = 0x7FFF;
  for ( v0 = 0; v0 < 16; v0 += 1 )
  {
    svm_envx_hist_[v0] &= ~(1 << (svm_cur_.m_voice_idx & 0xFF));
  }
  if ( (svm_cur_.m_vag_idx2 & 1) != 0 )
  {
    vag_spu_addr = svm_pg_[(svm_cur_.m_vag_idx2 - 1) / 2].m_vag_spu_addr_hi;
  }
  else
  {
    vag_spu_addr = svm_pg_[(svm_cur_.m_vag_idx2 - 1) / 2].m_vag_spu_addr_lo;
  }
  svm_sreg_buf2_[svm_cur_.m_voice_idx].m_vag_spu_addr = vag_spu_addr;
  svm_sreg_dirty_[svm_cur_.m_voice_idx] |= 8u;
  svm_sreg_buf2_[svm_cur_.m_voice_idx].m_vab_spu_offset = gVabOffet[svm_cur_.m_vab_id];
  v6 = &svm_tn_[16 * svm_cur_.m_fake_program + svm_cur_.m_tone];
  svm_sreg_buf_[svm_cur_.m_voice_idx].m_adsr1 = v6->adsr1;
  damper = svm_damper_ + (v6->adsr2 & 0x1F);
  if ( damper >= 32 )
    damper = 31;
  svm_sreg_buf_[svm_cur_.m_voice_idx].m_adsr2 = damper | (v6->adsr2 & 0xFFE0);
  svm_sreg_dirty_[svm_cur_.m_voice_idx] |= 0x30u;
}

// vm_autop.o

//----- (004142E0) --------------------------------------------------------
void __fastcall SeAutoPan(s16 vc, s16 start_pan, s16 end_pan, s16 delta_time)
{
  if ( start_pan == end_pan )
    return;
  svm_voice_[vc].m_b_auto_pan = 1;
  svm_voice_[vc].m_auto_pan_start = start_pan;
  svm_voice_[vc].m_auto_pan_end = end_pan;
  if ( ((start_pan - end_pan >= 0) && (start_pan - end_pan < delta_time)) || ((start_pan - end_pan < 0) && (end_pan - start_pan < delta_time)) )
  {
    int v8; // $a0

    if ( end_pan >= start_pan )
    {
      int v12; // $a0
      int v13; // $v1

      v12 = delta_time;
      v13 = start_pan - end_pan;
      if ( v13 == -1 && (unsigned int)v12 == 0x80000000 )
        __builtin_trap();
      svm_voice_[vc].m_auto_pan_amount = 1;
      v8 = -(v12 / v13);
    }
    else
    {
      int v9; // $v1

      v8 = delta_time;
      v9 = start_pan - end_pan;
      if ( v9 == -1 && (unsigned int)v8 == 0x80000000 )
        __builtin_trap();
      v8 = v8 / v9;
      svm_voice_[vc].m_auto_pan_amount = -1;
    }
    svm_voice_[vc].m_auto_pan_dt1 = v8;
    svm_voice_[vc].m_auto_pan_dt2 = v8;
  }
  else
  {
    int v14; // $a0

    v14 = start_pan - end_pan;
    if ( !delta_time )
      __builtin_trap();
    if ( delta_time == -1 && (unsigned int)v14 == 0x80000000 )
      __builtin_trap();
    svm_voice_[vc].m_auto_pan_dt1 = 0;
    svm_voice_[vc].m_auto_pan_dt2 = 0;
    svm_voice_[vc].m_auto_pan_amount = -(__int16)(v14 / delta_time);
  }
}

//----- (00414524) --------------------------------------------------------
void __fastcall SetAutoPan(int vc)
{
  int m_auto_pan_dt2; // $v1
  int v5; // $v0
  int m_auto_pan_amount; // $a0
  char m_auto_pan_start; // $t0
  const VagAtr *pVag; // $v1
  int pan; // $a1
  unsigned int v15; // kr00_4
  unsigned int v16; // $v1
  unsigned int v18; // $a1
  unsigned int v19; // $a2
  int mpan; // $a0

  m_auto_pan_dt2 = (u16)svm_voice_[(__int16)vc].m_auto_pan_dt2;
  svm_voice_[(__int16)vc].m_auto_pan_dt2 = m_auto_pan_dt2 - 1;
  if ( m_auto_pan_dt2 << 16 > 0 )
    return;
  v5 = (u16)svm_voice_[(__int16)vc].m_auto_pan_start + (u16)svm_voice_[(__int16)vc].m_auto_pan_amount;
  svm_voice_[(__int16)vc].m_auto_pan_start = v5;
  m_auto_pan_amount = svm_voice_[(__int16)vc].m_auto_pan_amount;
  if ( m_auto_pan_amount <= 0 )
  {
    if ( m_auto_pan_amount < 0 && (__int16)v5 <= svm_voice_[(__int16)vc].m_auto_pan_end )
    {
      svm_voice_[(__int16)vc].m_auto_pan_start = svm_voice_[(__int16)vc].m_auto_pan_end;
      svm_voice_[(__int16)vc].m_b_auto_pan = 0;
    }
  }
  else if ( (__int16)v5 >= svm_voice_[(__int16)vc].m_auto_pan_end )
  {
    svm_voice_[(__int16)vc].m_auto_pan_start = svm_voice_[(__int16)vc].m_auto_pan_end;
    svm_voice_[(__int16)vc].m_b_auto_pan = 0;
  }
  m_auto_pan_start = svm_voice_[(__int16)vc].m_auto_pan_start;
  if ( svm_cur_.m_voice_idx == (__int16)vc )
    svm_cur_.m_unk05 = svm_voice_[(__int16)vc].m_auto_pan_start;
  pVag = &svm_tn_[(u16)svm_voice_[(__int16)vc].m_tone + (svm_voice_[(__int16)vc].m_fake_program * 16)];
  pan = (char)pVag->pan;
  v15 = svm_voice_[(__int16)vc].m_voll2 * 0x3FFF * svm_vh_->mvol / 16129 * svm_pg_[svm_voice_[(__int16)vc].m_prog].mvol * pVag->vol;
  v16 = v15 / 0x3F01;
  if ( pan >= 64 )
  {
    v19 = v15 / 0x3F01;
    v18 = (v16 * (127 - pan)) >> 6;
  }
  else
  {
    unsigned int v17; // $lo

    v17 = v16 * pan;
    v18 = v15 / 0x3F01;
    v19 = v17 >> 6;
  }
  mpan = (char)svm_pg_[svm_voice_[(__int16)vc].m_prog].mpan;
  if ( mpan >= 64 )
  {
    int v22; // $v1

    v22 = (u16)v18 * (127 - mpan);
    v18 = (unsigned int)v22 >> 6;
    if ( v22 < 0 )
      v18 = (unsigned int)(v22 + 63) >> 6;
  }
  else
  {
    int v21; // $v0

    v21 = (u16)v19 * mpan;
    v19 = (unsigned int)v21 >> 6;
    if ( v21 < 0 )
      v19 = (unsigned int)(v21 + 63) >> 6;
  }
  if ( m_auto_pan_start >= 64 )
  {
    int v24; // $v1

    v24 = (u16)v18 * (127 - m_auto_pan_start);
    v18 = (unsigned int)v24 >> 6;
    if ( v24 < 0 )
      v18 = (unsigned int)(v24 + 63) >> 6;
  }
  else
  {
    int v23; // $v0

    v23 = (u16)v19 * m_auto_pan_start;
    v19 = (unsigned int)v23 >> 6;
    if ( v23 < 0 )
      v19 = (unsigned int)(v23 + 63) >> 6;
  }
  if ( svm_stereo_mono_ == 1 )
  {
    if ( (u16)v18 >= (unsigned int)(u16)v19 )
      v19 = v18;
    else
      v18 = v19;
  }
  svm_voice_[(__int16)vc].m_auto_pan_dt2 = svm_voice_[(__int16)vc].m_auto_pan_dt1;
  svm_sreg_buf_[vc].m_vol_left = v18;
  svm_sreg_buf_[vc].m_vol_right = v19;
  svm_sreg_dirty_[(__int16)vc] |= 3;
}

// vm_autov.o

//----- (00414900) --------------------------------------------------------
void __fastcall SeAutoVol(s16 vc, s16 start_vol, s16 end_vol, s16 delta_time)
{
  if ( start_vol == end_vol )
    return;
  svm_voice_[vc].m_b_auto_vol = 1;
  svm_voice_[vc].m_auto_vol_start = start_vol;
  svm_voice_[vc].m_auto_vol_end = end_vol;
  if ( ((start_vol - end_vol >= 0) && (start_vol - end_vol < delta_time)) || ((start_vol - end_vol < 0) && (end_vol - start_vol < delta_time)) )
  {
    int v8; // $a0

    if ( end_vol >= start_vol )
    {
      int v12; // $a0
      int v13; // $v1

      v12 = delta_time;
      v13 = start_vol - end_vol;
      if ( v13 == -1 && (unsigned int)v12 == 0x80000000 )
        __builtin_trap();
      svm_voice_[vc].m_auto_vol_amount = 1;
      v8 = -(v12 / v13);
    }
    else
    {
      int v9; // $v1

      v8 = delta_time;
      v9 = start_vol - end_vol;
      if ( v9 == -1 && (unsigned int)v8 == 0x80000000 )
        __builtin_trap();
      svm_voice_[vc].m_auto_vol_amount = -1;
      v8 = v8 / v9;
    }
    svm_voice_[vc].m_auto_vol_dt1 = v8;
    svm_voice_[vc].m_auto_vol_dt2 = v8;
  }
  else
  {
    int v14; // $a0

    v14 = start_vol - end_vol;
    if ( !delta_time )
      __builtin_trap();
    if ( delta_time == -1 && (unsigned int)v14 == 0x80000000 )
      __builtin_trap();
    svm_voice_[vc].m_auto_vol_dt1 = 0;
    svm_voice_[vc].m_auto_vol_dt2 = 0;
    svm_voice_[vc].m_auto_vol_amount = -(__int16)(v14 / delta_time);
  }
}

//----- (00414B44) --------------------------------------------------------
void __fastcall SetAutoVol(int vc)
{
  int m_auto_vol_dt2; // $v1
  s16 v5; // $v0
  int m_auto_vol_amount; // $a0
  s16 m_auto_vol_start; // $v1
  unsigned int v9; // $v1
  unsigned int v10; // $a1
  unsigned int v11; // $a2

  m_auto_vol_dt2 = (u16)svm_voice_[(__int16)vc].m_auto_vol_dt2;
  svm_voice_[(__int16)vc].m_auto_vol_dt2 = m_auto_vol_dt2 - 1;
  if ( m_auto_vol_dt2 << 16 > 0 )
    return;
  v5 = svm_voice_[(__int16)vc].m_auto_vol_start + svm_voice_[(__int16)vc].m_auto_vol_amount;
  svm_voice_[(__int16)vc].m_auto_vol_start = v5;
  m_auto_vol_amount = svm_voice_[(__int16)vc].m_auto_vol_amount;
  if ( m_auto_vol_amount > 0 )
  {
    if ( svm_voice_[(__int16)vc].m_auto_vol_end <= v5 )
    {
      svm_voice_[(__int16)vc].m_auto_vol_start = svm_voice_[(__int16)vc].m_auto_vol_end;
      svm_voice_[(__int16)vc].m_b_auto_vol = 0;
    }
  }
  if ( m_auto_vol_amount < 0 )
  {
    if ( svm_voice_[(__int16)vc].m_auto_vol_end >= v5 )
    {
      svm_voice_[(__int16)vc].m_auto_vol_start = svm_voice_[(__int16)vc].m_auto_vol_end;
      svm_voice_[(__int16)vc].m_b_auto_vol = 0;
    }
  }
  m_auto_vol_start = svm_voice_[(__int16)vc].m_auto_vol_start;
  svm_cur_.m_voll = m_auto_vol_start;
  v9 = m_auto_vol_start * 0x3FFF * svm_vh_->mvol / 16129 * svm_cur_.m_mvol * svm_cur_.m_vol / 0x3F01u;
  if ( (u8)svm_cur_.m_pan >= 0x40u )
  {
    v11 = v9;
    v10 = (v9 * (127 - (u8)svm_cur_.m_pan)) >> 6;
  }
  else
  {
    v10 = v9;
    v11 = (v9 * (u8)svm_cur_.m_pan) >> 6;
  }
  if ( (u8)svm_cur_.m_mpan >= 0x40u )
  {
    int v13; // $v1

    v13 = (u16)v10 * (127 - (u8)svm_cur_.m_mpan);
    v10 = (unsigned int)v13 >> 6;
    if ( v13 < 0 )
      v10 = (unsigned int)(v13 + 63) >> 6;
  }
  else
  {
    int v12; // $v0

    v12 = (u16)v11 * (u8)svm_cur_.m_mpan;
    v11 = (unsigned int)v12 >> 6;
    if ( v12 < 0 )
      v11 = (unsigned int)(v12 + 63) >> 6;
  }
  if ( (u8)svm_cur_.m_unk05 >= 0x40u )
  {
    int v15; // $v1

    v15 = (u16)v10 * (127 - (u8)svm_cur_.m_unk05);
    v10 = (unsigned int)v15 >> 6;
    if ( v15 < 0 )
      v10 = (unsigned int)(v15 + 63) >> 6;
  }
  else
  {
    int v14; // $v0

    v14 = (u16)v11 * (u8)svm_cur_.m_unk05;
    v11 = (unsigned int)v14 >> 6;
    if ( v14 < 0 )
      v11 = (unsigned int)(v14 + 63) >> 6;
  }
  if ( svm_stereo_mono_ == 1 )
  {
    if ( (u16)v10 >= (unsigned int)(u16)v11 )
      v11 = v10;
    else
      v10 = v11;
  }
  svm_voice_[(__int16)vc].m_auto_vol_dt2 = svm_voice_[(__int16)vc].m_auto_vol_dt1;
  svm_sreg_buf_[vc].m_vol_left = v10;
  svm_sreg_buf_[vc].m_vol_right = v11;
  svm_sreg_dirty_[(__int16)vc] |= 3;
}

// vm_doff.o

//----- (00414EA0) --------------------------------------------------------
void SsVmDamperOff_(void)
{
  svm_damper_ = 0;
}

//----- (00414EB0) --------------------------------------------------------
void SsVmDamperOn_(void)
{
  svm_damper_ = 2;
}

// vm_f.o

//----- (00414ED0) --------------------------------------------------------
void __attribute__((optimize("no-unroll-loops"))) __fastcall wait1fsa()
{
  int i; // [sp+0h] [-8h]
  int curdum; // [sp+4h] [-4h]

  curdum = 13;
  for ( i = 0; i < 1000; ++i )
  {
    curdum *= 3;
    __asm__ __volatile__("" : "+g" (curdum) : :);
  }
}

//----- (00414F24) --------------------------------------------------------
void __fastcall DumpSpu()
{
  int cur_i_1; // $s0
  int cur_i_2; // $s0

  for ( cur_i_1 = 0; (u16)cur_i_1 < 0x1A2u; cur_i_1 += 1 )
  {
    int curdata_1; // $v1

    curdata_1 = *(u16 *)(2 * (u16)cur_i_1 + (SpuGetCore() << 10) + 0xbf900000);
    printf("  0x%3x  0x%4x \n", (u16)cur_i_1, curdata_1);
  }
  for ( cur_i_2 = 944; (u16)cur_i_2 < 0x3C4u; cur_i_2 += 1 )
  {
    int curdata_2; // $v1

    curdata_2 = *(u16 *)(2 * (u16)cur_i_2 + 40 * SpuGetCore() + 0xbf900000);
    printf("  0x%3x  0x%4x \n", (u16)cur_i_2, curdata_2);
  }
  printf(" ------------------------------------\n");
}

//----- (00414FF4) --------------------------------------------------------
void __fastcall DumpVoice()
{
  u16 i; // $s2
  u16 cur_i_1; // $s0
  u16 cur_j_1; // $s0

  for ( i = 0; i < 0x10u; ++i )
  {
    if ( (((int)*((vu16 *)0xBF9001A0) >> i) & 1) != 0 )
    {
      printf("voice = %d\n", i);
      for ( cur_i_1 = 0; cur_i_1 < 8u; cur_i_1 += 1 )
      {
        printf("  0x%3x  0x%4x \n", cur_i_1, *(u16 *)(2 * cur_i_1 + 16 * i + 0xbf900000));
      }
      for ( cur_j_1 = 224; cur_j_1 < 0xE6u; cur_j_1 += 1 )
      {
        printf("  0x%3x  0x%4x \n", cur_j_1, *(u16 *)(2 * cur_j_1 + 12 * i + 0xbf900000));
      }
      printf(" ------------------------------------\n");
    }
  }
}

//----- (00415114) --------------------------------------------------------
void __fastcall DumpVoice2()
{
  u16 i; // $s2
  u16 cur_i_1; // $s0
  u16 cur_j_1; // $s0

  for ( i = 0; i < 0x10u; ++i )
  {
    if ( (((int)svm_okon1_ >> i) & 1) != 0 )
    {
      if ( i >= 5u )
      {
        *(_WORD *)(16 * i + 0xbf900000) = 0;
        *(_WORD *)(16 * i + 0xbf900002) = 0;
      }
      printf("voice = %d\n", i);
      for ( cur_i_1 = 0; cur_i_1 < 8u; cur_i_1 += 1 )
      {
        printf("  0x%3x  0x%4x \n", cur_i_1, *(u16 *)(2 * cur_i_1 + 16 * i + 0xbf900000));
      }
      for ( cur_j_1 = 224; cur_j_1 < 0xE6u; cur_j_1 += 1 )
      {
        printf("  0x%3x  0x%4x \n", cur_j_1, *(u16 *)(2 * cur_j_1 + 12 * i + 0xbf900000));
      }
      printf(" ------------------------------------\n");
    }
  }
}

//----- (00415248) --------------------------------------------------------
void SsVmFlush_(void)
{
  int v1; // $s0
  signed int v4; // $s0
  int v12; // $s0
  int mask; // $s0
  SpuVoiceAttr voice_attr; // [sp+10h] [-40h] BYREF

  svm_envx_ptr_ = ((_BYTE)svm_envx_ptr_ + 1) & 0xF;
  svm_envx_hist_[svm_envx_ptr_] = 0;
  for ( v1 = 0; v1 < SsVmMaxVoice_; v1 += 1 )
  {
    SpuGetVoiceEnvelope(v1, &(svm_voice_[v1].m_key_stat));
    if ( !svm_voice_[v1].m_key_stat )
      svm_envx_hist_[svm_envx_ptr_] |= 1 << v1;
  }
  if ( !svm_auto_kof_mode_ )
  {
    int voiceBits; // $s2
    int v7; // $s0

    voiceBits = -1;
    for (v4 = 0; v4 < 15; v4 += 1)
    {
      voiceBits &= svm_envx_hist_[v4];
    }
    for ( v7 = 0; v7 < SsVmMaxVoice_; v7 += 1 )
    {
      if ( (voiceBits & (1 << v7)) != 0 )
      {
        if ( svm_voice_[v7].m_unk1d == 2 )
        {
          int mask_1; // $a1
          int mask2; // $v0

          mask_1 = 1 << v7;
          mask2 = 0;
          if ( v7 >= 16 )
          {
            mask_1 = 0;
            mask2 = 1 << (v7 - 16);
          }
          SpuSetNoiseVoice(0, ((u8)mask2 << 16) | (__int16)mask_1);
        }
        svm_voice_[v7].m_unk1d = 0;
      }
    }
  }
  svm_okon1_ &= ~svm_okof1_;
  svm_okon2_ &= ~svm_okof2_;
  for (v4 = 0; v4 < 24; v4 += 1)
  {
    if ( svm_voice_[v4].m_b_auto_vol )
      autovol_(v4);
    if ( svm_voice_[v4].m_b_auto_pan )
      autopan_(v4);
  }
  for (v12 = 0; v12 < 24; v12 += 1)
  {
    voice_attr.mask = 0;
    voice_attr.voice = 1 << v12;
    if ( (svm_sreg_dirty_[v12] & 1) != 0 )
    {
      voice_attr.mask = 3;
      voice_attr.volume.left = svm_sreg_buf_[v12].m_vol_left;
      voice_attr.volume.right = svm_sreg_buf_[v12].m_vol_right;
      if ( voice_attr.volume.left == 614 )
        voice_attr.volume.left = 615;
      if ( voice_attr.volume.right == 614 )
        voice_attr.volume.right = 615;
    }
    if ( (svm_sreg_dirty_[v12] & 4) != 0 )
    {
      voice_attr.mask |= 0x10u;
      voice_attr.pitch = svm_sreg_buf_[v12].m_pitch;
    }
    if ( (svm_sreg_dirty_[v12] & 8) != 0 )
    {
      voice_attr.mask |= 0x80u;
      voice_attr.addr = (svm_sreg_buf2_[v12].m_vag_spu_addr << 4)
                      + (svm_sreg_buf2_[v12].m_vab_spu_offset << 20);
    }
    if ( (svm_sreg_dirty_[v12] & 0x10) != 0 )
    {
      voice_attr.mask |= 0x60000u;
      voice_attr.adsr1 = svm_sreg_buf_[v12].m_adsr1;
      voice_attr.adsr2 = svm_sreg_buf_[v12].m_adsr2;
    }
    if ( voice_attr.mask )
      SpuSetVoiceAttr(&voice_attr);
    svm_sreg_dirty_[v12] = 0;
  }
  SpuSetKey(0, ((u8)svm_okof2_ << 16) | svm_okof1_);
  SpuSetKey(1, ((u8)svm_okon2_ << 16) | svm_okon1_);
  mask = 0xFFFFFF >> (24 - SsVmMaxVoice_);
  // cppcheck-suppress badBitmaskCheck
  SpuSetReverbVoice(8, ((((u32)svm_orev2_ << 16) | svm_orev1_) & mask) | (SpuGetReverbVoice() & ~mask));
  SpuSetNoiseVoice(8, ((((u32)svm_onos2_ << 16) | svm_onos1_) & mask) | (SpuGetNoiseVoice() & ~mask));
  svm_okof1_ = 0;
  svm_okof2_ = 0;
  svm_okon1_ = 0;
  svm_okon2_ = 0;
  svm_onos1_ = 0;
  svm_onos2_ = 0;
}

// vm_init.o

//----- (00415730) --------------------------------------------------------
void __fastcall SsVmInit_(int voice_count)
{
  char v1; // $s1
  u16 v8; // $s0
  SpuVoiceAttr voice_attr; // [sp+10h] [-40h] BYREF

  v1 = voice_count;
  spu_setInTransfer_(0);
  svm_damper_ = 0;
  SpuInitMalloc(32, (char *)top);
  memset(&svm_sreg_buf_, 0, sizeof(svm_sreg_buf_));
  memset(&svm_sreg_buf2_, 0, sizeof(svm_sreg_buf2_));
  memset(&svm_sreg_dirty_, 0, sizeof(svm_sreg_dirty_));
  svm_vab_count_ = 0;
  memset(&svm_vab_used_, 0, sizeof(svm_vab_used_));
  if ( (v1 & 0xFFFFu) < 0x18 )
    SsVmMaxVoice_ = v1;
  else
    SsVmMaxVoice_ = 24;
  v8 = 0;
  voice_attr.mask = 393363;
  voice_attr.pitch = 4096;
  voice_attr.addr = 20480;
  voice_attr.adsr1 = -32513;
  voice_attr.volume.left = 0;
  voice_attr.volume.right = 0;
  for ( voice_attr.adsr2 = 0x4000; v8 < SsVmMaxVoice_; ++v8 )
  {
    svm_voice_[v8].m_unk02 = 24;
    svm_voice_[v8].m_vag_idx = 255;
    svm_voice_[v8].m_unk1d = 0;
    svm_voice_[v8].m_pitch = 0;
    svm_voice_[v8].m_key_stat = 0;
    svm_voice_[v8].m_seq_sep_no = -1;
    svm_voice_[v8].m_fake_program = 0;
    svm_voice_[v8].m_prog = 0;
    svm_voice_[v8].m_tone = 255;
    svm_voice_[v8].m_voll1 = 0;
    svm_voice_[v8].m_channel_idx = 0;
    svm_voice_[v8].m_pan = 64;
    svm_voice_[v8].m_voll2 = 0;
    svm_voice_[v8].m_b_auto_vol = 0;
    svm_voice_[v8].m_auto_vol_amount = 0;
    svm_voice_[v8].m_auto_vol_dt1 = 0;
    svm_voice_[v8].m_auto_vol_dt2 = 0;
    svm_voice_[v8].m_b_auto_pan = 0;
    svm_voice_[v8].m_auto_pan_amount = 0;
    svm_voice_[v8].m_auto_pan_dt1 = 0;
    svm_voice_[v8].m_auto_pan_dt2 = 0;
    svm_voice_[v8].m_auto_pan_start = 0;
    svm_voice_[v8].m_auto_vol_start = 0;
    voice_attr.voice = 1 << v8;
    SpuSetVoiceAttr(&voice_attr);
    svm_cur_.m_voice_idx = v8;
    SsVmKeyOffNow_();
  }
  svm_rattr_.mask = 0;
  svm_rattr_.depth.left = 0x3FFF;
  svm_rattr_.depth.right = 0x3FFF;
  svm_rattr_.mode = 0;
  svm_okon1_ = 0;
  svm_okon2_ = 0;
  svm_okof1_ = 0;
  svm_orev1_ = 0;
  svm_orev2_ = 0;
  svm_onos1_ = 0;
  svm_onos2_ = 0;
  svm_auto_kof_mode_ = 0;
  svm_stereo_mono_ = 0;
  svm_vab_not_send_size_ = 0;
  kMaxPrograms = 128;
  SsVmFlush_();
}

// vm_key.o

//----- (00415A90) --------------------------------------------------------
int __fastcall SsVmKeyOn_(int seq_sep_no, s16 vab_id, s16 prog, s16 note, s16 voll, s16 unknown27)
{
  int on_keys_mask_1; // $s2
  libsnd2_sequence_struct_t *score_struct; // $s5
  int on_keys_mask_2; // $v0
  const ProgAtr *prog_attr_Ptr; // $v0
  u8 selected_vag_count; // $s3
  const VagAtr *vag_attr_ptr; // $v0
  int v16; // $s1
  u8 vag_nums[128]; // [sp+10h] [-110h] BYREF
  u8 vag_index_nums[128]; // [sp+90h] [-90h] BYREF

  score_struct = NULL;
  if ( seq_sep_no != 33 )
  {
    score_struct = &ss_score_[(u8)seq_sep_no][(seq_sep_no & 0xFF00) >> 8];
  }
  on_keys_mask_1 = 0;
  on_keys_mask_2 = -1;
  if ( SsVmVSetUp_(vab_id, prog) != 0 )
  {
    return on_keys_mask_2;
  }
  svm_cur_.m_seq_sep_no = seq_sep_no;
  svm_cur_.m_note = note;
  svm_cur_.m_fine = 0;
  if ( score_struct != NULL )
    svm_cur_.m_voll = (u16)voll * score_struct->m_vol[score_struct->m_channel_idx] / 127;
  else
    svm_cur_.m_voll = voll;
  svm_cur_.m_unk05 = unknown27;
  prog_attr_Ptr = &svm_pg_[prog];
  svm_cur_.m_mvol = prog_attr_Ptr->mvol;
  svm_cur_.m_mpan = prog_attr_Ptr->mpan;
  svm_cur_.m_sep_sep_no_tonecount = prog_attr_Ptr->tones;
  if ( svm_cur_.m_fake_program >= (int)svm_vh_->ps )
  {
    return -1;
  }
  if ( !voll )
    return SsVmKeyOff_(seq_sep_no, vab_id, prog, note);
  selected_vag_count = SsVmSelectToneAndVag_(vag_index_nums, vag_nums);
  for ( v16 = 0; (u8)v16 < (unsigned int)selected_vag_count; v16 += 1 )
  {
    svm_cur_.m_vag_idx2 = (u8)vag_nums[(u8)v16];
    svm_cur_.m_tone = vag_index_nums[(u8)v16];
    vag_attr_ptr = &svm_tn_[(u16)(svm_cur_.m_tone + 16 * svm_cur_.m_fake_program)];
    svm_cur_.m_prior = vag_attr_ptr->prior;
    svm_cur_.m_vol = vag_attr_ptr->vol;
    svm_cur_.m_pan = vag_attr_ptr->pan;
    svm_cur_.m_centre = vag_attr_ptr->center;
    svm_cur_.m_shift = vag_attr_ptr->shift;
    svm_cur_.m_mode = vag_attr_ptr->mode;
    svm_cur_.m_voice_idx = (u8)SsVmAlloc_();
    if ( svm_cur_.m_voice_idx >= SsVmMaxVoice_ )
    {
      on_keys_mask_1 = -1;
    }
    else
    {
      svm_voice_[svm_cur_.m_voice_idx].m_unk1d = 1;
      svm_voice_[svm_cur_.m_voice_idx].m_unk02 = 0;
      svm_voice_[svm_cur_.m_voice_idx].m_seq_sep_no = seq_sep_no;
      svm_voice_[svm_cur_.m_voice_idx].m_vab_id = svm_cur_.m_vab_id;
      svm_voice_[svm_cur_.m_voice_idx].m_fake_program = svm_cur_.m_fake_program;
      svm_voice_[svm_cur_.m_voice_idx].m_prog = prog;
      if ( score_struct != NULL )
      {
        svm_voice_[svm_cur_.m_voice_idx].m_voll1 = voll;
        svm_voice_[svm_cur_.m_voice_idx].m_channel_idx = score_struct->m_channel_idx;
      }
      svm_voice_[svm_cur_.m_voice_idx].m_pan = unknown27;
      svm_voice_[svm_cur_.m_voice_idx].m_voll2 = svm_cur_.m_voll;
      svm_voice_[svm_cur_.m_voice_idx].m_tone = svm_cur_.m_tone;
      svm_voice_[svm_cur_.m_voice_idx].m_note = note;
      svm_voice_[svm_cur_.m_voice_idx].m_priority = svm_cur_.m_prior;
      svm_voice_[svm_cur_.m_voice_idx].m_vag_idx = svm_cur_.m_vag_idx2;
      SsVmDoAllocate_();
      if ( svm_cur_.m_vag_idx2 == 255 )
      {
        vmNoiseOn(svm_cur_.m_voice_idx);
      }
      else
      {
        SsVmKeyOnNow_(selected_vag_count, note2pitch());
      }
      on_keys_mask_1 |= 1 << (svm_cur_.m_voice_idx & 0xFF);
    }
  }
  return on_keys_mask_1;
}

//----- (00415FB8) --------------------------------------------------------
int __fastcall SsVmKeyOff_(int seq_sep_no, s16 vab_id, s16 prog, s16 note)
{
  int v4; // $s0
  int v5; // $s1

  v5 = 0;
  for ( v4 = 0; (u8)v4 < SsVmMaxVoice_; v4 += 1 )
  {
    if ( !((snd_vmask_ & (1 << v4)) != 0
      || svm_voice_[v4].m_note != note
      || svm_voice_[v4].m_prog != prog
      || svm_voice_[v4].m_seq_sep_no != (__int16)seq_sep_no
      || svm_voice_[v4].m_vab_id != vab_id) )
    {
      v5 += 1;
      if ( svm_voice_[v4].m_vag_idx == 255 )
      {
        vmNoiseOff(v4);
      }
      else
      {
        svm_cur_.m_voice_idx = (u8)v4;
        SsVmKeyOffNow_();
        continue;
      }
    }
  }
  return v5;
}

//----- (00416118) --------------------------------------------------------
int __fastcall SsVmSeKeyOn_(s16 vab_id, s16 prog, u16 note, int pitch, u16 voll, u16 volr)
{
  s16 unknown27; // $v1
  u16 voll_; // $a1

  (void)pitch;

  if ( voll == volr )
  {
    unknown27 = 64;
    voll_ = voll;
  }
  else if ( volr >= (unsigned int)voll )
  {
    voll_ = volr;
    unknown27 = 127 - (voll << 6) / volr;
  }
  else
  {
    voll_ = voll;
    unknown27 = (volr << 6) / voll;
  }
  return SsVmKeyOn_(33, vab_id, prog, note, voll_, unknown27);
}
// 416154: conditional instruction was optimized away because $a1.4 is in (1..FFFF)
// 416164: conditional instruction was optimized away because $a1.4 is in (1..FFFF)
// 41618C: conditional instruction was optimized away because $v1.4 is in (1..FFFF)
// 41619C: conditional instruction was optimized away because $v1.4 is in (1..FFFF)

//----- (004161FC) --------------------------------------------------------
int __fastcall SsVmSeKeyOff_(s16 vab_id, s16 prog, s16 note)
{
  return SsVmKeyOff_(33, vab_id, prog, note);
}

//----- (00416230) --------------------------------------------------------
void KeyOnCheck(void)
{
  ;
}

// vm_n2p.o

//----- (00416240) --------------------------------------------------------
s16 note2pitch(void)
{
  u8 m_shift; // $a3

  m_shift = svm_cur_.m_shift;
  if ( (svm_cur_.m_shift & 0x80u) != 0 )
    m_shift = 127;
  return SsPitchFromNote(svm_cur_.m_note, 0, svm_cur_.m_centre, m_shift);
}

//----- (00416284) --------------------------------------------------------
s16 __fastcall note2pitch2(s16 note, s16 fine)
{
  VagAtr *pVag; // $v0

  pVag = &svm_tn_[svm_cur_.m_tone + (svm_cur_.m_fake_program * 16)];
  return SsPitchFromNote(note, fine, pVag->center, pVag->shift);
}

//----- (004162EC) --------------------------------------------------------
u16 __fastcall SsPitchFromNote(s16 note, s16 fine, u8 center, u8 shift)
{
  int shift_plus_fine; // $a3
  int shift_plus_fine_div_minus; // $a0
  unsigned int shift_plus_fine_div_minus_tmp; // $a1
  int shift_plus_fine_mod; // $a3
  int shift_plus_fine_mod_tmp; // $t0
  int shift_plus_fine_mul_minus; // $v1
  __int16 v10; // $a2
  int v11; // $a1

  shift_plus_fine = (__int16)(shift + fine);
  shift_plus_fine_div_minus = note + shift_plus_fine / 128 - center;
  shift_plus_fine_div_minus_tmp = shift_plus_fine_div_minus;
  shift_plus_fine_mod = shift_plus_fine % 128;
  shift_plus_fine_mod_tmp = shift_plus_fine_mod;
  if ( (shift_plus_fine_mod & 0x8000) != 0 )
  {
    shift_plus_fine_mod_tmp = shift_plus_fine_mod + 128;
    shift_plus_fine_div_minus_tmp = shift_plus_fine_div_minus - 1 + (__int16)(shift_plus_fine_mod + 128) / 128;
  }
  shift_plus_fine_mul_minus = ((int)((unsigned __int64)(0x2AAAAAABLL * (__int16)shift_plus_fine_div_minus_tmp) >> 32) >> 1)
                            - ((int)(shift_plus_fine_div_minus_tmp << 16 >> 31));
  v10 = (__int16)shift_plus_fine_div_minus_tmp / 12 - 2;
  v11 = (__int16)shift_plus_fine_div_minus_tmp - 12 * shift_plus_fine_mul_minus;
  if ( (v11 & 0x8000) != 0 )
  {
    v11 += 12;
    v10 = shift_plus_fine_mul_minus - 3;
  }
  if ( v10 >= 0 )
    return 0x3FFF;
  return (unsigned int)(((svm_ntable_[v11]
                        * svm_ftable_[shift_plus_fine_mod_tmp]) >> 16)
                      + (1 << (-v10 - 1))) >> -v10;
}

// vm_no1.o

//----- (00416410) --------------------------------------------------------
void __fastcall vmNoiseOn(u8 vc)
{
  unsigned int right_vol_calc; // $a2
  libsnd2_sequence_struct_t *score_struct; // $v1
  unsigned int left_vol_calc; // $a3
  unsigned int left_vol_final; // $s1
  unsigned int right_vol_final; // $s2
  int v8; // $a3
  int v9; // $a2
  int v11; // $a1

  right_vol_calc = svm_cur_.m_voll * 0x3FFF * svm_vh_->mvol / 16129 * svm_cur_.m_mvol * svm_cur_.m_vol / 0x3F01u;
  left_vol_calc = right_vol_calc;
  score_struct = NULL;
  if ( svm_cur_.m_seq_sep_no != 33 )
  {
    score_struct = &ss_score_[(svm_cur_.m_seq_sep_no & 0xFF)][(svm_cur_.m_seq_sep_no & 0xFF00) >> 8];
  }
  if ( score_struct != NULL )
  {
    left_vol_calc = right_vol_calc * (u16)score_struct->m_voll / 0x7F;
    right_vol_calc = right_vol_calc * (u16)score_struct->m_volr / 0x7F;
  }
  if ( (unsigned int)svm_cur_.m_pan >= 0x40 )
  {
    right_vol_final = right_vol_calc;
    left_vol_final = left_vol_calc * (127 - svm_cur_.m_pan) / 0x3F;
  }
  else
  {
    left_vol_final = left_vol_calc;
    right_vol_final = right_vol_calc * svm_cur_.m_pan / 0x3F;
  }
  if ( (unsigned int)svm_cur_.m_mpan >= 0x40 )
    left_vol_final = left_vol_final * (127 - svm_cur_.m_mpan) / 0x3F;
  else
    right_vol_final = right_vol_final * svm_cur_.m_mpan / 0x3F;
  if ( (unsigned int)svm_cur_.m_unk05 >= 0x40 )
    left_vol_final = left_vol_final * (127 - svm_cur_.m_unk05) / 0x3F;
  else
    right_vol_final = svm_cur_.m_unk05 * right_vol_final / 0x3F;
  if ( svm_stereo_mono_ == 1 )
  {
    if ( left_vol_final >= right_vol_final )
      right_vol_final = left_vol_final;
    else
      left_vol_final = right_vol_final;
  }
  if ( score_struct != NULL )
  {
    left_vol_final = left_vol_final * left_vol_final / 0x3FFF;
    right_vol_final = right_vol_final * right_vol_final / 0x3FFF;
  }
  SpuSetNoiseClock((svm_cur_.m_note - svm_cur_.m_centre) & 0x3F);
  svm_sreg_buf_[vc].m_vol_left = left_vol_final;
  svm_sreg_buf_[vc].m_vol_right = right_vol_final;
  svm_sreg_dirty_[vc] |= 3;
  if ( vc >= 0x10u )
  {
    v8 = 0;
    v9 = 1 << (vc - 16);
  }
  else
  {
    v8 = 1 << vc;
    v9 = 0;
  }
  svm_voice_[vc].m_pitch = 10;
  for ( v11 = 0; (__int16)v11 < SsVmMaxVoice_; v11 += 1 )
  {
    if ( (snd_vmask_ & (1 << v11)) == 0 )
    {
      svm_voice_[v11].m_unk1d &= 1u;
    }
  }
  svm_voice_[vc].m_unk1d = 2;
  svm_okon1_ |= v8;
  svm_okon2_ |= v9;
  svm_okof1_ &= ~svm_okon1_;
  svm_okof2_ &= ~svm_okon2_;
  if ( (svm_cur_.m_mode & 4) != 0 )
  {
    svm_orev1_ |= v8;
    svm_orev2_ |= v9;
  }
  else
  {
    svm_orev1_ &= ~(_WORD)v8;
    svm_orev2_ &= ~(_WORD)v9;
  }
  svm_onos1_ = v8;
  svm_onos2_ = v9;
}

// vm_no2.o

//----- (00416990) --------------------------------------------------------
void __fastcall vmNoiseOn2(u8 vc, u16 voll, u16 volr, u16 arg3, u16 arg4)
{
  int vc_mask_tmp1; // $a2
  int vc_mask_tmp2; // $a1
  u16 okon1_tmp; // $v1
  u16 okon2_tmp; // $a0

  (void)arg3;
  (void)arg4;

  svm_sreg_buf_[vc].m_vol_left = voll;
  svm_sreg_buf_[vc].m_vol_right = volr;
  svm_sreg_dirty_[vc] |= 3;
  if ( vc >= 0x10u )
  {
    vc_mask_tmp1 = 0;
    vc_mask_tmp2 = 1 << (vc - 16);
  }
  else
  {
    vc_mask_tmp1 = 1 << vc;
    vc_mask_tmp2 = 0;
  }
  svm_voice_[vc].m_pitch = 10;
  svm_voice_[vc].m_unk1d = 2;
  okon1_tmp = svm_okon1_;
  okon2_tmp = svm_okon2_;
  svm_voice_[vc].m_unk02 = 0;
  svm_okon1_ = okon1_tmp | vc_mask_tmp1;
  svm_okon2_ = okon2_tmp | vc_mask_tmp2;
  svm_okof1_ &= ~(okon1_tmp | vc_mask_tmp1);
  svm_okof2_ &= ~(okon2_tmp | vc_mask_tmp2);
  SpuSetNoiseVoice(1, ((u8)vc_mask_tmp2 << 16) | (u16)vc_mask_tmp1);
}

// vm_noff.o

//----- (00416AC0) --------------------------------------------------------
void __fastcall vmNoiseOff(u8 vc)
{
  svm_voice_[vc].m_unk1d = 0;
  svm_voice_[vc].m_vag_idx = 0;
  svm_voice_[vc].m_pitch = 0;
}

// vm_noise.o

//----- (00416B00) --------------------------------------------------------
void __fastcall SsVmNoiseOnWithAdsr_(s32 voll, s32 volr, s32 arg2, s32 arg3)
{
  int voice_idx_tmp; // $v0

  svm_cur_.m_prior = 127;
  voice_idx_tmp = (u8)SsVmAlloc_();
  svm_cur_.m_voice_idx = voice_idx_tmp;
  if ( voice_idx_tmp < SsVmMaxVoice_ )
    vmNoiseOn2(svm_cur_.m_voice_idx, voll, volr, arg2, arg3);
}

//----- (00416B98) --------------------------------------------------------
void SsVmNoiseOff_(void)
{
  int v0; // $s0

  for ( v0 = 0; (__int16)v0 < SsVmMaxVoice_; v0 += 1 )
  {
    if ( (snd_vmask_ & (1 << v0)) == 0 )
    {
      if ( svm_voice_[v0].m_unk1d == 2 )
      {
        vmNoiseOff(v0);
      }
    }
  }
}

//----- (00416C4C) --------------------------------------------------------
void __fastcall SsVmNoiseOn_(u16 voll, u16 volr)
{
  SsVmNoiseOnWithAdsr_(voll, volr, 33023, 24520);
}

// vm_nowof.o

//----- (00416C80) --------------------------------------------------------
void SsVmKeyOffNow_(void)
{
  int bits_upper; // $a2
  int bits_lower; // $a1
  int m_voice_idx; // $v0
  u16 okof1_tmp; // $v1
  u16 okof2_tmp; // $a0

  if ( (u16)svm_cur_.m_voice_idx >= 0x10u )
  {
    bits_upper = 0;
    bits_lower = 1 << ((svm_cur_.m_voice_idx & 0xFF) - 16);
  }
  else
  {
    bits_upper = 1 << (svm_cur_.m_voice_idx & 0xFF);
    bits_lower = 0;
  }
  m_voice_idx = (u16)svm_cur_.m_voice_idx;
  svm_voice_[m_voice_idx].m_unk1d = 0;
  okof1_tmp = svm_okof1_;
  okof2_tmp = svm_okof2_;
  svm_voice_[m_voice_idx].m_pitch = 0;
  svm_voice_[m_voice_idx].m_vag_idx = 0;
  svm_okof1_ = okof1_tmp | bits_upper;
  svm_okon1_ &= ~(okof1_tmp | bits_upper);
  svm_okof2_ = okof2_tmp | bits_lower;
  svm_okon2_ &= ~(okof2_tmp | bits_lower);
}

// vm_nowon.o

//----- (00416D50) --------------------------------------------------------
void __fastcall SsVmKeyOnNow_(s16 vag_count, s16 pitch)
{
  u16 m_voice_idx; // $t2
  unsigned int left; // $a2
  libsnd2_sequence_struct_t *score_struct; // $v1
  unsigned int left_tmp2; // $a3
  unsigned int right_tmp; // $a0
  unsigned int left_tmp; // $a1
  int bits_lower; // $a2
  int bits_upper; // $a1

  (void)vag_count;

  m_voice_idx = svm_cur_.m_voice_idx;
  left = svm_cur_.m_voll * 0x3FFF * svm_vh_->mvol / 16129 * svm_cur_.m_mvol * svm_cur_.m_vol / 0x3F01u;
  left_tmp2 = left;
  score_struct = NULL;
  if ( svm_cur_.m_seq_sep_no != 33 )
  {
    score_struct = &ss_score_[(svm_cur_.m_seq_sep_no & 0xFF)][(svm_cur_.m_seq_sep_no & 0xFF00) >> 8];
  }
  if ( score_struct != NULL )
  {
    left_tmp2 = left * (u16)score_struct->m_voll / 0x7F;
    left = left * (u16)score_struct->m_volr / 0x7F;
  }
  if ( (u8)svm_cur_.m_pan >= 0x40u )
  {
    left_tmp = left;
    right_tmp = left_tmp2 * (127 - (u8)svm_cur_.m_pan) / 0x3F;
  }
  else
  {
    right_tmp = left_tmp2;
    left_tmp = left * (u8)svm_cur_.m_pan / 0x3F;
  }
  if ( (u8)svm_cur_.m_mpan >= 0x40u )
    right_tmp = right_tmp * (127 - (u8)svm_cur_.m_mpan) / 0x3F;
  else
    left_tmp = left_tmp * (u8)svm_cur_.m_mpan / 0x3F;
  if ( (u8)svm_cur_.m_unk05 >= 0x40u )
    right_tmp = right_tmp * (127 - (u8)svm_cur_.m_unk05) / 0x3F;
  else
    left_tmp = left_tmp * (u8)svm_cur_.m_unk05 / 0x3F;
  if ( svm_stereo_mono_ == 1 )
  {
    if ( right_tmp >= left_tmp )
      left_tmp = right_tmp;
    else
      right_tmp = left_tmp;
  }
  if ( score_struct != NULL )
  {
    right_tmp = right_tmp * right_tmp / 0x3FFF;
    left_tmp = left_tmp * left_tmp / 0x3FFF;
  }
  svm_sreg_buf_[m_voice_idx].m_pitch = pitch;
  svm_sreg_buf_[m_voice_idx].m_vol_left = right_tmp;
  svm_sreg_buf_[m_voice_idx].m_vol_right = left_tmp;
  svm_sreg_dirty_[svm_cur_.m_voice_idx] |= 7u;
  svm_voice_[svm_cur_.m_voice_idx].m_pitch = pitch;
  if ( svm_cur_.m_voice_idx >= 16 )
  {
    bits_lower = 0;
    bits_upper = 1 << ((svm_cur_.m_voice_idx & 0xFF) - 16);
  }
  else
  {
    bits_lower = 1 << (svm_cur_.m_voice_idx & 0xFF);
    bits_upper = 0;
  }
  if ( (svm_cur_.m_mode & 4) != 0 )
  {
    svm_orev1_ |= bits_lower;
    svm_orev2_ |= bits_upper;
  }
  else
  {
    svm_orev1_ &= ~(_WORD)bits_lower;
    svm_orev2_ &= ~(_WORD)bits_upper;
  }
  svm_onos1_ &= ~(_WORD)bits_lower;
  svm_okon2_ |= bits_upper;
  svm_onos2_ &= ~(_WORD)bits_upper;
  svm_okon1_ |= bits_lower;
  svm_okof1_ &= ~svm_okon1_;
  svm_okof2_ &= ~svm_okon2_;
}

// vm_pb.o

//----- (00417230) --------------------------------------------------------
int __fastcall SsVmPBVoice_(s16 vc, s16 seq_sep_num, s16 vab_id, s16 prog, s16 pitch)
{
  if ( svm_voice_[vc].m_seq_sep_no == seq_sep_num && svm_voice_[vc].m_vab_id == vab_id && svm_voice_[vc].m_prog == prog )
  {
    __int16 pitch_converted; // $t0
    int bend_min; // $a2
    int bend_max; // $a1

    pitch_converted = pitch - 64;
    bend_min = (u16)svm_voice_[vc].m_note;
    if ( pitch_converted <= 0 )
    {
      if ( pitch_converted >= 0 )
      {
        bend_max = 0;
      }
      else
      {
        int pbmin_tmp; // $a0

        pbmin_tmp = pitch_converted
                  * svm_tn_[(u16)(svm_voice_[vc].m_tone + 16 * svm_cur_.m_fake_program)].pbmin;
        bend_min = bend_min + pbmin_tmp / 64 - 1;
        bend_max = 2 * (pbmin_tmp % 64) + 127;
      }
    }
    else
    {
      int pbmax_tmp; // $a0

      pbmax_tmp = pitch_converted
                * svm_tn_[(u16)(svm_voice_[vc].m_tone + 16 * svm_cur_.m_fake_program)].pbmax;
      bend_min += pbmax_tmp / 63;
      bend_max = 2 * (pbmax_tmp % 63);
    }
    svm_cur_.m_voice_idx = vc;
    svm_cur_.m_tone = svm_voice_[vc].m_tone;
    svm_sreg_buf_[vc].m_pitch = note2pitch2(bend_min, bend_max);
    svm_sreg_dirty_[vc] |= 4;
    return 1;
  }
  return 0;
}

//----- (00417424) --------------------------------------------------------
int __fastcall SsVmPitchBend_(s16 seq_sep_no, int vab_id, int prog, s16 pitch)
{
  int voice_i_tmp; // $s1
  int voice_offs_tmp; // $s0

  SsVmVSetUp_(vab_id, prog);
  svm_cur_.m_seq_sep_no = seq_sep_no;
  voice_offs_tmp = 0;
  for ( voice_i_tmp = 0; (__int16)voice_i_tmp < SsVmMaxVoice_; voice_i_tmp += 1 )
  {
    voice_offs_tmp += (__int16)SsVmPBVoice_(
                                 voice_i_tmp,
                                 seq_sep_no,
                                 vab_id,
                                 prog,
                                 pitch);
  }
  return voice_offs_tmp;
}

// vm_prog.o

//----- (00417500) --------------------------------------------------------
void __fastcall SsVmSetProgVol_(s16 vab_id, s16 prog, u8 vol)
{
  if ( !SsVmVSetUp_(vab_id, prog) )
    svm_pg_[prog].mvol = vol;
}

//----- (00417570) --------------------------------------------------------
int __fastcall SsVmGetProgVol_(s16 vab_id, s16 prog)
{
  if ( SsVmVSetUp_(vab_id, prog) != 0 )
    return -1;
  return svm_pg_[prog].mvol;
}

//----- (004175C0) --------------------------------------------------------
int __fastcall SsVmSetProgPan_(s16 vab_id, s16 prog, char mpan)
{
  if ( SsVmVSetUp_(vab_id, prog) != 0 )
  {
    return -1;
  }
  svm_pg_[prog].mpan = mpan;
  return svm_pg_[prog].mpan;
}

//----- (00417630) --------------------------------------------------------
int __fastcall SsVmGetProgPan_(s16 vab_id, s16 prog)
{
  if ( SsVmVSetUp_(vab_id, prog) != 0 )
    return -1;
  return svm_pg_[prog].mpan;
}

// vm_seq.o

//----- (00417680) --------------------------------------------------------
void __fastcall SsVmSetSeqVol_(s16 seq_sep_num, s16 voll, s16 volr)
{
  libsnd2_sequence_struct_t *score_struct; // $s1
  int v5; // $s2
  int m_vab_id; // $a0
  const VagAtr *vag_attr_ptr; // $a2
  unsigned int vol_factor; // kr00_4
  unsigned int voll_val; // $a0
  unsigned int pan; // $v1
  unsigned int volr_val; // $a1
  unsigned int mpan; // $v1
  unsigned int m_pan; // $v1

  score_struct = &ss_score_[(u8)seq_sep_num][(seq_sep_num & 0xFF00) >> 8];
  score_struct->m_voll = voll;
  score_struct->m_volr = volr;
  if ( (u16)voll >= 0x7Fu )
    score_struct->m_voll = 127;
  if ( (u16)score_struct->m_volr >= 0x7Fu )
    score_struct->m_volr = 127;
  for ( v5 = 0; (__int16)v5 < SsVmMaxVoice_; v5 += 1 )
  {
    if ( (snd_vmask_ & (1 << v5)) == 0 )
    {
      if ( svm_voice_[v5].m_seq_sep_no == seq_sep_num )
      {
        m_vab_id = svm_voice_[v5].m_vab_id;
        if ( m_vab_id == (char)score_struct->m_vab_id )
        {
          SsVmVSetUp_(m_vab_id, svm_voice_[v5].m_fake_program);
          vag_attr_ptr = &svm_tn_[16 * svm_voice_[v5].m_fake_program + svm_voice_[v5].m_tone];
          vol_factor = svm_vh_->mvol
                     * 0x3FFF
                     * (svm_voice_[v5].m_voll1
                      * score_struct->m_vol[svm_voice_[v5].m_channel_idx]
                      / 127)
                     / 16129
                     * svm_pg_[svm_voice_[v5].m_prog].mvol
                     * vag_attr_ptr->vol;
          voll_val = vol_factor / 0x3F01 * (u16)score_struct->m_voll / 0x7F;
          pan = vag_attr_ptr->pan;
          volr_val = vol_factor / 0x3F01 * (u16)score_struct->m_volr / 0x7F;
          if ( pan >= 0x40 )
            voll_val = voll_val * (127 - pan) / 0x3F;
          else
            volr_val = volr_val * pan / 0x3F;
          mpan = svm_pg_[svm_voice_[(__int16)v5].m_prog].mpan;
          if ( mpan >= 0x40 )
            voll_val = (int)((u16)voll_val * (127 - mpan)) / 63;
          else
            volr_val = (unsigned int)((unsigned __int64)(2181570691LL * (int)((u16)volr_val * mpan)) >> 32) >> 5;
          m_pan = (u8)svm_voice_[(__int16)v5].m_pan;
          if ( m_pan >= 0x40 )
            voll_val = (int)((u16)voll_val * (127 - m_pan)) / 63;
          else
            volr_val = (unsigned int)((unsigned __int64)(2181570691LL * (int)((u16)volr_val * m_pan)) >> 32) >> 5;
          if ( svm_stereo_mono_ == 1 )
          {
            if ( (u16)voll_val >= (unsigned int)(u16)volr_val )
              volr_val = voll_val & 0xFFFF;
            else
              voll_val = volr_val & 0xFFFF;
          }
          svm_sreg_dirty_[(__int16)v5] |= 3u;
          svm_sreg_buf_[(__int16)v5].m_vol_left = (u16)voll_val * (u16)voll_val / 0x3FFF;
          svm_sreg_buf_[(__int16)v5].m_vol_right = (__int16)(volr_val * volr_val) / 0x3FFF;
        }
      }
    }
  }
}

//----- (00417BD8) --------------------------------------------------------
void __fastcall SsVmGetSeqVol_(s16 seq_sep_no, s16 *voll_ptr, s16 *volr_ptr)
{
  const libsnd2_sequence_struct_t *score_struct; // $v1

  svm_cur_.m_seq_sep_no = seq_sep_no;
  score_struct = &ss_score_[(u8)seq_sep_no][(seq_sep_no & 0xFF00) >> 8];
  *voll_ptr = score_struct->m_voll;
  *volr_ptr = score_struct->m_volr;
}

//----- (00417C3C) --------------------------------------------------------
int __fastcall SsVmGetSeqLVol_(s16 seq_sep_no)
{
  const libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[(u8)seq_sep_no][(seq_sep_no & 0xFF00) >> 8];
  svm_cur_.m_seq_sep_no = seq_sep_no;
  return score_struct->m_voll;
}

//----- (00417C84) --------------------------------------------------------
int __fastcall SsVmGetSeqRVol_(s16 seq_sep_no)
{
  const libsnd2_sequence_struct_t *score_struct;

  score_struct = &ss_score_[(u8)seq_sep_no][(seq_sep_no & 0xFF00) >> 8];
  svm_cur_.m_seq_sep_no = seq_sep_no;
  return score_struct->m_volr;
}

//----- (00417CCC) --------------------------------------------------------
void __fastcall SsVmSeqKeyOff_(s16 seq_sep_no)
{
  u8 cur_voice_tmp; // $s0

  for ( cur_voice_tmp = 0; cur_voice_tmp < SsVmMaxVoice_; cur_voice_tmp += 1 )
  {
    if ( (snd_vmask_ & (1 << cur_voice_tmp)) == 0 && svm_voice_[cur_voice_tmp].m_seq_sep_no == seq_sep_no )
    {
      svm_cur_.m_voice_idx = cur_voice_tmp;
      SsVmKeyOffNow_();
    }
  }
}

// vm_spb.o

//----- (00417D80) --------------------------------------------------------
void __fastcall SePitchBend(u8 vc, s16 arg1)
{
  char v8; // $a1
  int tone; // $v0
  int note; // $a2
  int pbend; // $a1

  if ( vc >= 0x18 )
  {
    return;
  }
  svm_cur_.m_fake_program = svm_voice_[vc].m_fake_program;
  v8 = svm_voice_[vc].m_tone;
  svm_cur_.m_voice_idx = vc;
  svm_cur_.m_tone = v8;
  tone = v8 + ((u8)svm_cur_.m_fake_program * 16);
  if ( arg1 < 0 )
  {
    int v13; // $v0

    v13 = arg1 * svm_tn_[tone].pbmin;
    pbend = v13 / 127 + 127;
    note = svm_voice_[vc].m_note + v13 / 127 - 1;
  }
  else
  {
    int v10; // $a0

    v10 = arg1 * svm_tn_[tone].pbmax;
    note = svm_voice_[vc].m_note + v10 / 127;
    pbend = v10 % 127;
  }
  svm_sreg_buf_[vc].m_pitch = note2pitch2(note, pbend);
  svm_sreg_dirty_[vc] |= 4;
}

// vm_stav.o

//----- (00417F20) --------------------------------------------------------
s16 __fastcall SsVmSelectToneAndVag_(u8 *vag_attr_idx_ptr, u8 *vag_nums_ptr)
{
  u8 idx; // $a3
  int v4; // $a2
  const VagAtr *v6; // $a0

  idx = 0;
  for ( v4 = 0; (char)v4 < svm_cur_.m_sep_sep_no_tonecount; v4 += 1 )
  {
    v6 = &svm_tn_[16 * svm_cur_.m_fake_program + v4];
    if ( svm_cur_.m_note >= (int)v6->min )
    {
      if ( v6->max >= svm_cur_.m_note )
      {
        vag_nums_ptr[idx] = v6->vag;
        vag_attr_idx_ptr[(u8)idx] = v4;
        idx += 1;
      }
    }
  }
  return idx;
}

// vm_vib.o

//----- (00417FF0) --------------------------------------------------------
void SeVibOn(void)
{
  ;
}

//----- (00417FF8) --------------------------------------------------------
static void SeVibOff(void)
{
  ;
}

//----- (00418000) --------------------------------------------------------
void SetVib(void)
{
  ;
}

//----- (00418008) --------------------------------------------------------
void SsUtVibrateOn(void)
{
  ;
}

//----- (00418010) --------------------------------------------------------
void SsUtVibrateOff(void)
{
  SeVibOff();
}

// vm_vol.o

//----- (00418040) --------------------------------------------------------
void __fastcall SsVmSetVol_(s16 seq_sep_no, s16 vab_id, s16 prog, s16 voll, s16 volr)
{
  int v7; // $s7
  u8 volr_tmp; // $s6
  libsnd2_sequence_struct_t *score_struct; // $s4
  int v13; // $t0
  int v20; // $v0
  const VagAtr *vag_attr_ptr; // $a2
  unsigned int volcalc; // kr00_4
  unsigned int left_vol; // $a0
  unsigned int pan; // $v1
  unsigned int right_vol; // $a1
  unsigned int mpan; // $v1
  unsigned int vol_selfmul; // $lo

  v7 = 0;
  volr_tmp = volr;
  score_struct = &ss_score_[(u8)seq_sep_no][(seq_sep_no & 0xFF00) >> 8];
  SsVmVSetUp_(vab_id, prog);
  svm_cur_.m_seq_sep_no = seq_sep_no;
  if ( !volr )
    volr_tmp = 1;
  if ( !voll )
    voll = 1;
  for ( v13 = 0; (__int16)v13 < SsVmMaxVoice_; v13 += 1 )
  {
    if ( (snd_vmask_ & (1 << v13)) == 0 )
    {
      if ( svm_voice_[v13].m_seq_sep_no == seq_sep_no )
      {
        if ( svm_voice_[v13].m_prog == prog )
        {
          if ( svm_voice_[v13].m_vab_id == vab_id )
          {
            v20 = score_struct->m_vol[score_struct->m_channel_idx];
            if ( (v20 != 0) || (v20 != (u16)voll) )
            {
              vag_attr_ptr = &svm_tn_[16 * svm_voice_[v13].m_fake_program + svm_voice_[v13].m_tone];
              volcalc = svm_voice_[v13].m_voll1
                      * (u16)voll
                      / 127
                      * 0x3FFF
                      * svm_vh_->mvol
                      / 16129
                      * svm_pg_[prog].mvol
                      * vag_attr_ptr->vol;
              left_vol = volcalc / 0x3F01 * (u16)score_struct->m_voll / 0x7F;
              pan = vag_attr_ptr->pan;
              right_vol = volcalc / 0x3F01 * (u16)score_struct->m_volr / 0x7F;
              if ( pan >= 0x40 )
                left_vol = left_vol * (127 - pan) / 0x3F;
              else
                right_vol = right_vol * pan / 0x3F;
              mpan = svm_pg_[svm_voice_[(__int16)v13].m_prog].mpan;
              if ( mpan >= 0x40 )
                left_vol = left_vol * (127 - mpan) / 0x3F;
              else
                right_vol = right_vol * svm_pg_[svm_voice_[(__int16)v13].m_prog].mpan / 0x3F;
              if ( volr_tmp >= 0x40u )
                left_vol = left_vol * (127 - volr_tmp) / 0x3F;
              else
                right_vol = right_vol * volr_tmp / 0x3F;
              vol_selfmul = left_vol * left_vol;
              if ( svm_stereo_mono_ == 1 )
              {
                if ( left_vol >= right_vol )
                  right_vol = left_vol;
                else
                  left_vol = right_vol;
                vol_selfmul = left_vol * left_vol;
              }
              ++v7;
              svm_sreg_dirty_[(__int16)v13] |= 3u;
              svm_sreg_buf_[(__int16)v13].m_vol_left = vol_selfmul / 0x3FFF;
              svm_sreg_buf_[(__int16)v13].m_vol_right = right_vol * right_vol / 0x3FFF;
            }
            if ( v20 != 0 )
            {
              score_struct->m_vol[score_struct->m_channel_idx] = 1;
            }
          }
        }
      }
    }
  }
}

// vm_vsu.o

//----- (004185E0) --------------------------------------------------------
int __fastcall SsVmVSetUp_(s16 vab_id, s16 prog)
{
  if ( (u16)vab_id >= 0x10u )
    return -1;
  if ( svm_vab_used_[vab_id] != 1 )
    return -1;
  if ( prog >= kMaxPrograms )
    return -1;
  svm_cur_.m_vab_id = vab_id;
  svm_cur_.m_program = prog;
  svm_tn_ = svm_vab_tn_[vab_id];
  svm_vh_ = svm_vab_vh_[vab_id];
  svm_pg_ = svm_vab_pg_[vab_id];
  svm_cur_.m_fake_program = svm_pg_[prog].m_fake_prog_idx;
  return 0;
}

// vs_auto.o

//----- (004186A0) --------------------------------------------------------
void __fastcall SsSetAutoKeyOffMode(s16 mode)
{
  svm_auto_kof_mode_ = mode;
}

// vs_mono.o

//----- (004186B0) --------------------------------------------------------
void SsSetMono(void)
{
  svm_stereo_mono_ = 1;
}

//----- (004186C4) --------------------------------------------------------
void SsSetStereo(void)
{
  svm_stereo_mono_ = 0;
}

// vs_srv.o

//----- (004186E0) --------------------------------------------------------
char __fastcall SsSetReservedVoice(char voices)
{
  if ( (u8)(voices - 1) >= 0x18u )
    return -1;
  SsVmMaxVoice_ = voices;
  return voices;
}

// vs_vab.o

//----- (00418710) --------------------------------------------------------
void __fastcall SsVabClose(s16 vab_id)
{
  if ( (u16)vab_id >= 0x10u )
  {
    return;
  }
  if ( (u8)svm_vab_used_[vab_id] >= 3u )
  {
    return;
  }
  if ( svm_vab_used_[vab_id] == 0 )
  {
    return;
  }
  SpuFree(svm_vab_start_[vab_id]);
  svm_vab_used_[vab_id] = 0;
  --svm_vab_count_;
  if ( spu_getInTransfer_() == 1 )
    spu_setInTransfer_(0);
}

// vs_vfb.o

//----- (004187C0) --------------------------------------------------------
s16 __fastcall SsVabFakeBody(s16 vab_id)
{
  if ( (u16)vab_id >= 0x11u )
    return -1;
  if ( svm_vab_used_[vab_id] != 2 )
    return -1;
  spu_setInTransfer_(0);
  svm_vab_used_[vab_id] = 1;
  return vab_id;
}

// vs_vh.o

//----- (00418830) --------------------------------------------------------
s16 __fastcall SsVabOpenHeadSticky(u8 *addr, s16 vab_id, unsigned int sbaddr)
{
  return SsVabOpenHeadWithMode_(addr, vab_id, VsGetAddr, sbaddr);
}

//----- (00418864) --------------------------------------------------------
s16 __fastcall SsVabFakeHead(u8 *addr, s16 vab_id, unsigned int sbaddr)
{
  return SsVabOpenHeadWithMode_(addr, vab_id, VsGetAddr, sbaddr);
}

//----- (00418898) --------------------------------------------------------
static int __fastcall VsGetAddr(unsigned int size_in_bytes, int mode, s16 vab_id)
{
  (void)size_in_bytes;
  (void)vab_id;

  return mode;
}

//----- (004188A0) --------------------------------------------------------
int __fastcall SsVabOpenHeadWithMode_(u8 *addr, int vab_id, libsnd2_vab_allocate_callback alloc_fn, int mode)
{
  int vab_id_tmp; // $s2
  const VabHdr *vab_hdr_ptr; // $a0
  unsigned int form_chk; // $a1
  ProgAtr *prog_atr_ptr; // $a3
  s16 maxPrograms; // $v0
  VagAtr *vag_attr_ptr1; // $a3
  int v21; // $a1
  ProgAtr *v24; // $v1
  int v27; // $a1
  VagAtr *vag_attr_ptr2; // $a3
  int v31; // $v1
  int v32; // $v0
  int vag_idx; // $a1
  int vag_lens[256]; // [sp+10h] [-400h] BYREF

  vab_id_tmp = 16;
  if ( spu_getInTransfer_() == 1 )
    return -1;
  spu_setInTransfer_(1);
  if ( (__int16)vab_id < 16 )
  {
    if ( (__int16)vab_id == -1 )
    {
      int v11; // $a1

      for ( v11 = 0; v11 < 16; v11 += 1 )
      {
        if ( svm_vab_used_[v11] == 0 )
        {
          svm_vab_used_[v11] = 1;
          vab_id_tmp = v11;
          svm_vab_count_ += 1;
          break;
        }
      }
    }
    else
    {
      if ( svm_vab_used_[(__int16)vab_id] == 0 )
      {
        svm_vab_used_[(__int16)vab_id] = 1;
        vab_id_tmp = vab_id;
        svm_vab_count_ += 1;
      }
    }
  }
  if ( vab_id_tmp >= 16 )
  {
    spu_setInTransfer_(0);
    return -1;
  }
  svm_vab_count_ += 1;
  svm_vab_vh_[vab_id_tmp] = (VabHdr *)addr;
  vab_hdr_ptr = (VabHdr *)addr;
  form_chk = *(_DWORD *)addr;
  svm_vab_not_send_size_ = 0;
  prog_atr_ptr = (ProgAtr *)(addr + 32);
  maxPrograms = 64;
  for (;;)
  {
    int fake_prog_idx; // $s0
    int total_vags_size; // $s0
    unsigned int rounded_size; // $s0
    unsigned int spu_alloc_mem; // $a2
    int total_vag_size_1; // $s0

    if ( form_chk >> 8 != 0x564142 )
    {
      break;
    }
    if ( (u8)form_chk == 112 )
    {
      if ( *((int *)addr + 1) >= 5 )
        maxPrograms = 128;
    }
    kMaxPrograms = maxPrograms;
    if ( maxPrograms < (int)*((u16 *)addr + 9) )
    {
      break;
    }
    svm_vab_pg_[vab_id_tmp] = prog_atr_ptr;
    vag_attr_ptr1 = (VagAtr *)&prog_atr_ptr[maxPrograms];
    fake_prog_idx = 0;
    for ( v21 = 0; v21 < maxPrograms; v21 += 1 )
    {
      v24 = &prog_atr_ptr[v21];
      v24->m_fake_prog_idx = fake_prog_idx;
      if ( v24->tones )
        fake_prog_idx += 1;
    }
    total_vags_size = 0;
    svm_vab_tn_[vab_id_tmp] = vag_attr_ptr1;
    vag_attr_ptr2 = &vag_attr_ptr1[16 * vab_hdr_ptr->ps];
    for ( v27 = 0; v27 < 256; v27 += 1 )
    {
      if ( vab_hdr_ptr->vs >= v27 )
      {
        v31 = *(u16 *)&vag_attr_ptr2->prior;
        v32 = 4 * v31;
        if ( vab_hdr_ptr->ver >= 5 )
          v32 = 8 * v31;
        vag_lens[v27] = v32;
        total_vags_size += vag_lens[v27];
      }
      vag_attr_ptr2 = (VagAtr *)((char *)vag_attr_ptr2 + 2);
    }
    rounded_size = (total_vags_size + 63) & 0xFFFFFFC0;
    spu_alloc_mem = alloc_fn(rounded_size, mode, (__int16)vab_id_tmp);
    if ( spu_alloc_mem == 0xFFFFFFFF )
    {
      return -1;
    }
    gVabOffet[(__int16)vab_id_tmp] = spu_alloc_mem > 0xFFFFF;
    if ( spu_alloc_mem + rounded_size > 0x1FAFF0 )
    {
      break;
    }
    svm_vab_start_[(__int16)vab_id_tmp] = spu_alloc_mem;
    total_vag_size_1 = 0;
    for ( vag_idx = 0; vag_idx <= vab_hdr_ptr->vs; vag_idx += 1 )
    {
      total_vag_size_1 += vag_lens[vag_idx];
      if ( (vag_idx & 1) != 0 )
        prog_atr_ptr[vag_idx / 2].m_vag_spu_addr_lo = (spu_alloc_mem + total_vag_size_1) >> 4;
      else
        prog_atr_ptr[vag_idx / 2].m_vag_spu_addr_hi = (spu_alloc_mem + total_vag_size_1) >> 4;
    }
    svm_vab_total_[(__int16)vab_id_tmp] = total_vag_size_1;
    svm_vab_used_[(__int16)vab_id_tmp] = 2;
    return (__int16)vab_id_tmp;
  }
  svm_vab_used_[vab_id_tmp] = 0;
  spu_setInTransfer_(0);
  svm_vab_count_ -= 1;
  return -1;
}
// 418A6C: conditional instruction was optimized away because $v1.4 is in (==40|==80)

// vs_vh2.o

//----- (00418CD0) --------------------------------------------------------
s16 __fastcall SsVabOpenHead(u8 *addr, s16 vab_id)
{
  return SsVabOpenHeadWithMode_(addr, vab_id, VsGetAddrSpuMalloc, 0);
}

//----- (00418D04) --------------------------------------------------------
static int __fastcall VsGetAddrSpuMalloc(unsigned int size_in_bytes, int mode, s16 vab_id)
{
  int result; // $v0

  (void)mode;

  result = SpuMalloc(size_in_bytes);
  if ( result == -1 )
  {
    svm_vab_used_[vab_id] = 0;
    spu_setInTransfer_(0);
    --svm_vab_count_;
  }
  return result;
}

// vs_vt.o

//----- (00418D70) --------------------------------------------------------
s16 __fastcall SsVabTransfer(u8 *vh_addr, u8 *vb_addr, s16 vab_id, s16 i_flag)
{
  int v5; // $s1
  s16 v6; // $a1
  int v8; // $s0

  v5 = i_flag;
  v6 = SsVabOpenHead(vh_addr, vab_id);
  if ( v6 < 0 )
    return -1;
  v8 = SsVabTransBody(vb_addr, v6);
  if ( v8 < 0 )
  {
    return -2;
  }
  if ( (v5 << 16) != 0 )
  {
    SsVabTransCompleted(1);
  }
  return v8;
}

// vs_vtb.o

//----- (00418DF0) --------------------------------------------------------
s16 __fastcall SsVabTransBody(u8 *addr, s16 vab_id)
{
  if ( (u16)vab_id >= 0x11u || svm_vab_used_[vab_id] != 2 )
  {
    spu_setInTransfer_(0);
    return -1;
  }
  SpuSetTransferMode(0);
  if ( !SpuSetTransferStartAddr(svm_vab_start_[vab_id]) )
  {
    spu_setInTransfer_(0);
    return -1;
  }
  SpuWrite(addr, svm_vab_total_[vab_id]);
  svm_vab_used_[vab_id] = 1;
  return vab_id;
}

// vs_vtbp.o

//----- (00418EC0) --------------------------------------------------------
s16 __fastcall SsVabTransBodyPartly(u8 *addr, unsigned int bufsize, s16 vab_id)
{
  unsigned int bufsize_tmp; // $s0
  int new_vabid; // $s1

  if ( (u16)vab_id >= 0x11u || svm_vab_used_[vab_id] != 2 )
  {
    spu_setInTransfer_(0);
    return -1;
  }
  if ( !svm_vab_not_send_size_ )
  {
    vabid_old_2 = vab_id;
    svm_vab_not_send_size_ = svm_vab_total_[vab_id];
    SpuSetTransferMode(0);
    if ( !SpuSetTransferStartAddr(svm_vab_start_[vab_id]) )
    {
      svm_vab_not_send_size_ = 0;
      vabid_old_2 = -1;
      spu_setInTransfer_(0);
      return -1;
    }
  }
  new_vabid = vabid_old_2;
  if ( vabid_old_2 != vab_id )
  {
    spu_setInTransfer_(0);
    return -1;
  }
  bufsize_tmp = bufsize;
  if ( (unsigned int)svm_vab_not_send_size_ < bufsize )
    bufsize_tmp = svm_vab_not_send_size_;
  spu_setInTransfer_(1);
  SpuWritePartly(addr, bufsize_tmp);
  svm_vab_not_send_size_ -= bufsize_tmp;
  if ( svm_vab_not_send_size_ != 0 )
  {
    return -2;
  }
  vabid_old_2 = -1;
  svm_vab_not_send_size_ = 0;
  svm_vab_used_[new_vabid] = 1;
  return new_vabid;
}

// vs_vtc.o

//----- (00419050) --------------------------------------------------------
s16 __fastcall SsVabTransCompleted(s16 immediate_flag)
{
  return SpuIsTransferCompleted(immediate_flag);
}

// vm_aloc3.o

//----- (00419080) --------------------------------------------------------
char SsBlockVoiceAllocation(void)
{
  if ( snd_ev_flag_ == 1 )
    return -1;
  snd_ev_flag_ = 1;
  return 1;
}

//----- (004190AC) --------------------------------------------------------
char SsUnBlockVoiceAllocation(void)
{
  if ( !snd_ev_flag_ )
    return -1;
  snd_ev_flag_ = 0;
  return 1;
}

//----- (004190D8) --------------------------------------------------------
int __fastcall SsAllocateVoices(u8 voices, u8 priority)
{
  int v2; // $s3
  int v3; // $s2
  u16 v4; // $t4
  u16 v5; // $t5
  char v9; // $s1
  int m_priority; // $a3
  unsigned int m_key_stat; // $a2
  int v16; // $s3
  int v17; // $s1
  int v20; // $s0

  v3 = 0;
  for ( v2 = 0; (u8)v2 < (unsigned int)voices; v2 += 1 )
  {
    int m_unk02; // $t2
    char v7; // $t3
    char v8; // $t6

    v4 = -1;
    v5 = priority;
    m_unk02 = 0;
    v7 = 99;
    v8 = 99;
    for ( v9 = 0; (u8)v9 < SsVmMaxVoice_; v9 += 1 )
    {
      if ( ((1 << (u8)v9) & v3) == 0 )
      {
        if ( !svm_voice_[(u8)v9].m_unk1d && !svm_voice_[(u8)v9].m_key_stat )
        {
          v8 = v9;
          break;
        }
        m_priority = svm_voice_[(u8)v9].m_priority;
        if ( m_priority >= v5 )
        {
          if ( m_priority == v5 )
          {
            m_key_stat = (u16)svm_voice_[(u8)v9].m_key_stat;
            if ( m_key_stat >= v4 )
            {
              if ( m_key_stat != v4 || m_unk02 >= svm_voice_[(u8)v9].m_unk02 )
                continue;
              m_unk02 = (u16)svm_voice_[(u8)v9].m_unk02;
            }
            else
            {
              m_unk02 = (u16)svm_voice_[(u8)v9].m_unk02;
              v4 = svm_voice_[(u8)v9].m_key_stat;
            }
            v7 = v9;
          }
        }
        else
        {
          v5 = svm_voice_[(u8)v9].m_priority;
          v4 = svm_voice_[(u8)v9].m_key_stat;
          m_unk02 = (u16)svm_voice_[(u8)v9].m_unk02;
          v7 = v9;
        }
      }
    }
    if ( v7 != 99 )
    {
      v3 |= 1 << v7;
    }
    else if ( v8 != 99 )
    {
      v3 |= 1 << v8;
    }
    else
    {
      return -1;
    }
  }
  v16 = voices;
  for ( v17 = 0; (u8)v17 < SsVmMaxVoice_; v17 += 1 )
  {
    if ( ((1 << v17) & v3) != 0 )
    {
      v16 -= 1;
      v20 = (u8)v17;
      svm_voice_[v20].m_unk02 = (u8)v16;
      svm_voice_[v20].m_priority = priority;
      svm_voice_[v20].m_b_auto_vol = 0;
      svm_voice_[v20].m_b_auto_pan = 0;
      if ( svm_voice_[v20].m_unk1d == 2 )
        SpuSetNoiseVoice(0, 1 << v17);
      svm_voice_[v20].m_unk1d = 1;
    }
    else
    {
      svm_voice_[(u8)v17].m_unk02 += voices;
    }
  }
  return v3;
}

// q_keyon.o

//----- (004193D0) --------------------------------------------------------
void __fastcall SsQueueKeyOn(int voices)
{
  int v1; // $a2

  for ( v1 = 0; (char)v1 < SsVmMaxVoice_; v1 += 1 )
  {
    int v4; // $v1

    v4 = 1 << v1;
    if ( (v4 & voices) != 0 )
    {
      if ( v1 >= 16 )
      {
        int v7; // $v0

        v7 = 1 << (v1 - 16);
        svm_okon2_ |= v7;
        svm_okof2_ &= ~(_WORD)v7;
      }
      else
      {
        svm_okon1_ |= v4;
        svm_okof1_ &= ~(_WORD)v4;
      }
    }
  }
}

//----- (0041949C) --------------------------------------------------------
void __fastcall SsQueueReverb(int voices, int reverb)
{
  int v2; // $a3
  int v8; // $v0
  char v9; // $v0
  int v10; // $v1

  for ( v2 = 0; (char)v2 < 24; v2 += 1 )
  {
    int v5; // $v1

    v5 = 1 << v2;
    if ( (v5 & voices) != 0 )
    {
      v8 = v5 & reverb;
      if ( v2 >= 16 )
      {
        v9 = v2 - 16;
        if ( v8 == 0 )
          v10 = svm_orev2_ & ~(1 << v9);
        else
          v10 = svm_orev2_ | (1 << v9);
        svm_orev2_ = v10;
      }
      else
      {
        if ( v8 )
          svm_orev1_ |= v5;
        else
          svm_orev1_ &= ~(_WORD)v5;
      }
    }
  }
}

//----- (0041956C) --------------------------------------------------------
void __fastcall SsQueueRegisters(int vc, SndRegisterAttr *sra)
{
  u32 mask;

  mask = sra->mask;
  printf("SsQueueRegisters \n");
  if ( mask == 0 )
    mask = 0xFFFFFFFF;
  if ( (mask & 1) != 0 )
  {
    svm_sreg_buf_[vc].m_vol_left = sra->volume.left & 0x7FFF;
    svm_sreg_dirty_[vc] |= 1;
  }
  if ( (mask & 2) != 0 )
  {
    svm_sreg_buf_[vc].m_vol_right = sra->volume.right & 0x7FFF;
    svm_sreg_dirty_[vc] |= 2;
  }
  if ( (mask & 4) != 0 )
  {
    svm_sreg_buf_[vc].m_adsr1 = sra->adsr1;
    svm_sreg_dirty_[vc] |= 0x10;
  }
  if ( (mask & 8) != 0 )
  {
    svm_sreg_buf_[vc].m_adsr2 = sra->adsr2;
    svm_sreg_dirty_[vc] |= 0x20;
  }
  if ( (mask & 0x20) != 0 )
  {
    svm_sreg_buf_[vc].m_pitch = sra->pitch;
    svm_sreg_dirty_[vc] |= 4;
  }
  if ( (mask & 0x10) != 0 )
  {
    svm_sreg_buf2_[vc].m_vag_spu_addr = sra->addr;
    svm_sreg_dirty_[vc] |= 8u;
  }
}

//----- (004197A4) --------------------------------------------------------
s16 __fastcall SsGetActualProgFromProg(s16 vab_id, s16 prog)
{
  if ( !((u16)vab_id < 0x11u && prog >= 0 && kMaxPrograms >= prog) )
    return -1;
  return svm_vab_pg_[vab_id][prog].m_fake_prog_idx;
}

//----- (00419804) --------------------------------------------------------
void __fastcall SsSetVoiceSettings(int vc, const SndVoiceStats *snd_v_attr)
{
  svm_voice_[vc].m_vag_idx = snd_v_attr->vagId;
  svm_voice_[vc].m_pitch = snd_v_attr->pitch;
  svm_voice_[vc].m_voll1 = snd_v_attr->vol;
  svm_voice_[vc].m_pan = snd_v_attr->pan;
  svm_voice_[vc].m_seq_sep_no = 33;
  svm_voice_[vc].m_note = snd_v_attr->note;
  svm_voice_[vc].m_fake_program = snd_v_attr->prog_actual;
  svm_voice_[vc].m_prog = snd_v_attr->prog_num;
  svm_voice_[vc].m_tone = snd_v_attr->tone;
  svm_voice_[vc].m_vab_id = snd_v_attr->vabId;
  svm_voice_[vc].m_voll2 = snd_v_attr->vol;
}

//----- (004198C8) --------------------------------------------------------
s16 __fastcall SsVoiceCheck(int vc, int vab_id, s16 note)
{
  if ( (unsigned int)vc >= 0x18 )
    return -1;
  if ( svm_voice_[vc].m_vab_id != vab_id >> 8 )
    return -1;
  if ( svm_voice_[vc].m_prog != (u8)vab_id )
    return -1;
  if ( svm_voice_[vc].m_note != note )
    return -1;
  return 0;
}

// 000rest_of_imports.o

#if 0
//----- (00419954) --------------------------------------------------------
int Kprintf(const char *format, ...)
{
  int result; // $v0

  return result;
}
// 419954: variable 'result' is possibly undefined

//----- (00419978) --------------------------------------------------------
int __fastcall RegisterIntrHandler(int irq, int mode, int (__fastcall *handler)(void *), void *arg)
{
  int result; // $v0

  return result;
}
// 419978: variable 'result' is possibly undefined

//----- (00419980) --------------------------------------------------------
int __fastcall ReleaseIntrHandler(int irq)
{
  int result; // $v0

  return result;
}
// 419980: variable 'result' is possibly undefined

//----- (00419988) --------------------------------------------------------
int __fastcall EnableIntr(int irq)
{
  int result; // $v0

  return result;
}
// 419988: variable 'result' is possibly undefined

//----- (00419990) --------------------------------------------------------
int __fastcall DisableIntr(int irq, int *res)
{
  int result; // $v0

  return result;
}
// 419990: variable 'result' is possibly undefined

//----- (00419998) --------------------------------------------------------
int __fastcall CpuDisableIntr()
{
  int result; // $v0

  return result;
}
// 419998: variable 'result' is possibly undefined

//----- (004199A0) --------------------------------------------------------
int __fastcall CpuEnableIntr()
{
  int result; // $v0

  return result;
}
// 4199A0: variable 'result' is possibly undefined

//----- (004199C4) --------------------------------------------------------
void FlushDcache(void)
{
  ;
}

//----- (004199E8) --------------------------------------------------------
int printf(const char *format, ...)
{
  int result; // $v0

  return result;
}
// 4199E8: variable 'result' is possibly undefined

//----- (00419A0C) --------------------------------------------------------
int __fastcall SetAlarm(iop_sys_clock_t *sys_clock, unsigned int (__fastcall *alarm_cb)(void *), void *arg)
{
  int result; // $v0

  return result;
}
// 419A0C: variable 'result' is possibly undefined

//----- (00419A14) --------------------------------------------------------
int __fastcall CancelAlarm(unsigned int (__fastcall *alarm_cb)(void *), void *arg)
{
  int result; // $v0

  return result;
}
// 419A14: variable 'result' is possibly undefined

//----- (00419A1C) --------------------------------------------------------
void __fastcall USec2SysClock(u32 usec, iop_sys_clock_t *sys_clock)
{
  ;
}

//----- (00419A40) --------------------------------------------------------
int __fastcall RegisterVblankHandler(int startend, int priority, int (__fastcall *handler)(void *), void *arg)
{
  int result; // $v0

  return result;
}
// 419A40: variable 'result' is possibly undefined

//----- (00419A48) --------------------------------------------------------
int __fastcall ReleaseVblankHandler(int startend, int (__fastcall *handler)(void *))
{
  int result; // $v0

  return result;
}
// 419A48: variable 'result' is possibly undefined
#endif

// nfuncs=510 queued=510 decompiled=510 lumina nreq=0 worse=0 better=0
// ALL OK, 510 function(s) have been successfully decompiled
